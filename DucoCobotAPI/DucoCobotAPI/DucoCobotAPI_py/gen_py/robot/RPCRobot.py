#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def power_on(self, block):
        """
        Parameters:
         - block

        """
        pass

    def power_off(self, block):
        """
        Parameters:
         - block

        """
        pass

    def enable(self, block):
        """
        Parameters:
         - block

        """
        pass

    def disable(self, block):
        """
        Parameters:
         - block

        """
        pass

    def shutdown(self, block):
        """
        Parameters:
         - block

        """
        pass

    def stop(self, block):
        """
        Parameters:
         - block

        """
        pass

    def pause(self, block):
        """
        Parameters:
         - block

        """
        pass

    def resume(self, block):
        """
        Parameters:
         - block

        """
        pass

    def run_program(self, name, block):
        """
        Parameters:
         - name
         - block

        """
        pass

    def set_tool_data(self, name, tool_offset, payload, inertia_tensor):
        """
        Parameters:
         - name
         - tool_offset
         - payload
         - inertia_tensor

        """
        pass

    def get_tool_load(self):
        pass

    def get_tcp_offset(self):
        pass

    def set_wobj(self, name, wobj):
        """
        Parameters:
         - name
         - wobj

        """
        pass

    def set_wobj_offset(self, wobj, active):
        """
        Parameters:
         - wobj
         - active

        """
        pass

    def get_wobj(self):
        pass

    def cal_fkine(self, joints_position, tool, wobj):
        """
        Parameters:
         - joints_position
         - tool
         - wobj

        """
        pass

    def cal_ikine(self, p, q_near, tool, wobj):
        """
        Parameters:
         - p
         - q_near
         - tool
         - wobj

        """
        pass

    def set_digital_output_mode(self, num, type, freq, duty_cycle):
        """
        Parameters:
         - num
         - type
         - freq
         - duty_cycle

        """
        pass

    def set_standard_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        pass

    def set_tool_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        pass

    def get_standard_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_standard_digital_out(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_tool_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_tool_digital_out(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_config_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_standard_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_tool_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_standard_analog_current_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def set_standard_analog_voltage_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        pass

    def set_standard_analog_current_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        pass

    def read_data_485(self):
        pass

    def read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        pass

    def read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        pass

    def read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        pass

    def write_data_485(self, data):
        """
        Parameters:
         - data

        """
        pass

    def write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        pass

    def write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        pass

    def write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        pass

    def tool_read_data_485(self):
        pass

    def tool_read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        pass

    def tool_read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        pass

    def tool_read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        pass

    def tool_write_data_485(self, data):
        """
        Parameters:
         - data

        """
        pass

    def tool_write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        pass

    def tool_write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        pass

    def tool_write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        pass

    def read_data_can(self):
        pass

    def read_raw_data_can(self):
        pass

    def write_data_can(self, id, data):
        """
        Parameters:
         - id
         - data

        """
        pass

    def write_raw_data_can(self, id, data):
        """
        Parameters:
         - id
         - data

        """
        pass

    def get_function_digital_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_function_digital_out(self, num):
        """
        Parameters:
         - num

        """
        pass

    def read_bool_reg(self, num):
        """
        Parameters:
         - num

        """
        pass

    def read_word_reg(self, num):
        """
        Parameters:
         - num

        """
        pass

    def read_float_reg(self, num):
        """
        Parameters:
         - num

        """
        pass

    def write_bool_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        pass

    def write_word_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        pass

    def write_float_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        pass

    def get_function_reg_in(self, num):
        """
        Parameters:
         - num

        """
        pass

    def get_function_reg_out(self, num):
        """
        Parameters:
         - num

        """
        pass

    def movej(self, joints_list, v, a, r, block, op, def_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op
         - def_acc

        """
        pass

    def movej_pose(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def movej2(self, joints_list, v, a, r, block, op, def_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op
         - def_acc

        """
        pass

    def movej_pose2(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def movel(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def movec(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def move_circle(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def tcp_move(self, pose_offset, v, a, r, tool, block, op, def_acc):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - r
         - tool
         - block
         - op
         - def_acc

        """
        pass

    def tcp_move_2p(self, p1, p2, v, a, r, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def wobj_move(self, pose_offset, v, a, r, wobj, block, op, def_acc):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - r
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def wobj_move_2p(self, p1, p2, v, a, r, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def spline(self, pose_list, v, a, tool, wobj, block, op, r, def_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - tool
         - wobj
         - block
         - op
         - r
         - def_acc

        """
        pass

    def spline_op(self, pose_list, v, a, tool, wobj, block, op, r, def_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - tool
         - wobj
         - block
         - op
         - r
         - def_acc

        """
        pass

    def speedj(self, joints_list, a, time, block):
        """
        Parameters:
         - joints_list
         - a
         - time
         - block

        """
        pass

    def speedl(self, pose_list, a, time, block):
        """
        Parameters:
         - pose_list
         - a
         - time
         - block

        """
        pass

    def speed_stop(self, block):
        """
        Parameters:
         - block

        """
        pass

    def servoj(self, joints_list, v, a, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        pass

    def servoj_pose(self, pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        pass

    def servo_tcp(self, pose_offset, v, a, tool, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - tool
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        pass

    def servol(self, pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        pass

    def teach_mode(self, block):
        """
        Parameters:
         - block

        """
        pass

    def end_teach_mode(self, block):
        """
        Parameters:
         - block

        """
        pass

    def modbus_add_signal(self, ip, slave_number, signal_address, signal_type, signal_name):
        """
        Parameters:
         - ip
         - slave_number
         - signal_address
         - signal_type
         - signal_name

        """
        pass

    def modbus_delete_signal(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        pass

    def modbus_read(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        pass

    def modbus_write(self, signal_name, value):
        """
        Parameters:
         - signal_name
         - value

        """
        pass

    def modbus_set_frequency(self, signal_name, frequence):
        """
        Parameters:
         - signal_name
         - frequence

        """
        pass

    def get_last_error(self):
        pass

    def get_noneblock_taskstate(self, id):
        """
        Parameters:
         - id

        """
        pass

    def log_info(self, message):
        """
        Parameters:
         - message

        """
        pass

    def log_error(self, message):
        """
        Parameters:
         - message

        """
        pass

    def simulation(self, sim, block):
        """
        Parameters:
         - sim
         - block

        """
        pass

    def speed(self, val):
        """
        Parameters:
         - val

        """
        pass

    def get_robot_state(self):
        pass

    def get_flange_pose(self):
        pass

    def get_flange_speed(self):
        pass

    def get_flange_acceleration(self):
        pass

    def get_tcp_pose(self):
        pass

    def get_tcp_speed(self):
        pass

    def get_tcp_acceleration(self):
        pass

    def get_tcp_force(self):
        pass

    def get_actual_joints_position(self):
        pass

    def get_target_joints_position(self):
        pass

    def get_actual_joints_speed(self):
        pass

    def get_target_joints_speed(self):
        pass

    def get_actual_joints_acceleration(self):
        pass

    def get_target_joints_acceleration(self):
        pass

    def get_actual_joints_torque(self):
        pass

    def get_target_joints_torque(self):
        pass

    def stop_record_track(self):
        pass

    def start_record_track(self, name, mode, tool, wobj, interval):
        """
        Parameters:
         - name
         - mode
         - tool
         - wobj
         - interval

        """
        pass

    def collision_detect(self, value):
        """
        Parameters:
         - value

        """
        pass

    def replay(self, name, value, mode):
        """
        Parameters:
         - name
         - value
         - mode

        """
        pass

    def set_load_data(self, value):
        """
        Parameters:
         - value

        """
        pass

    def fc_start(self):
        pass

    def fc_stop(self):
        pass

    def fc_config(self, direction, ref_ft, damp, max_vel, number_list, tool, wobj, value):
        """
        Parameters:
         - direction
         - ref_ft
         - damp
         - max_vel
         - number_list
         - tool
         - wobj
         - value

        """
        pass

    def fc_move(self, block):
        """
        Parameters:
         - block

        """
        pass

    def fc_guard_act(self, direction, ref_ft, tool, wobj, type, force_property):
        """
        Parameters:
         - direction
         - ref_ft
         - tool
         - wobj
         - type
         - force_property

        """
        pass

    def fc_guard_deact(self):
        pass

    def fc_force_set_value(self, direction, ref_ft):
        """
        Parameters:
         - direction
         - ref_ft

        """
        pass

    def fc_wait_pos(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        pass

    def fc_wait_vel(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        pass

    def fc_wait_ft(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        pass

    def fc_wait_logic(self, value):
        """
        Parameters:
         - value

        """
        pass

    def fc_get_ft(self):
        pass

    def fc_mode_is_active(self):
        pass

    def start_realtime_mode(self, mode, fileter_bandwidth, com_lost_time):
        """
        Parameters:
         - mode
         - fileter_bandwidth
         - com_lost_time

        """
        pass

    def end_realtime_mode(self):
        pass

    def realtime_data_enqueue(self, realtime_data, block):
        """
        Parameters:
         - realtime_data
         - block

        """
        pass

    def clear_realtime_data_queue(self):
        pass

    def get_realtime_data_queue_size(self):
        pass

    def enable_speed_optimization(self):
        pass

    def disable_speed_optimization(self):
        pass

    def change_recipe(self):
        pass

    def set_system_value_bool(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        pass

    def set_system_value_double(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        pass

    def set_system_value_str(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        pass

    def set_system_value_list(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        pass

    def get_system_value_bool(self, name):
        """
        Parameters:
         - name

        """
        pass

    def get_system_value_double(self, name):
        """
        Parameters:
         - name

        """
        pass

    def get_system_value_str(self, name):
        """
        Parameters:
         - name

        """
        pass

    def get_system_value_list(self, name):
        """
        Parameters:
         - name

        """
        pass

    def trackEnqueue(self, track, block):
        """
        Parameters:
         - track
         - block

        """
        pass

    def trackEnqueueOp(self, track, block):
        """
        Parameters:
         - track
         - block

        """
        pass

    def trackClearQueue(self):
        pass

    def getQueueSize(self):
        pass

    def trackJointMotion(self, speed, acc, block):
        """
        Parameters:
         - speed
         - acc
         - block

        """
        pass

    def trackCartMotion(self, speed, acc, block, tool, wobj, radius):
        """
        Parameters:
         - speed
         - acc
         - block
         - tool
         - wobj
         - radius

        """
        pass

    def rpc_heartbeat(self, time):
        """
        Parameters:
         - time

        """
        pass

    def move_spiral(self, p1, p2, rev, len, r, mode, v, a, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - rev
         - len
         - r
         - mode
         - v
         - a
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        pass

    def enable_acc_optimization(self):
        pass

    def disable_acc_optimization(self):
        pass

    def set_baudrate_485(self, value, block):
        """
        Parameters:
         - value
         - block

        """
        pass

    def set_baudrate_can(self, value, block):
        """
        Parameters:
         - value
         - block

        """
        pass

    def set_analog_output_mode(self, num, mode, block):
        """
        Parameters:
         - num
         - mode
         - block

        """
        pass

    def robotmoving(self):
        pass

    def modbus_write_multiple_coils(self, slave_num, name, len, byte_list):
        """
        Parameters:
         - slave_num
         - name
         - len
         - byte_list

        """
        pass

    def modbus_write_multiple_regs(self, slave_num, name, len, word_list):
        """
        Parameters:
         - slave_num
         - name
         - len
         - word_list

        """
        pass

    def get_current_project(self):
        pass

    def get_files_list(self, path):
        """
        Parameters:
         - path

        """
        pass

    def getRobotStatus(self):
        pass

    def getRobotIOStatus(self):
        pass

    def get_tcp_pose_coord(self, tool, wobj):
        """
        Parameters:
         - tool
         - wobj

        """
        pass

    def get_tcp_force_tool(self, tool):
        """
        Parameters:
         - tool

        """
        pass

    def restart(self, block):
        """
        Parameters:
         - block

        """
        pass

    def set_servo_config(self, axis_num, id, value, qfmt, block):
        """
        Parameters:
         - axis_num
         - id
         - value
         - qfmt
         - block

        """
        pass

    def apply_servo_config(self, axis_num, block):
        """
        Parameters:
         - axis_num
         - block

        """
        pass

    def get_motor_pole_pair_number(self):
        pass

    def get_motor_stator_slots(self):
        pass

    def get_axis_ratio(self):
        pass

    def collision_detection_reset(self):
        pass

    def set_servo_file_params(self, axis_num, id, name, value, qfmt):
        """
        Parameters:
         - axis_num
         - id
         - name
         - value
         - qfmt

        """
        pass

    def combine_motion_config(self, type, ref_plane, fq, amp, el_offset, az_offset, up_height, time, path_dwell, op_list):
        """
        Parameters:
         - type
         - ref_plane
         - fq
         - amp
         - el_offset
         - az_offset
         - up_height
         - time
         - path_dwell
         - op_list

        """
        pass

    def set_eaxis_param(self, num, param, block):
        """
        Parameters:
         - num
         - param
         - block

        """
        pass

    def add_eaxis_scheme(self, num, block):
        """
        Parameters:
         - num
         - block

        """
        pass

    def delete_eaxis_scheme(self, num, block):
        """
        Parameters:
         - num
         - block

        """
        pass

    def enable_eaxis_scheme(self, scheme_name):
        """
        Parameters:
         - scheme_name

        """
        pass

    def disable_eaxis_scheme(self, scheme_name):
        """
        Parameters:
         - scheme_name

        """
        pass

    def set_eaxiss_scheme_param(self, num, param, block):
        """
        Parameters:
         - num
         - param
         - block

        """
        pass

    def move_jog(self, param, block):
        """
        Parameters:
         - param
         - block

        """
        pass

    def stop_manual_move(self, block):
        """
        Parameters:
         - block

        """
        pass

    def get_robot_version(self):
        pass

    def set_teach_pendant(self, enable):
        """
        Parameters:
         - enable

        """
        pass

    def get_teach_speed(self):
        pass

    def get_global_speed(self):
        pass

    def set_teach_speed(self, v):
        """
        Parameters:
         - v

        """
        pass

    def enable_combine_motion(self):
        pass

    def disable_combine_motion(self):
        pass

    def enable_singularity_control(self):
        pass

    def disable_singularity_control(self):
        pass

    def enable_vibration_control(self):
        pass

    def disable_vibration_control(self):
        pass

    def move_eaxis(self, scheme_name, epose, v, block, op):
        """
        Parameters:
         - scheme_name
         - epose
         - v
         - block
         - op

        """
        pass

    def movej2_eaxis(self, joints_list, v, a, rad, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - rad
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        pass

    def movej2_pose_eaxis(self, p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - rad
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        pass

    def movel_eaxis(self, p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - rad
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        pass

    def movec_eaxis(self, p1, p2, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc, mode):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - rad
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc
         - mode

        """
        pass

    def move_circle_eaxis(self, p1, p2, v, a, rad, mode, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - rad
         - mode
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        pass

    def reach_check(self, base, wobj, tool, ref_pos, check_points):
        """
        Parameters:
         - base
         - wobj
         - tool
         - ref_pos
         - check_points

        """
        pass

    def move_jog_eaxis(self, name, direction, vel, block):
        """
        Parameters:
         - name
         - direction
         - vel
         - block

        """
        pass

    def get_eaxis_info(self):
        pass

    def set_hand_teach_parameter(self, space, joint_scale, cart_scale, coord_type, direction):
        """
        Parameters:
         - space
         - joint_scale
         - cart_scale
         - coord_type
         - direction

        """
        pass

    def set_pendant_type(self, type):
        """
        Parameters:
         - type

        """
        pass

    def set_blend_ahead(self, per, num):
        """
        Parameters:
         - per
         - num

        """
        pass

    def switch_mode(self, mode):
        """
        Parameters:
         - mode

        """
        pass

    def read_encoder_count(self):
        pass

    def set_kinematic_calibration_params(self, params):
        """
        Parameters:
         - params

        """
        pass

    def get_pos_bias(self):
        pass

    def get_system_value_lists(self, name):
        """
        Parameters:
         - name

        """
        pass

    def get_origin_DH(self):
        pass

    def get_calib_DH(self):
        pass

    def get_robot_type(self):
        pass

    def get_ext_torque(self):
        pass

    def set_dynamic_calibration_params(self, params):
        """
        Parameters:
         - params

        """
        pass

    def get_dynamic_calibration_params(self):
        pass

    def upload_robot_param_to_toolboard(self, passwd):
        """
        Parameters:
         - passwd

        """
        pass

    def set_kinematic_calibration_info(self, passwd, info):
        """
        Parameters:
         - passwd
         - info

        """
        pass

    def set_dynamic_calibration_info(self, passwd, info):
        """
        Parameters:
         - passwd
         - info

        """
        pass

    def set_vibration_calibration_info(self, passwd, info):
        """
        Parameters:
         - passwd
         - info

        """
        pass

    def get_axis_motor_rated_current(self):
        pass

    def get_axis_motor_kt(self):
        pass

    def abort(self, block):
        """
        Parameters:
         - block

        """
        pass

    def get_vibration_calibration_params(self):
        pass

    def save_kinematic_calibration_params(self, passwd):
        """
        Parameters:
         - passwd

        """
        pass

    def save_dynamic_calibration_params(self, passwd):
        """
        Parameters:
         - passwd

        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def power_on(self, block):
        """
        Parameters:
         - block

        """
        self.send_power_on(block)
        return self.recv_power_on()

    def send_power_on(self, block):
        self._oprot.writeMessageBegin('power_on', TMessageType.CALL, self._seqid)
        args = power_on_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_power_on(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = power_on_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "power_on failed: unknown result")

    def power_off(self, block):
        """
        Parameters:
         - block

        """
        self.send_power_off(block)
        return self.recv_power_off()

    def send_power_off(self, block):
        self._oprot.writeMessageBegin('power_off', TMessageType.CALL, self._seqid)
        args = power_off_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_power_off(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = power_off_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "power_off failed: unknown result")

    def enable(self, block):
        """
        Parameters:
         - block

        """
        self.send_enable(block)
        return self.recv_enable()

    def send_enable(self, block):
        self._oprot.writeMessageBegin('enable', TMessageType.CALL, self._seqid)
        args = enable_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable failed: unknown result")

    def disable(self, block):
        """
        Parameters:
         - block

        """
        self.send_disable(block)
        return self.recv_disable()

    def send_disable(self, block):
        self._oprot.writeMessageBegin('disable', TMessageType.CALL, self._seqid)
        args = disable_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable failed: unknown result")

    def shutdown(self, block):
        """
        Parameters:
         - block

        """
        self.send_shutdown(block)
        return self.recv_shutdown()

    def send_shutdown(self, block):
        self._oprot.writeMessageBegin('shutdown', TMessageType.CALL, self._seqid)
        args = shutdown_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_shutdown(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = shutdown_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "shutdown failed: unknown result")

    def stop(self, block):
        """
        Parameters:
         - block

        """
        self.send_stop(block)
        return self.recv_stop()

    def send_stop(self, block):
        self._oprot.writeMessageBegin('stop', TMessageType.CALL, self._seqid)
        args = stop_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stop failed: unknown result")

    def pause(self, block):
        """
        Parameters:
         - block

        """
        self.send_pause(block)
        return self.recv_pause()

    def send_pause(self, block):
        self._oprot.writeMessageBegin('pause', TMessageType.CALL, self._seqid)
        args = pause_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_pause(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = pause_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "pause failed: unknown result")

    def resume(self, block):
        """
        Parameters:
         - block

        """
        self.send_resume(block)
        return self.recv_resume()

    def send_resume(self, block):
        self._oprot.writeMessageBegin('resume', TMessageType.CALL, self._seqid)
        args = resume_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "resume failed: unknown result")

    def run_program(self, name, block):
        """
        Parameters:
         - name
         - block

        """
        self.send_run_program(name, block)
        return self.recv_run_program()

    def send_run_program(self, name, block):
        self._oprot.writeMessageBegin('run_program', TMessageType.CALL, self._seqid)
        args = run_program_args()
        args.name = name
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_run_program(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = run_program_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "run_program failed: unknown result")

    def set_tool_data(self, name, tool_offset, payload, inertia_tensor):
        """
        Parameters:
         - name
         - tool_offset
         - payload
         - inertia_tensor

        """
        self.send_set_tool_data(name, tool_offset, payload, inertia_tensor)
        return self.recv_set_tool_data()

    def send_set_tool_data(self, name, tool_offset, payload, inertia_tensor):
        self._oprot.writeMessageBegin('set_tool_data', TMessageType.CALL, self._seqid)
        args = set_tool_data_args()
        args.name = name
        args.tool_offset = tool_offset
        args.payload = payload
        args.inertia_tensor = inertia_tensor
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_tool_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_tool_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_tool_data failed: unknown result")

    def get_tool_load(self):
        self.send_get_tool_load()
        return self.recv_get_tool_load()

    def send_get_tool_load(self):
        self._oprot.writeMessageBegin('get_tool_load', TMessageType.CALL, self._seqid)
        args = get_tool_load_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tool_load(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tool_load_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tool_load failed: unknown result")

    def get_tcp_offset(self):
        self.send_get_tcp_offset()
        return self.recv_get_tcp_offset()

    def send_get_tcp_offset(self):
        self._oprot.writeMessageBegin('get_tcp_offset', TMessageType.CALL, self._seqid)
        args = get_tcp_offset_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_offset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_offset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_offset failed: unknown result")

    def set_wobj(self, name, wobj):
        """
        Parameters:
         - name
         - wobj

        """
        self.send_set_wobj(name, wobj)
        return self.recv_set_wobj()

    def send_set_wobj(self, name, wobj):
        self._oprot.writeMessageBegin('set_wobj', TMessageType.CALL, self._seqid)
        args = set_wobj_args()
        args.name = name
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_wobj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_wobj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_wobj failed: unknown result")

    def set_wobj_offset(self, wobj, active):
        """
        Parameters:
         - wobj
         - active

        """
        self.send_set_wobj_offset(wobj, active)
        return self.recv_set_wobj_offset()

    def send_set_wobj_offset(self, wobj, active):
        self._oprot.writeMessageBegin('set_wobj_offset', TMessageType.CALL, self._seqid)
        args = set_wobj_offset_args()
        args.wobj = wobj
        args.active = active
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_wobj_offset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_wobj_offset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_wobj_offset failed: unknown result")

    def get_wobj(self):
        self.send_get_wobj()
        return self.recv_get_wobj()

    def send_get_wobj(self):
        self._oprot.writeMessageBegin('get_wobj', TMessageType.CALL, self._seqid)
        args = get_wobj_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_wobj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_wobj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_wobj failed: unknown result")

    def cal_fkine(self, joints_position, tool, wobj):
        """
        Parameters:
         - joints_position
         - tool
         - wobj

        """
        self.send_cal_fkine(joints_position, tool, wobj)
        return self.recv_cal_fkine()

    def send_cal_fkine(self, joints_position, tool, wobj):
        self._oprot.writeMessageBegin('cal_fkine', TMessageType.CALL, self._seqid)
        args = cal_fkine_args()
        args.joints_position = joints_position
        args.tool = tool
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cal_fkine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cal_fkine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cal_fkine failed: unknown result")

    def cal_ikine(self, p, q_near, tool, wobj):
        """
        Parameters:
         - p
         - q_near
         - tool
         - wobj

        """
        self.send_cal_ikine(p, q_near, tool, wobj)
        return self.recv_cal_ikine()

    def send_cal_ikine(self, p, q_near, tool, wobj):
        self._oprot.writeMessageBegin('cal_ikine', TMessageType.CALL, self._seqid)
        args = cal_ikine_args()
        args.p = p
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cal_ikine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cal_ikine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "cal_ikine failed: unknown result")

    def set_digital_output_mode(self, num, type, freq, duty_cycle):
        """
        Parameters:
         - num
         - type
         - freq
         - duty_cycle

        """
        self.send_set_digital_output_mode(num, type, freq, duty_cycle)
        return self.recv_set_digital_output_mode()

    def send_set_digital_output_mode(self, num, type, freq, duty_cycle):
        self._oprot.writeMessageBegin('set_digital_output_mode', TMessageType.CALL, self._seqid)
        args = set_digital_output_mode_args()
        args.num = num
        args.type = type
        args.freq = freq
        args.duty_cycle = duty_cycle
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_digital_output_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_digital_output_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_digital_output_mode failed: unknown result")

    def set_standard_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        self.send_set_standard_digital_out(num, value, block)
        return self.recv_set_standard_digital_out()

    def send_set_standard_digital_out(self, num, value, block):
        self._oprot.writeMessageBegin('set_standard_digital_out', TMessageType.CALL, self._seqid)
        args = set_standard_digital_out_args()
        args.num = num
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_standard_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_standard_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_standard_digital_out failed: unknown result")

    def set_tool_digital_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        self.send_set_tool_digital_out(num, value, block)
        return self.recv_set_tool_digital_out()

    def send_set_tool_digital_out(self, num, value, block):
        self._oprot.writeMessageBegin('set_tool_digital_out', TMessageType.CALL, self._seqid)
        args = set_tool_digital_out_args()
        args.num = num
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_tool_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_tool_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_tool_digital_out failed: unknown result")

    def get_standard_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_standard_digital_in(num)
        return self.recv_get_standard_digital_in()

    def send_get_standard_digital_in(self, num):
        self._oprot.writeMessageBegin('get_standard_digital_in', TMessageType.CALL, self._seqid)
        args = get_standard_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_standard_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_standard_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_standard_digital_in failed: unknown result")

    def get_standard_digital_out(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_standard_digital_out(num)
        return self.recv_get_standard_digital_out()

    def send_get_standard_digital_out(self, num):
        self._oprot.writeMessageBegin('get_standard_digital_out', TMessageType.CALL, self._seqid)
        args = get_standard_digital_out_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_standard_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_standard_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_standard_digital_out failed: unknown result")

    def get_tool_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_tool_digital_in(num)
        return self.recv_get_tool_digital_in()

    def send_get_tool_digital_in(self, num):
        self._oprot.writeMessageBegin('get_tool_digital_in', TMessageType.CALL, self._seqid)
        args = get_tool_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tool_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tool_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tool_digital_in failed: unknown result")

    def get_tool_digital_out(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_tool_digital_out(num)
        return self.recv_get_tool_digital_out()

    def send_get_tool_digital_out(self, num):
        self._oprot.writeMessageBegin('get_tool_digital_out', TMessageType.CALL, self._seqid)
        args = get_tool_digital_out_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tool_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tool_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tool_digital_out failed: unknown result")

    def get_config_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_config_digital_in(num)
        return self.recv_get_config_digital_in()

    def send_get_config_digital_in(self, num):
        self._oprot.writeMessageBegin('get_config_digital_in', TMessageType.CALL, self._seqid)
        args = get_config_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_config_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_config_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_digital_in failed: unknown result")

    def get_standard_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_standard_analog_voltage_in(num)
        return self.recv_get_standard_analog_voltage_in()

    def send_get_standard_analog_voltage_in(self, num):
        self._oprot.writeMessageBegin('get_standard_analog_voltage_in', TMessageType.CALL, self._seqid)
        args = get_standard_analog_voltage_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_standard_analog_voltage_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_standard_analog_voltage_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_standard_analog_voltage_in failed: unknown result")

    def get_tool_analog_voltage_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_tool_analog_voltage_in(num)
        return self.recv_get_tool_analog_voltage_in()

    def send_get_tool_analog_voltage_in(self, num):
        self._oprot.writeMessageBegin('get_tool_analog_voltage_in', TMessageType.CALL, self._seqid)
        args = get_tool_analog_voltage_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tool_analog_voltage_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tool_analog_voltage_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tool_analog_voltage_in failed: unknown result")

    def get_standard_analog_current_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_standard_analog_current_in(num)
        return self.recv_get_standard_analog_current_in()

    def send_get_standard_analog_current_in(self, num):
        self._oprot.writeMessageBegin('get_standard_analog_current_in', TMessageType.CALL, self._seqid)
        args = get_standard_analog_current_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_standard_analog_current_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_standard_analog_current_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_standard_analog_current_in failed: unknown result")

    def set_standard_analog_voltage_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        self.send_set_standard_analog_voltage_out(num, value, block)
        return self.recv_set_standard_analog_voltage_out()

    def send_set_standard_analog_voltage_out(self, num, value, block):
        self._oprot.writeMessageBegin('set_standard_analog_voltage_out', TMessageType.CALL, self._seqid)
        args = set_standard_analog_voltage_out_args()
        args.num = num
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_standard_analog_voltage_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_standard_analog_voltage_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_standard_analog_voltage_out failed: unknown result")

    def set_standard_analog_current_out(self, num, value, block):
        """
        Parameters:
         - num
         - value
         - block

        """
        self.send_set_standard_analog_current_out(num, value, block)
        return self.recv_set_standard_analog_current_out()

    def send_set_standard_analog_current_out(self, num, value, block):
        self._oprot.writeMessageBegin('set_standard_analog_current_out', TMessageType.CALL, self._seqid)
        args = set_standard_analog_current_out_args()
        args.num = num
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_standard_analog_current_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_standard_analog_current_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_standard_analog_current_out failed: unknown result")

    def read_data_485(self):
        self.send_read_data_485()
        return self.recv_read_data_485()

    def send_read_data_485(self):
        self._oprot.writeMessageBegin('read_data_485', TMessageType.CALL, self._seqid)
        args = read_data_485_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_data_485 failed: unknown result")

    def read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        self.send_read_raw_data_485(len)
        return self.recv_read_raw_data_485()

    def send_read_raw_data_485(self, len):
        self._oprot.writeMessageBegin('read_raw_data_485', TMessageType.CALL, self._seqid)
        args = read_raw_data_485_args()
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_485 failed: unknown result")

    def read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        self.send_read_raw_data_485_ht(head, tail)
        return self.recv_read_raw_data_485_ht()

    def send_read_raw_data_485_ht(self, head, tail):
        self._oprot.writeMessageBegin('read_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = read_raw_data_485_ht_args()
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_485_ht failed: unknown result")

    def read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        self.send_read_raw_data_485_h(head, len)
        return self.recv_read_raw_data_485_h()

    def send_read_raw_data_485_h(self, head, len):
        self._oprot.writeMessageBegin('read_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = read_raw_data_485_h_args()
        args.head = head
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_485_h failed: unknown result")

    def write_data_485(self, data):
        """
        Parameters:
         - data

        """
        self.send_write_data_485(data)
        return self.recv_write_data_485()

    def send_write_data_485(self, data):
        self._oprot.writeMessageBegin('write_data_485', TMessageType.CALL, self._seqid)
        args = write_data_485_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_data_485 failed: unknown result")

    def write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        self.send_write_raw_data_485(data)
        return self.recv_write_raw_data_485()

    def send_write_raw_data_485(self, data):
        self._oprot.writeMessageBegin('write_raw_data_485', TMessageType.CALL, self._seqid)
        args = write_raw_data_485_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_485 failed: unknown result")

    def write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        self.send_write_raw_data_485_h(data, head)
        return self.recv_write_raw_data_485_h()

    def send_write_raw_data_485_h(self, data, head):
        self._oprot.writeMessageBegin('write_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = write_raw_data_485_h_args()
        args.data = data
        args.head = head
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_485_h failed: unknown result")

    def write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        self.send_write_raw_data_485_ht(data, head, tail)
        return self.recv_write_raw_data_485_ht()

    def send_write_raw_data_485_ht(self, data, head, tail):
        self._oprot.writeMessageBegin('write_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = write_raw_data_485_ht_args()
        args.data = data
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_485_ht failed: unknown result")

    def tool_read_data_485(self):
        self.send_tool_read_data_485()
        return self.recv_tool_read_data_485()

    def send_tool_read_data_485(self):
        self._oprot.writeMessageBegin('tool_read_data_485', TMessageType.CALL, self._seqid)
        args = tool_read_data_485_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_read_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_read_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_read_data_485 failed: unknown result")

    def tool_read_raw_data_485(self, len):
        """
        Parameters:
         - len

        """
        self.send_tool_read_raw_data_485(len)
        return self.recv_tool_read_raw_data_485()

    def send_tool_read_raw_data_485(self, len):
        self._oprot.writeMessageBegin('tool_read_raw_data_485', TMessageType.CALL, self._seqid)
        args = tool_read_raw_data_485_args()
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_read_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_read_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_read_raw_data_485 failed: unknown result")

    def tool_read_raw_data_485_h(self, head, len):
        """
        Parameters:
         - head
         - len

        """
        self.send_tool_read_raw_data_485_h(head, len)
        return self.recv_tool_read_raw_data_485_h()

    def send_tool_read_raw_data_485_h(self, head, len):
        self._oprot.writeMessageBegin('tool_read_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = tool_read_raw_data_485_h_args()
        args.head = head
        args.len = len
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_read_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_read_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_read_raw_data_485_h failed: unknown result")

    def tool_read_raw_data_485_ht(self, head, tail):
        """
        Parameters:
         - head
         - tail

        """
        self.send_tool_read_raw_data_485_ht(head, tail)
        return self.recv_tool_read_raw_data_485_ht()

    def send_tool_read_raw_data_485_ht(self, head, tail):
        self._oprot.writeMessageBegin('tool_read_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = tool_read_raw_data_485_ht_args()
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_read_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_read_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_read_raw_data_485_ht failed: unknown result")

    def tool_write_data_485(self, data):
        """
        Parameters:
         - data

        """
        self.send_tool_write_data_485(data)
        return self.recv_tool_write_data_485()

    def send_tool_write_data_485(self, data):
        self._oprot.writeMessageBegin('tool_write_data_485', TMessageType.CALL, self._seqid)
        args = tool_write_data_485_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_write_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_write_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_write_data_485 failed: unknown result")

    def tool_write_raw_data_485(self, data):
        """
        Parameters:
         - data

        """
        self.send_tool_write_raw_data_485(data)
        return self.recv_tool_write_raw_data_485()

    def send_tool_write_raw_data_485(self, data):
        self._oprot.writeMessageBegin('tool_write_raw_data_485', TMessageType.CALL, self._seqid)
        args = tool_write_raw_data_485_args()
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_write_raw_data_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_write_raw_data_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_write_raw_data_485 failed: unknown result")

    def tool_write_raw_data_485_h(self, data, head):
        """
        Parameters:
         - data
         - head

        """
        self.send_tool_write_raw_data_485_h(data, head)
        return self.recv_tool_write_raw_data_485_h()

    def send_tool_write_raw_data_485_h(self, data, head):
        self._oprot.writeMessageBegin('tool_write_raw_data_485_h', TMessageType.CALL, self._seqid)
        args = tool_write_raw_data_485_h_args()
        args.data = data
        args.head = head
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_write_raw_data_485_h(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_write_raw_data_485_h_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_write_raw_data_485_h failed: unknown result")

    def tool_write_raw_data_485_ht(self, data, head, tail):
        """
        Parameters:
         - data
         - head
         - tail

        """
        self.send_tool_write_raw_data_485_ht(data, head, tail)
        return self.recv_tool_write_raw_data_485_ht()

    def send_tool_write_raw_data_485_ht(self, data, head, tail):
        self._oprot.writeMessageBegin('tool_write_raw_data_485_ht', TMessageType.CALL, self._seqid)
        args = tool_write_raw_data_485_ht_args()
        args.data = data
        args.head = head
        args.tail = tail
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tool_write_raw_data_485_ht(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tool_write_raw_data_485_ht_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tool_write_raw_data_485_ht failed: unknown result")

    def read_data_can(self):
        self.send_read_data_can()
        return self.recv_read_data_can()

    def send_read_data_can(self):
        self._oprot.writeMessageBegin('read_data_can', TMessageType.CALL, self._seqid)
        args = read_data_can_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_data_can(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_data_can_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_data_can failed: unknown result")

    def read_raw_data_can(self):
        self.send_read_raw_data_can()
        return self.recv_read_raw_data_can()

    def send_read_raw_data_can(self):
        self._oprot.writeMessageBegin('read_raw_data_can', TMessageType.CALL, self._seqid)
        args = read_raw_data_can_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_raw_data_can(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_raw_data_can_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_raw_data_can failed: unknown result")

    def write_data_can(self, id, data):
        """
        Parameters:
         - id
         - data

        """
        self.send_write_data_can(id, data)
        return self.recv_write_data_can()

    def send_write_data_can(self, id, data):
        self._oprot.writeMessageBegin('write_data_can', TMessageType.CALL, self._seqid)
        args = write_data_can_args()
        args.id = id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_data_can(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_data_can_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_data_can failed: unknown result")

    def write_raw_data_can(self, id, data):
        """
        Parameters:
         - id
         - data

        """
        self.send_write_raw_data_can(id, data)
        return self.recv_write_raw_data_can()

    def send_write_raw_data_can(self, id, data):
        self._oprot.writeMessageBegin('write_raw_data_can', TMessageType.CALL, self._seqid)
        args = write_raw_data_can_args()
        args.id = id
        args.data = data
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_raw_data_can(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_raw_data_can_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_raw_data_can failed: unknown result")

    def get_function_digital_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_function_digital_in(num)
        return self.recv_get_function_digital_in()

    def send_get_function_digital_in(self, num):
        self._oprot.writeMessageBegin('get_function_digital_in', TMessageType.CALL, self._seqid)
        args = get_function_digital_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function_digital_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_digital_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function_digital_in failed: unknown result")

    def get_function_digital_out(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_function_digital_out(num)
        return self.recv_get_function_digital_out()

    def send_get_function_digital_out(self, num):
        self._oprot.writeMessageBegin('get_function_digital_out', TMessageType.CALL, self._seqid)
        args = get_function_digital_out_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function_digital_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_digital_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function_digital_out failed: unknown result")

    def read_bool_reg(self, num):
        """
        Parameters:
         - num

        """
        self.send_read_bool_reg(num)
        return self.recv_read_bool_reg()

    def send_read_bool_reg(self, num):
        self._oprot.writeMessageBegin('read_bool_reg', TMessageType.CALL, self._seqid)
        args = read_bool_reg_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_bool_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_bool_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_bool_reg failed: unknown result")

    def read_word_reg(self, num):
        """
        Parameters:
         - num

        """
        self.send_read_word_reg(num)
        return self.recv_read_word_reg()

    def send_read_word_reg(self, num):
        self._oprot.writeMessageBegin('read_word_reg', TMessageType.CALL, self._seqid)
        args = read_word_reg_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_word_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_word_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_word_reg failed: unknown result")

    def read_float_reg(self, num):
        """
        Parameters:
         - num

        """
        self.send_read_float_reg(num)
        return self.recv_read_float_reg()

    def send_read_float_reg(self, num):
        self._oprot.writeMessageBegin('read_float_reg', TMessageType.CALL, self._seqid)
        args = read_float_reg_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_float_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_float_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_float_reg failed: unknown result")

    def write_bool_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        self.send_write_bool_reg(num, value)
        return self.recv_write_bool_reg()

    def send_write_bool_reg(self, num, value):
        self._oprot.writeMessageBegin('write_bool_reg', TMessageType.CALL, self._seqid)
        args = write_bool_reg_args()
        args.num = num
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_bool_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_bool_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_bool_reg failed: unknown result")

    def write_word_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        self.send_write_word_reg(num, value)
        return self.recv_write_word_reg()

    def send_write_word_reg(self, num, value):
        self._oprot.writeMessageBegin('write_word_reg', TMessageType.CALL, self._seqid)
        args = write_word_reg_args()
        args.num = num
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_word_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_word_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_word_reg failed: unknown result")

    def write_float_reg(self, num, value):
        """
        Parameters:
         - num
         - value

        """
        self.send_write_float_reg(num, value)
        return self.recv_write_float_reg()

    def send_write_float_reg(self, num, value):
        self._oprot.writeMessageBegin('write_float_reg', TMessageType.CALL, self._seqid)
        args = write_float_reg_args()
        args.num = num
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write_float_reg(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_float_reg_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write_float_reg failed: unknown result")

    def get_function_reg_in(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_function_reg_in(num)
        return self.recv_get_function_reg_in()

    def send_get_function_reg_in(self, num):
        self._oprot.writeMessageBegin('get_function_reg_in', TMessageType.CALL, self._seqid)
        args = get_function_reg_in_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function_reg_in(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_reg_in_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function_reg_in failed: unknown result")

    def get_function_reg_out(self, num):
        """
        Parameters:
         - num

        """
        self.send_get_function_reg_out(num)
        return self.recv_get_function_reg_out()

    def send_get_function_reg_out(self, num):
        self._oprot.writeMessageBegin('get_function_reg_out', TMessageType.CALL, self._seqid)
        args = get_function_reg_out_args()
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function_reg_out(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_reg_out_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function_reg_out failed: unknown result")

    def movej(self, joints_list, v, a, r, block, op, def_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op
         - def_acc

        """
        self.send_movej(joints_list, v, a, r, block, op, def_acc)
        return self.recv_movej()

    def send_movej(self, joints_list, v, a, r, block, op, def_acc):
        self._oprot.writeMessageBegin('movej', TMessageType.CALL, self._seqid)
        args = movej_args()
        args.joints_list = joints_list
        args.v = v
        args.a = a
        args.r = r
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej failed: unknown result")

    def movej_pose(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_movej_pose(p, v, a, r, q_near, tool, wobj, block, op, def_acc)
        return self.recv_movej_pose()

    def send_movej_pose(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('movej_pose', TMessageType.CALL, self._seqid)
        args = movej_pose_args()
        args.p = p
        args.v = v
        args.a = a
        args.r = r
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej_pose failed: unknown result")

    def movej2(self, joints_list, v, a, r, block, op, def_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - r
         - block
         - op
         - def_acc

        """
        self.send_movej2(joints_list, v, a, r, block, op, def_acc)
        return self.recv_movej2()

    def send_movej2(self, joints_list, v, a, r, block, op, def_acc):
        self._oprot.writeMessageBegin('movej2', TMessageType.CALL, self._seqid)
        args = movej2_args()
        args.joints_list = joints_list
        args.v = v
        args.a = a
        args.r = r
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej2 failed: unknown result")

    def movej_pose2(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_movej_pose2(p, v, a, r, q_near, tool, wobj, block, op, def_acc)
        return self.recv_movej_pose2()

    def send_movej_pose2(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('movej_pose2', TMessageType.CALL, self._seqid)
        args = movej_pose2_args()
        args.p = p
        args.v = v
        args.a = a
        args.r = r
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej_pose2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej_pose2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej_pose2 failed: unknown result")

    def movel(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - r
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_movel(p, v, a, r, q_near, tool, wobj, block, op, def_acc)
        return self.recv_movel()

    def send_movel(self, p, v, a, r, q_near, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('movel', TMessageType.CALL, self._seqid)
        args = movel_args()
        args.p = p
        args.v = v
        args.a = a
        args.r = r
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movel failed: unknown result")

    def movec(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_movec(p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc)
        return self.recv_movec()

    def send_movec(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('movec', TMessageType.CALL, self._seqid)
        args = movec_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.r = r
        args.mode = mode
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movec failed: unknown result")

    def move_circle(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - mode
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_move_circle(p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc)
        return self.recv_move_circle()

    def send_move_circle(self, p1, p2, v, a, r, mode, q_near, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('move_circle', TMessageType.CALL, self._seqid)
        args = move_circle_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.r = r
        args.mode = mode
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_move_circle(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = move_circle_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "move_circle failed: unknown result")

    def tcp_move(self, pose_offset, v, a, r, tool, block, op, def_acc):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - r
         - tool
         - block
         - op
         - def_acc

        """
        self.send_tcp_move(pose_offset, v, a, r, tool, block, op, def_acc)
        return self.recv_tcp_move()

    def send_tcp_move(self, pose_offset, v, a, r, tool, block, op, def_acc):
        self._oprot.writeMessageBegin('tcp_move', TMessageType.CALL, self._seqid)
        args = tcp_move_args()
        args.pose_offset = pose_offset
        args.v = v
        args.a = a
        args.r = r
        args.tool = tool
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tcp_move(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tcp_move_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tcp_move failed: unknown result")

    def tcp_move_2p(self, p1, p2, v, a, r, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_tcp_move_2p(p1, p2, v, a, r, tool, wobj, block, op, def_acc)
        return self.recv_tcp_move_2p()

    def send_tcp_move_2p(self, p1, p2, v, a, r, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('tcp_move_2p', TMessageType.CALL, self._seqid)
        args = tcp_move_2p_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.r = r
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tcp_move_2p(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tcp_move_2p_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tcp_move_2p failed: unknown result")

    def wobj_move(self, pose_offset, v, a, r, wobj, block, op, def_acc):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - r
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_wobj_move(pose_offset, v, a, r, wobj, block, op, def_acc)
        return self.recv_wobj_move()

    def send_wobj_move(self, pose_offset, v, a, r, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('wobj_move', TMessageType.CALL, self._seqid)
        args = wobj_move_args()
        args.pose_offset = pose_offset
        args.v = v
        args.a = a
        args.r = r
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wobj_move(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wobj_move_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wobj_move failed: unknown result")

    def wobj_move_2p(self, p1, p2, v, a, r, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - r
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_wobj_move_2p(p1, p2, v, a, r, tool, wobj, block, op, def_acc)
        return self.recv_wobj_move_2p()

    def send_wobj_move_2p(self, p1, p2, v, a, r, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('wobj_move_2p', TMessageType.CALL, self._seqid)
        args = wobj_move_2p_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.r = r
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_wobj_move_2p(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = wobj_move_2p_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "wobj_move_2p failed: unknown result")

    def spline(self, pose_list, v, a, tool, wobj, block, op, r, def_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - tool
         - wobj
         - block
         - op
         - r
         - def_acc

        """
        self.send_spline(pose_list, v, a, tool, wobj, block, op, r, def_acc)
        return self.recv_spline()

    def send_spline(self, pose_list, v, a, tool, wobj, block, op, r, def_acc):
        self._oprot.writeMessageBegin('spline', TMessageType.CALL, self._seqid)
        args = spline_args()
        args.pose_list = pose_list
        args.v = v
        args.a = a
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.r = r
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spline(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spline_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spline failed: unknown result")

    def spline_op(self, pose_list, v, a, tool, wobj, block, op, r, def_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - tool
         - wobj
         - block
         - op
         - r
         - def_acc

        """
        self.send_spline_op(pose_list, v, a, tool, wobj, block, op, r, def_acc)
        return self.recv_spline_op()

    def send_spline_op(self, pose_list, v, a, tool, wobj, block, op, r, def_acc):
        self._oprot.writeMessageBegin('spline_op', TMessageType.CALL, self._seqid)
        args = spline_op_args()
        args.pose_list = pose_list
        args.v = v
        args.a = a
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.r = r
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_spline_op(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = spline_op_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "spline_op failed: unknown result")

    def speedj(self, joints_list, a, time, block):
        """
        Parameters:
         - joints_list
         - a
         - time
         - block

        """
        self.send_speedj(joints_list, a, time, block)
        return self.recv_speedj()

    def send_speedj(self, joints_list, a, time, block):
        self._oprot.writeMessageBegin('speedj', TMessageType.CALL, self._seqid)
        args = speedj_args()
        args.joints_list = joints_list
        args.a = a
        args.time = time
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speedj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speedj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speedj failed: unknown result")

    def speedl(self, pose_list, a, time, block):
        """
        Parameters:
         - pose_list
         - a
         - time
         - block

        """
        self.send_speedl(pose_list, a, time, block)
        return self.recv_speedl()

    def send_speedl(self, pose_list, a, time, block):
        self._oprot.writeMessageBegin('speedl', TMessageType.CALL, self._seqid)
        args = speedl_args()
        args.pose_list = pose_list
        args.a = a
        args.time = time
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speedl(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speedl_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speedl failed: unknown result")

    def speed_stop(self, block):
        """
        Parameters:
         - block

        """
        self.send_speed_stop(block)
        return self.recv_speed_stop()

    def send_speed_stop(self, block):
        self._oprot.writeMessageBegin('speed_stop', TMessageType.CALL, self._seqid)
        args = speed_stop_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speed_stop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speed_stop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speed_stop failed: unknown result")

    def servoj(self, joints_list, v, a, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        self.send_servoj(joints_list, v, a, block, kp, kd, smooth_vel, smooth_acc)
        return self.recv_servoj()

    def send_servoj(self, joints_list, v, a, block, kp, kd, smooth_vel, smooth_acc):
        self._oprot.writeMessageBegin('servoj', TMessageType.CALL, self._seqid)
        args = servoj_args()
        args.joints_list = joints_list
        args.v = v
        args.a = a
        args.block = block
        args.kp = kp
        args.kd = kd
        args.smooth_vel = smooth_vel
        args.smooth_acc = smooth_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_servoj(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = servoj_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "servoj failed: unknown result")

    def servoj_pose(self, pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        self.send_servoj_pose(pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc)
        return self.recv_servoj_pose()

    def send_servoj_pose(self, pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc):
        self._oprot.writeMessageBegin('servoj_pose', TMessageType.CALL, self._seqid)
        args = servoj_pose_args()
        args.pose_list = pose_list
        args.v = v
        args.a = a
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.kp = kp
        args.kd = kd
        args.smooth_vel = smooth_vel
        args.smooth_acc = smooth_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_servoj_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = servoj_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "servoj_pose failed: unknown result")

    def servo_tcp(self, pose_offset, v, a, tool, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - pose_offset
         - v
         - a
         - tool
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        self.send_servo_tcp(pose_offset, v, a, tool, block, kp, kd, smooth_vel, smooth_acc)
        return self.recv_servo_tcp()

    def send_servo_tcp(self, pose_offset, v, a, tool, block, kp, kd, smooth_vel, smooth_acc):
        self._oprot.writeMessageBegin('servo_tcp', TMessageType.CALL, self._seqid)
        args = servo_tcp_args()
        args.pose_offset = pose_offset
        args.v = v
        args.a = a
        args.tool = tool
        args.block = block
        args.kp = kp
        args.kd = kd
        args.smooth_vel = smooth_vel
        args.smooth_acc = smooth_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_servo_tcp(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = servo_tcp_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "servo_tcp failed: unknown result")

    def servol(self, pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc):
        """
        Parameters:
         - pose_list
         - v
         - a
         - q_near
         - tool
         - wobj
         - block
         - kp
         - kd
         - smooth_vel
         - smooth_acc

        """
        self.send_servol(pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc)
        return self.recv_servol()

    def send_servol(self, pose_list, v, a, q_near, tool, wobj, block, kp, kd, smooth_vel, smooth_acc):
        self._oprot.writeMessageBegin('servol', TMessageType.CALL, self._seqid)
        args = servol_args()
        args.pose_list = pose_list
        args.v = v
        args.a = a
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.kp = kp
        args.kd = kd
        args.smooth_vel = smooth_vel
        args.smooth_acc = smooth_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_servol(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = servol_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "servol failed: unknown result")

    def teach_mode(self, block):
        """
        Parameters:
         - block

        """
        self.send_teach_mode(block)
        return self.recv_teach_mode()

    def send_teach_mode(self, block):
        self._oprot.writeMessageBegin('teach_mode', TMessageType.CALL, self._seqid)
        args = teach_mode_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_teach_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = teach_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "teach_mode failed: unknown result")

    def end_teach_mode(self, block):
        """
        Parameters:
         - block

        """
        self.send_end_teach_mode(block)
        return self.recv_end_teach_mode()

    def send_end_teach_mode(self, block):
        self._oprot.writeMessageBegin('end_teach_mode', TMessageType.CALL, self._seqid)
        args = end_teach_mode_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_end_teach_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = end_teach_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "end_teach_mode failed: unknown result")

    def modbus_add_signal(self, ip, slave_number, signal_address, signal_type, signal_name):
        """
        Parameters:
         - ip
         - slave_number
         - signal_address
         - signal_type
         - signal_name

        """
        self.send_modbus_add_signal(ip, slave_number, signal_address, signal_type, signal_name)
        return self.recv_modbus_add_signal()

    def send_modbus_add_signal(self, ip, slave_number, signal_address, signal_type, signal_name):
        self._oprot.writeMessageBegin('modbus_add_signal', TMessageType.CALL, self._seqid)
        args = modbus_add_signal_args()
        args.ip = ip
        args.slave_number = slave_number
        args.signal_address = signal_address
        args.signal_type = signal_type
        args.signal_name = signal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_add_signal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_add_signal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_add_signal failed: unknown result")

    def modbus_delete_signal(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        self.send_modbus_delete_signal(signal_name)
        return self.recv_modbus_delete_signal()

    def send_modbus_delete_signal(self, signal_name):
        self._oprot.writeMessageBegin('modbus_delete_signal', TMessageType.CALL, self._seqid)
        args = modbus_delete_signal_args()
        args.signal_name = signal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_delete_signal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_delete_signal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_delete_signal failed: unknown result")

    def modbus_read(self, signal_name):
        """
        Parameters:
         - signal_name

        """
        self.send_modbus_read(signal_name)
        return self.recv_modbus_read()

    def send_modbus_read(self, signal_name):
        self._oprot.writeMessageBegin('modbus_read', TMessageType.CALL, self._seqid)
        args = modbus_read_args()
        args.signal_name = signal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_read failed: unknown result")

    def modbus_write(self, signal_name, value):
        """
        Parameters:
         - signal_name
         - value

        """
        self.send_modbus_write(signal_name, value)
        return self.recv_modbus_write()

    def send_modbus_write(self, signal_name, value):
        self._oprot.writeMessageBegin('modbus_write', TMessageType.CALL, self._seqid)
        args = modbus_write_args()
        args.signal_name = signal_name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_write failed: unknown result")

    def modbus_set_frequency(self, signal_name, frequence):
        """
        Parameters:
         - signal_name
         - frequence

        """
        self.send_modbus_set_frequency(signal_name, frequence)
        self.recv_modbus_set_frequency()

    def send_modbus_set_frequency(self, signal_name, frequence):
        self._oprot.writeMessageBegin('modbus_set_frequency', TMessageType.CALL, self._seqid)
        args = modbus_set_frequency_args()
        args.signal_name = signal_name
        args.frequence = frequence
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_set_frequency(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_set_frequency_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def get_last_error(self):
        self.send_get_last_error()
        return self.recv_get_last_error()

    def send_get_last_error(self):
        self._oprot.writeMessageBegin('get_last_error', TMessageType.CALL, self._seqid)
        args = get_last_error_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_last_error(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_last_error_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_last_error failed: unknown result")

    def get_noneblock_taskstate(self, id):
        """
        Parameters:
         - id

        """
        self.send_get_noneblock_taskstate(id)
        return self.recv_get_noneblock_taskstate()

    def send_get_noneblock_taskstate(self, id):
        self._oprot.writeMessageBegin('get_noneblock_taskstate', TMessageType.CALL, self._seqid)
        args = get_noneblock_taskstate_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_noneblock_taskstate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_noneblock_taskstate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_noneblock_taskstate failed: unknown result")

    def log_info(self, message):
        """
        Parameters:
         - message

        """
        self.send_log_info(message)
        self.recv_log_info()

    def send_log_info(self, message):
        self._oprot.writeMessageBegin('log_info', TMessageType.CALL, self._seqid)
        args = log_info_args()
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_log_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = log_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def log_error(self, message):
        """
        Parameters:
         - message

        """
        self.send_log_error(message)
        self.recv_log_error()

    def send_log_error(self, message):
        self._oprot.writeMessageBegin('log_error', TMessageType.CALL, self._seqid)
        args = log_error_args()
        args.message = message
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_log_error(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = log_error_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def simulation(self, sim, block):
        """
        Parameters:
         - sim
         - block

        """
        self.send_simulation(sim, block)
        return self.recv_simulation()

    def send_simulation(self, sim, block):
        self._oprot.writeMessageBegin('simulation', TMessageType.CALL, self._seqid)
        args = simulation_args()
        args.sim = sim
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_simulation(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = simulation_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "simulation failed: unknown result")

    def speed(self, val):
        """
        Parameters:
         - val

        """
        self.send_speed(val)
        return self.recv_speed()

    def send_speed(self, val):
        self._oprot.writeMessageBegin('speed', TMessageType.CALL, self._seqid)
        args = speed_args()
        args.val = val
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "speed failed: unknown result")

    def get_robot_state(self):
        self.send_get_robot_state()
        return self.recv_get_robot_state()

    def send_get_robot_state(self):
        self._oprot.writeMessageBegin('get_robot_state', TMessageType.CALL, self._seqid)
        args = get_robot_state_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_robot_state(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_robot_state_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_robot_state failed: unknown result")

    def get_flange_pose(self):
        self.send_get_flange_pose()
        return self.recv_get_flange_pose()

    def send_get_flange_pose(self):
        self._oprot.writeMessageBegin('get_flange_pose', TMessageType.CALL, self._seqid)
        args = get_flange_pose_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flange_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flange_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_flange_pose failed: unknown result")

    def get_flange_speed(self):
        self.send_get_flange_speed()
        return self.recv_get_flange_speed()

    def send_get_flange_speed(self):
        self._oprot.writeMessageBegin('get_flange_speed', TMessageType.CALL, self._seqid)
        args = get_flange_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flange_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flange_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_flange_speed failed: unknown result")

    def get_flange_acceleration(self):
        self.send_get_flange_acceleration()
        return self.recv_get_flange_acceleration()

    def send_get_flange_acceleration(self):
        self._oprot.writeMessageBegin('get_flange_acceleration', TMessageType.CALL, self._seqid)
        args = get_flange_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flange_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flange_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_flange_acceleration failed: unknown result")

    def get_tcp_pose(self):
        self.send_get_tcp_pose()
        return self.recv_get_tcp_pose()

    def send_get_tcp_pose(self):
        self._oprot.writeMessageBegin('get_tcp_pose', TMessageType.CALL, self._seqid)
        args = get_tcp_pose_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_pose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_pose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_pose failed: unknown result")

    def get_tcp_speed(self):
        self.send_get_tcp_speed()
        return self.recv_get_tcp_speed()

    def send_get_tcp_speed(self):
        self._oprot.writeMessageBegin('get_tcp_speed', TMessageType.CALL, self._seqid)
        args = get_tcp_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_speed failed: unknown result")

    def get_tcp_acceleration(self):
        self.send_get_tcp_acceleration()
        return self.recv_get_tcp_acceleration()

    def send_get_tcp_acceleration(self):
        self._oprot.writeMessageBegin('get_tcp_acceleration', TMessageType.CALL, self._seqid)
        args = get_tcp_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_acceleration failed: unknown result")

    def get_tcp_force(self):
        self.send_get_tcp_force()
        return self.recv_get_tcp_force()

    def send_get_tcp_force(self):
        self._oprot.writeMessageBegin('get_tcp_force', TMessageType.CALL, self._seqid)
        args = get_tcp_force_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_force(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_force_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_force failed: unknown result")

    def get_actual_joints_position(self):
        self.send_get_actual_joints_position()
        return self.recv_get_actual_joints_position()

    def send_get_actual_joints_position(self):
        self._oprot.writeMessageBegin('get_actual_joints_position', TMessageType.CALL, self._seqid)
        args = get_actual_joints_position_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_position(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_position_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_position failed: unknown result")

    def get_target_joints_position(self):
        self.send_get_target_joints_position()
        return self.recv_get_target_joints_position()

    def send_get_target_joints_position(self):
        self._oprot.writeMessageBegin('get_target_joints_position', TMessageType.CALL, self._seqid)
        args = get_target_joints_position_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_position(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_position_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_position failed: unknown result")

    def get_actual_joints_speed(self):
        self.send_get_actual_joints_speed()
        return self.recv_get_actual_joints_speed()

    def send_get_actual_joints_speed(self):
        self._oprot.writeMessageBegin('get_actual_joints_speed', TMessageType.CALL, self._seqid)
        args = get_actual_joints_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_speed failed: unknown result")

    def get_target_joints_speed(self):
        self.send_get_target_joints_speed()
        return self.recv_get_target_joints_speed()

    def send_get_target_joints_speed(self):
        self._oprot.writeMessageBegin('get_target_joints_speed', TMessageType.CALL, self._seqid)
        args = get_target_joints_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_speed failed: unknown result")

    def get_actual_joints_acceleration(self):
        self.send_get_actual_joints_acceleration()
        return self.recv_get_actual_joints_acceleration()

    def send_get_actual_joints_acceleration(self):
        self._oprot.writeMessageBegin('get_actual_joints_acceleration', TMessageType.CALL, self._seqid)
        args = get_actual_joints_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_acceleration failed: unknown result")

    def get_target_joints_acceleration(self):
        self.send_get_target_joints_acceleration()
        return self.recv_get_target_joints_acceleration()

    def send_get_target_joints_acceleration(self):
        self._oprot.writeMessageBegin('get_target_joints_acceleration', TMessageType.CALL, self._seqid)
        args = get_target_joints_acceleration_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_acceleration(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_acceleration_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_acceleration failed: unknown result")

    def get_actual_joints_torque(self):
        self.send_get_actual_joints_torque()
        return self.recv_get_actual_joints_torque()

    def send_get_actual_joints_torque(self):
        self._oprot.writeMessageBegin('get_actual_joints_torque', TMessageType.CALL, self._seqid)
        args = get_actual_joints_torque_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_actual_joints_torque(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_actual_joints_torque_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_actual_joints_torque failed: unknown result")

    def get_target_joints_torque(self):
        self.send_get_target_joints_torque()
        return self.recv_get_target_joints_torque()

    def send_get_target_joints_torque(self):
        self._oprot.writeMessageBegin('get_target_joints_torque', TMessageType.CALL, self._seqid)
        args = get_target_joints_torque_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_target_joints_torque(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_target_joints_torque_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_target_joints_torque failed: unknown result")

    def stop_record_track(self):
        self.send_stop_record_track()
        return self.recv_stop_record_track()

    def send_stop_record_track(self):
        self._oprot.writeMessageBegin('stop_record_track', TMessageType.CALL, self._seqid)
        args = stop_record_track_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_record_track(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_record_track_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stop_record_track failed: unknown result")

    def start_record_track(self, name, mode, tool, wobj, interval):
        """
        Parameters:
         - name
         - mode
         - tool
         - wobj
         - interval

        """
        self.send_start_record_track(name, mode, tool, wobj, interval)
        return self.recv_start_record_track()

    def send_start_record_track(self, name, mode, tool, wobj, interval):
        self._oprot.writeMessageBegin('start_record_track', TMessageType.CALL, self._seqid)
        args = start_record_track_args()
        args.name = name
        args.mode = mode
        args.tool = tool
        args.wobj = wobj
        args.interval = interval
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_record_track(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_record_track_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_record_track failed: unknown result")

    def collision_detect(self, value):
        """
        Parameters:
         - value

        """
        self.send_collision_detect(value)
        return self.recv_collision_detect()

    def send_collision_detect(self, value):
        self._oprot.writeMessageBegin('collision_detect', TMessageType.CALL, self._seqid)
        args = collision_detect_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_collision_detect(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = collision_detect_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "collision_detect failed: unknown result")

    def replay(self, name, value, mode):
        """
        Parameters:
         - name
         - value
         - mode

        """
        self.send_replay(name, value, mode)
        return self.recv_replay()

    def send_replay(self, name, value, mode):
        self._oprot.writeMessageBegin('replay', TMessageType.CALL, self._seqid)
        args = replay_args()
        args.name = name
        args.value = value
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_replay(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = replay_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "replay failed: unknown result")

    def set_load_data(self, value):
        """
        Parameters:
         - value

        """
        self.send_set_load_data(value)
        return self.recv_set_load_data()

    def send_set_load_data(self, value):
        self._oprot.writeMessageBegin('set_load_data', TMessageType.CALL, self._seqid)
        args = set_load_data_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_load_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_load_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_load_data failed: unknown result")

    def fc_start(self):
        self.send_fc_start()
        return self.recv_fc_start()

    def send_fc_start(self):
        self._oprot.writeMessageBegin('fc_start', TMessageType.CALL, self._seqid)
        args = fc_start_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_start(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_start_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_start failed: unknown result")

    def fc_stop(self):
        self.send_fc_stop()
        return self.recv_fc_stop()

    def send_fc_stop(self):
        self._oprot.writeMessageBegin('fc_stop', TMessageType.CALL, self._seqid)
        args = fc_stop_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_stop(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_stop_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_stop failed: unknown result")

    def fc_config(self, direction, ref_ft, damp, max_vel, number_list, tool, wobj, value):
        """
        Parameters:
         - direction
         - ref_ft
         - damp
         - max_vel
         - number_list
         - tool
         - wobj
         - value

        """
        self.send_fc_config(direction, ref_ft, damp, max_vel, number_list, tool, wobj, value)
        return self.recv_fc_config()

    def send_fc_config(self, direction, ref_ft, damp, max_vel, number_list, tool, wobj, value):
        self._oprot.writeMessageBegin('fc_config', TMessageType.CALL, self._seqid)
        args = fc_config_args()
        args.direction = direction
        args.ref_ft = ref_ft
        args.damp = damp
        args.max_vel = max_vel
        args.number_list = number_list
        args.tool = tool
        args.wobj = wobj
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_config(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_config_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_config failed: unknown result")

    def fc_move(self, block):
        """
        Parameters:
         - block

        """
        self.send_fc_move(block)
        return self.recv_fc_move()

    def send_fc_move(self, block):
        self._oprot.writeMessageBegin('fc_move', TMessageType.CALL, self._seqid)
        args = fc_move_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_move(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_move_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_move failed: unknown result")

    def fc_guard_act(self, direction, ref_ft, tool, wobj, type, force_property):
        """
        Parameters:
         - direction
         - ref_ft
         - tool
         - wobj
         - type
         - force_property

        """
        self.send_fc_guard_act(direction, ref_ft, tool, wobj, type, force_property)
        return self.recv_fc_guard_act()

    def send_fc_guard_act(self, direction, ref_ft, tool, wobj, type, force_property):
        self._oprot.writeMessageBegin('fc_guard_act', TMessageType.CALL, self._seqid)
        args = fc_guard_act_args()
        args.direction = direction
        args.ref_ft = ref_ft
        args.tool = tool
        args.wobj = wobj
        args.type = type
        args.force_property = force_property
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_guard_act(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_guard_act_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_guard_act failed: unknown result")

    def fc_guard_deact(self):
        self.send_fc_guard_deact()
        return self.recv_fc_guard_deact()

    def send_fc_guard_deact(self):
        self._oprot.writeMessageBegin('fc_guard_deact', TMessageType.CALL, self._seqid)
        args = fc_guard_deact_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_guard_deact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_guard_deact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_guard_deact failed: unknown result")

    def fc_force_set_value(self, direction, ref_ft):
        """
        Parameters:
         - direction
         - ref_ft

        """
        self.send_fc_force_set_value(direction, ref_ft)
        return self.recv_fc_force_set_value()

    def send_fc_force_set_value(self, direction, ref_ft):
        self._oprot.writeMessageBegin('fc_force_set_value', TMessageType.CALL, self._seqid)
        args = fc_force_set_value_args()
        args.direction = direction
        args.ref_ft = ref_ft
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_force_set_value(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_force_set_value_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_force_set_value failed: unknown result")

    def fc_wait_pos(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        self.send_fc_wait_pos(middle, range, absolute, duration, timeout)
        return self.recv_fc_wait_pos()

    def send_fc_wait_pos(self, middle, range, absolute, duration, timeout):
        self._oprot.writeMessageBegin('fc_wait_pos', TMessageType.CALL, self._seqid)
        args = fc_wait_pos_args()
        args.middle = middle
        args.range = range
        args.absolute = absolute
        args.duration = duration
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_pos(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_pos_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_pos failed: unknown result")

    def fc_wait_vel(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        self.send_fc_wait_vel(middle, range, absolute, duration, timeout)
        return self.recv_fc_wait_vel()

    def send_fc_wait_vel(self, middle, range, absolute, duration, timeout):
        self._oprot.writeMessageBegin('fc_wait_vel', TMessageType.CALL, self._seqid)
        args = fc_wait_vel_args()
        args.middle = middle
        args.range = range
        args.absolute = absolute
        args.duration = duration
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_vel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_vel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_vel failed: unknown result")

    def fc_wait_ft(self, middle, range, absolute, duration, timeout):
        """
        Parameters:
         - middle
         - range
         - absolute
         - duration
         - timeout

        """
        self.send_fc_wait_ft(middle, range, absolute, duration, timeout)
        return self.recv_fc_wait_ft()

    def send_fc_wait_ft(self, middle, range, absolute, duration, timeout):
        self._oprot.writeMessageBegin('fc_wait_ft', TMessageType.CALL, self._seqid)
        args = fc_wait_ft_args()
        args.middle = middle
        args.range = range
        args.absolute = absolute
        args.duration = duration
        args.timeout = timeout
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_ft(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_ft_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_ft failed: unknown result")

    def fc_wait_logic(self, value):
        """
        Parameters:
         - value

        """
        self.send_fc_wait_logic(value)
        return self.recv_fc_wait_logic()

    def send_fc_wait_logic(self, value):
        self._oprot.writeMessageBegin('fc_wait_logic', TMessageType.CALL, self._seqid)
        args = fc_wait_logic_args()
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_wait_logic(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_wait_logic_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_wait_logic failed: unknown result")

    def fc_get_ft(self):
        self.send_fc_get_ft()
        return self.recv_fc_get_ft()

    def send_fc_get_ft(self):
        self._oprot.writeMessageBegin('fc_get_ft', TMessageType.CALL, self._seqid)
        args = fc_get_ft_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_get_ft(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_get_ft_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_get_ft failed: unknown result")

    def fc_mode_is_active(self):
        self.send_fc_mode_is_active()
        return self.recv_fc_mode_is_active()

    def send_fc_mode_is_active(self):
        self._oprot.writeMessageBegin('fc_mode_is_active', TMessageType.CALL, self._seqid)
        args = fc_mode_is_active_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fc_mode_is_active(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fc_mode_is_active_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fc_mode_is_active failed: unknown result")

    def start_realtime_mode(self, mode, fileter_bandwidth, com_lost_time):
        """
        Parameters:
         - mode
         - fileter_bandwidth
         - com_lost_time

        """
        self.send_start_realtime_mode(mode, fileter_bandwidth, com_lost_time)
        return self.recv_start_realtime_mode()

    def send_start_realtime_mode(self, mode, fileter_bandwidth, com_lost_time):
        self._oprot.writeMessageBegin('start_realtime_mode', TMessageType.CALL, self._seqid)
        args = start_realtime_mode_args()
        args.mode = mode
        args.fileter_bandwidth = fileter_bandwidth
        args.com_lost_time = com_lost_time
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_realtime_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_realtime_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "start_realtime_mode failed: unknown result")

    def end_realtime_mode(self):
        self.send_end_realtime_mode()
        return self.recv_end_realtime_mode()

    def send_end_realtime_mode(self):
        self._oprot.writeMessageBegin('end_realtime_mode', TMessageType.CALL, self._seqid)
        args = end_realtime_mode_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_end_realtime_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = end_realtime_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "end_realtime_mode failed: unknown result")

    def realtime_data_enqueue(self, realtime_data, block):
        """
        Parameters:
         - realtime_data
         - block

        """
        self.send_realtime_data_enqueue(realtime_data, block)
        return self.recv_realtime_data_enqueue()

    def send_realtime_data_enqueue(self, realtime_data, block):
        self._oprot.writeMessageBegin('realtime_data_enqueue', TMessageType.CALL, self._seqid)
        args = realtime_data_enqueue_args()
        args.realtime_data = realtime_data
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_realtime_data_enqueue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = realtime_data_enqueue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "realtime_data_enqueue failed: unknown result")

    def clear_realtime_data_queue(self):
        self.send_clear_realtime_data_queue()
        return self.recv_clear_realtime_data_queue()

    def send_clear_realtime_data_queue(self):
        self._oprot.writeMessageBegin('clear_realtime_data_queue', TMessageType.CALL, self._seqid)
        args = clear_realtime_data_queue_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_clear_realtime_data_queue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = clear_realtime_data_queue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "clear_realtime_data_queue failed: unknown result")

    def get_realtime_data_queue_size(self):
        self.send_get_realtime_data_queue_size()
        return self.recv_get_realtime_data_queue_size()

    def send_get_realtime_data_queue_size(self):
        self._oprot.writeMessageBegin('get_realtime_data_queue_size', TMessageType.CALL, self._seqid)
        args = get_realtime_data_queue_size_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_realtime_data_queue_size(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_realtime_data_queue_size_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_realtime_data_queue_size failed: unknown result")

    def enable_speed_optimization(self):
        self.send_enable_speed_optimization()
        return self.recv_enable_speed_optimization()

    def send_enable_speed_optimization(self):
        self._oprot.writeMessageBegin('enable_speed_optimization', TMessageType.CALL, self._seqid)
        args = enable_speed_optimization_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_speed_optimization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_speed_optimization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_speed_optimization failed: unknown result")

    def disable_speed_optimization(self):
        self.send_disable_speed_optimization()
        return self.recv_disable_speed_optimization()

    def send_disable_speed_optimization(self):
        self._oprot.writeMessageBegin('disable_speed_optimization', TMessageType.CALL, self._seqid)
        args = disable_speed_optimization_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_speed_optimization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_speed_optimization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_speed_optimization failed: unknown result")

    def change_recipe(self):
        self.send_change_recipe()
        self.recv_change_recipe()

    def send_change_recipe(self):
        self._oprot.writeMessageBegin('change_recipe', TMessageType.CALL, self._seqid)
        args = change_recipe_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_change_recipe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = change_recipe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def set_system_value_bool(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        self.send_set_system_value_bool(name, value)
        return self.recv_set_system_value_bool()

    def send_set_system_value_bool(self, name, value):
        self._oprot.writeMessageBegin('set_system_value_bool', TMessageType.CALL, self._seqid)
        args = set_system_value_bool_args()
        args.name = name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_system_value_bool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_system_value_bool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_system_value_bool failed: unknown result")

    def set_system_value_double(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        self.send_set_system_value_double(name, value)
        return self.recv_set_system_value_double()

    def send_set_system_value_double(self, name, value):
        self._oprot.writeMessageBegin('set_system_value_double', TMessageType.CALL, self._seqid)
        args = set_system_value_double_args()
        args.name = name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_system_value_double(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_system_value_double_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_system_value_double failed: unknown result")

    def set_system_value_str(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        self.send_set_system_value_str(name, value)
        return self.recv_set_system_value_str()

    def send_set_system_value_str(self, name, value):
        self._oprot.writeMessageBegin('set_system_value_str', TMessageType.CALL, self._seqid)
        args = set_system_value_str_args()
        args.name = name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_system_value_str(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_system_value_str_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_system_value_str failed: unknown result")

    def set_system_value_list(self, name, value):
        """
        Parameters:
         - name
         - value

        """
        self.send_set_system_value_list(name, value)
        return self.recv_set_system_value_list()

    def send_set_system_value_list(self, name, value):
        self._oprot.writeMessageBegin('set_system_value_list', TMessageType.CALL, self._seqid)
        args = set_system_value_list_args()
        args.name = name
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_system_value_list(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_system_value_list_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_system_value_list failed: unknown result")

    def get_system_value_bool(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_system_value_bool(name)
        return self.recv_get_system_value_bool()

    def send_get_system_value_bool(self, name):
        self._oprot.writeMessageBegin('get_system_value_bool', TMessageType.CALL, self._seqid)
        args = get_system_value_bool_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_system_value_bool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_system_value_bool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_system_value_bool failed: unknown result")

    def get_system_value_double(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_system_value_double(name)
        return self.recv_get_system_value_double()

    def send_get_system_value_double(self, name):
        self._oprot.writeMessageBegin('get_system_value_double', TMessageType.CALL, self._seqid)
        args = get_system_value_double_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_system_value_double(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_system_value_double_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_system_value_double failed: unknown result")

    def get_system_value_str(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_system_value_str(name)
        return self.recv_get_system_value_str()

    def send_get_system_value_str(self, name):
        self._oprot.writeMessageBegin('get_system_value_str', TMessageType.CALL, self._seqid)
        args = get_system_value_str_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_system_value_str(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_system_value_str_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_system_value_str failed: unknown result")

    def get_system_value_list(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_system_value_list(name)
        return self.recv_get_system_value_list()

    def send_get_system_value_list(self, name):
        self._oprot.writeMessageBegin('get_system_value_list', TMessageType.CALL, self._seqid)
        args = get_system_value_list_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_system_value_list(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_system_value_list_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_system_value_list failed: unknown result")

    def trackEnqueue(self, track, block):
        """
        Parameters:
         - track
         - block

        """
        self.send_trackEnqueue(track, block)
        return self.recv_trackEnqueue()

    def send_trackEnqueue(self, track, block):
        self._oprot.writeMessageBegin('trackEnqueue', TMessageType.CALL, self._seqid)
        args = trackEnqueue_args()
        args.track = track
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_trackEnqueue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = trackEnqueue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "trackEnqueue failed: unknown result")

    def trackEnqueueOp(self, track, block):
        """
        Parameters:
         - track
         - block

        """
        self.send_trackEnqueueOp(track, block)
        return self.recv_trackEnqueueOp()

    def send_trackEnqueueOp(self, track, block):
        self._oprot.writeMessageBegin('trackEnqueueOp', TMessageType.CALL, self._seqid)
        args = trackEnqueueOp_args()
        args.track = track
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_trackEnqueueOp(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = trackEnqueueOp_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "trackEnqueueOp failed: unknown result")

    def trackClearQueue(self):
        self.send_trackClearQueue()
        return self.recv_trackClearQueue()

    def send_trackClearQueue(self):
        self._oprot.writeMessageBegin('trackClearQueue', TMessageType.CALL, self._seqid)
        args = trackClearQueue_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_trackClearQueue(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = trackClearQueue_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "trackClearQueue failed: unknown result")

    def getQueueSize(self):
        self.send_getQueueSize()
        return self.recv_getQueueSize()

    def send_getQueueSize(self):
        self._oprot.writeMessageBegin('getQueueSize', TMessageType.CALL, self._seqid)
        args = getQueueSize_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getQueueSize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getQueueSize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getQueueSize failed: unknown result")

    def trackJointMotion(self, speed, acc, block):
        """
        Parameters:
         - speed
         - acc
         - block

        """
        self.send_trackJointMotion(speed, acc, block)
        return self.recv_trackJointMotion()

    def send_trackJointMotion(self, speed, acc, block):
        self._oprot.writeMessageBegin('trackJointMotion', TMessageType.CALL, self._seqid)
        args = trackJointMotion_args()
        args.speed = speed
        args.acc = acc
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_trackJointMotion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = trackJointMotion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "trackJointMotion failed: unknown result")

    def trackCartMotion(self, speed, acc, block, tool, wobj, radius):
        """
        Parameters:
         - speed
         - acc
         - block
         - tool
         - wobj
         - radius

        """
        self.send_trackCartMotion(speed, acc, block, tool, wobj, radius)
        return self.recv_trackCartMotion()

    def send_trackCartMotion(self, speed, acc, block, tool, wobj, radius):
        self._oprot.writeMessageBegin('trackCartMotion', TMessageType.CALL, self._seqid)
        args = trackCartMotion_args()
        args.speed = speed
        args.acc = acc
        args.block = block
        args.tool = tool
        args.wobj = wobj
        args.radius = radius
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_trackCartMotion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = trackCartMotion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "trackCartMotion failed: unknown result")

    def rpc_heartbeat(self, time):
        """
        Parameters:
         - time

        """
        self.send_rpc_heartbeat(time)
        self.recv_rpc_heartbeat()

    def send_rpc_heartbeat(self, time):
        self._oprot.writeMessageBegin('rpc_heartbeat', TMessageType.CALL, self._seqid)
        args = rpc_heartbeat_args()
        args.time = time
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rpc_heartbeat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rpc_heartbeat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def move_spiral(self, p1, p2, rev, len, r, mode, v, a, q_near, tool, wobj, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - rev
         - len
         - r
         - mode
         - v
         - a
         - q_near
         - tool
         - wobj
         - block
         - op
         - def_acc

        """
        self.send_move_spiral(p1, p2, rev, len, r, mode, v, a, q_near, tool, wobj, block, op, def_acc)
        return self.recv_move_spiral()

    def send_move_spiral(self, p1, p2, rev, len, r, mode, v, a, q_near, tool, wobj, block, op, def_acc):
        self._oprot.writeMessageBegin('move_spiral', TMessageType.CALL, self._seqid)
        args = move_spiral_args()
        args.p1 = p1
        args.p2 = p2
        args.rev = rev
        args.len = len
        args.r = r
        args.mode = mode
        args.v = v
        args.a = a
        args.q_near = q_near
        args.tool = tool
        args.wobj = wobj
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_move_spiral(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = move_spiral_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "move_spiral failed: unknown result")

    def enable_acc_optimization(self):
        self.send_enable_acc_optimization()
        return self.recv_enable_acc_optimization()

    def send_enable_acc_optimization(self):
        self._oprot.writeMessageBegin('enable_acc_optimization', TMessageType.CALL, self._seqid)
        args = enable_acc_optimization_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_acc_optimization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_acc_optimization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_acc_optimization failed: unknown result")

    def disable_acc_optimization(self):
        self.send_disable_acc_optimization()
        return self.recv_disable_acc_optimization()

    def send_disable_acc_optimization(self):
        self._oprot.writeMessageBegin('disable_acc_optimization', TMessageType.CALL, self._seqid)
        args = disable_acc_optimization_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_acc_optimization(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_acc_optimization_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_acc_optimization failed: unknown result")

    def set_baudrate_485(self, value, block):
        """
        Parameters:
         - value
         - block

        """
        self.send_set_baudrate_485(value, block)
        return self.recv_set_baudrate_485()

    def send_set_baudrate_485(self, value, block):
        self._oprot.writeMessageBegin('set_baudrate_485', TMessageType.CALL, self._seqid)
        args = set_baudrate_485_args()
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_baudrate_485(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_baudrate_485_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_baudrate_485 failed: unknown result")

    def set_baudrate_can(self, value, block):
        """
        Parameters:
         - value
         - block

        """
        self.send_set_baudrate_can(value, block)
        return self.recv_set_baudrate_can()

    def send_set_baudrate_can(self, value, block):
        self._oprot.writeMessageBegin('set_baudrate_can', TMessageType.CALL, self._seqid)
        args = set_baudrate_can_args()
        args.value = value
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_baudrate_can(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_baudrate_can_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_baudrate_can failed: unknown result")

    def set_analog_output_mode(self, num, mode, block):
        """
        Parameters:
         - num
         - mode
         - block

        """
        self.send_set_analog_output_mode(num, mode, block)
        return self.recv_set_analog_output_mode()

    def send_set_analog_output_mode(self, num, mode, block):
        self._oprot.writeMessageBegin('set_analog_output_mode', TMessageType.CALL, self._seqid)
        args = set_analog_output_mode_args()
        args.num = num
        args.mode = mode
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_analog_output_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_analog_output_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_analog_output_mode failed: unknown result")

    def robotmoving(self):
        self.send_robotmoving()
        return self.recv_robotmoving()

    def send_robotmoving(self):
        self._oprot.writeMessageBegin('robotmoving', TMessageType.CALL, self._seqid)
        args = robotmoving_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_robotmoving(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = robotmoving_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "robotmoving failed: unknown result")

    def modbus_write_multiple_coils(self, slave_num, name, len, byte_list):
        """
        Parameters:
         - slave_num
         - name
         - len
         - byte_list

        """
        self.send_modbus_write_multiple_coils(slave_num, name, len, byte_list)
        return self.recv_modbus_write_multiple_coils()

    def send_modbus_write_multiple_coils(self, slave_num, name, len, byte_list):
        self._oprot.writeMessageBegin('modbus_write_multiple_coils', TMessageType.CALL, self._seqid)
        args = modbus_write_multiple_coils_args()
        args.slave_num = slave_num
        args.name = name
        args.len = len
        args.byte_list = byte_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_write_multiple_coils(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_write_multiple_coils_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_write_multiple_coils failed: unknown result")

    def modbus_write_multiple_regs(self, slave_num, name, len, word_list):
        """
        Parameters:
         - slave_num
         - name
         - len
         - word_list

        """
        self.send_modbus_write_multiple_regs(slave_num, name, len, word_list)
        return self.recv_modbus_write_multiple_regs()

    def send_modbus_write_multiple_regs(self, slave_num, name, len, word_list):
        self._oprot.writeMessageBegin('modbus_write_multiple_regs', TMessageType.CALL, self._seqid)
        args = modbus_write_multiple_regs_args()
        args.slave_num = slave_num
        args.name = name
        args.len = len
        args.word_list = word_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_modbus_write_multiple_regs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = modbus_write_multiple_regs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "modbus_write_multiple_regs failed: unknown result")

    def get_current_project(self):
        self.send_get_current_project()
        return self.recv_get_current_project()

    def send_get_current_project(self):
        self._oprot.writeMessageBegin('get_current_project', TMessageType.CALL, self._seqid)
        args = get_current_project_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_current_project(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_current_project_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_current_project failed: unknown result")

    def get_files_list(self, path):
        """
        Parameters:
         - path

        """
        self.send_get_files_list(path)
        return self.recv_get_files_list()

    def send_get_files_list(self, path):
        self._oprot.writeMessageBegin('get_files_list', TMessageType.CALL, self._seqid)
        args = get_files_list_args()
        args.path = path
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_files_list(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_files_list_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_files_list failed: unknown result")

    def getRobotStatus(self):
        self.send_getRobotStatus()
        return self.recv_getRobotStatus()

    def send_getRobotStatus(self):
        self._oprot.writeMessageBegin('getRobotStatus', TMessageType.CALL, self._seqid)
        args = getRobotStatus_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRobotStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRobotStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRobotStatus failed: unknown result")

    def getRobotIOStatus(self):
        self.send_getRobotIOStatus()
        return self.recv_getRobotIOStatus()

    def send_getRobotIOStatus(self):
        self._oprot.writeMessageBegin('getRobotIOStatus', TMessageType.CALL, self._seqid)
        args = getRobotIOStatus_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getRobotIOStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getRobotIOStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getRobotIOStatus failed: unknown result")

    def get_tcp_pose_coord(self, tool, wobj):
        """
        Parameters:
         - tool
         - wobj

        """
        self.send_get_tcp_pose_coord(tool, wobj)
        return self.recv_get_tcp_pose_coord()

    def send_get_tcp_pose_coord(self, tool, wobj):
        self._oprot.writeMessageBegin('get_tcp_pose_coord', TMessageType.CALL, self._seqid)
        args = get_tcp_pose_coord_args()
        args.tool = tool
        args.wobj = wobj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_pose_coord(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_pose_coord_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_pose_coord failed: unknown result")

    def get_tcp_force_tool(self, tool):
        """
        Parameters:
         - tool

        """
        self.send_get_tcp_force_tool(tool)
        return self.recv_get_tcp_force_tool()

    def send_get_tcp_force_tool(self, tool):
        self._oprot.writeMessageBegin('get_tcp_force_tool', TMessageType.CALL, self._seqid)
        args = get_tcp_force_tool_args()
        args.tool = tool
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tcp_force_tool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tcp_force_tool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tcp_force_tool failed: unknown result")

    def restart(self, block):
        """
        Parameters:
         - block

        """
        self.send_restart(block)
        return self.recv_restart()

    def send_restart(self, block):
        self._oprot.writeMessageBegin('restart', TMessageType.CALL, self._seqid)
        args = restart_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_restart(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = restart_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "restart failed: unknown result")

    def set_servo_config(self, axis_num, id, value, qfmt, block):
        """
        Parameters:
         - axis_num
         - id
         - value
         - qfmt
         - block

        """
        self.send_set_servo_config(axis_num, id, value, qfmt, block)
        return self.recv_set_servo_config()

    def send_set_servo_config(self, axis_num, id, value, qfmt, block):
        self._oprot.writeMessageBegin('set_servo_config', TMessageType.CALL, self._seqid)
        args = set_servo_config_args()
        args.axis_num = axis_num
        args.id = id
        args.value = value
        args.qfmt = qfmt
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_servo_config(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_servo_config_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_servo_config failed: unknown result")

    def apply_servo_config(self, axis_num, block):
        """
        Parameters:
         - axis_num
         - block

        """
        self.send_apply_servo_config(axis_num, block)
        return self.recv_apply_servo_config()

    def send_apply_servo_config(self, axis_num, block):
        self._oprot.writeMessageBegin('apply_servo_config', TMessageType.CALL, self._seqid)
        args = apply_servo_config_args()
        args.axis_num = axis_num
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_apply_servo_config(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = apply_servo_config_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "apply_servo_config failed: unknown result")

    def get_motor_pole_pair_number(self):
        self.send_get_motor_pole_pair_number()
        return self.recv_get_motor_pole_pair_number()

    def send_get_motor_pole_pair_number(self):
        self._oprot.writeMessageBegin('get_motor_pole_pair_number', TMessageType.CALL, self._seqid)
        args = get_motor_pole_pair_number_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_motor_pole_pair_number(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_motor_pole_pair_number_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_motor_pole_pair_number failed: unknown result")

    def get_motor_stator_slots(self):
        self.send_get_motor_stator_slots()
        return self.recv_get_motor_stator_slots()

    def send_get_motor_stator_slots(self):
        self._oprot.writeMessageBegin('get_motor_stator_slots', TMessageType.CALL, self._seqid)
        args = get_motor_stator_slots_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_motor_stator_slots(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_motor_stator_slots_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_motor_stator_slots failed: unknown result")

    def get_axis_ratio(self):
        self.send_get_axis_ratio()
        return self.recv_get_axis_ratio()

    def send_get_axis_ratio(self):
        self._oprot.writeMessageBegin('get_axis_ratio', TMessageType.CALL, self._seqid)
        args = get_axis_ratio_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_axis_ratio(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_axis_ratio_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_axis_ratio failed: unknown result")

    def collision_detection_reset(self):
        self.send_collision_detection_reset()
        return self.recv_collision_detection_reset()

    def send_collision_detection_reset(self):
        self._oprot.writeMessageBegin('collision_detection_reset', TMessageType.CALL, self._seqid)
        args = collision_detection_reset_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_collision_detection_reset(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = collision_detection_reset_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "collision_detection_reset failed: unknown result")

    def set_servo_file_params(self, axis_num, id, name, value, qfmt):
        """
        Parameters:
         - axis_num
         - id
         - name
         - value
         - qfmt

        """
        self.send_set_servo_file_params(axis_num, id, name, value, qfmt)
        return self.recv_set_servo_file_params()

    def send_set_servo_file_params(self, axis_num, id, name, value, qfmt):
        self._oprot.writeMessageBegin('set_servo_file_params', TMessageType.CALL, self._seqid)
        args = set_servo_file_params_args()
        args.axis_num = axis_num
        args.id = id
        args.name = name
        args.value = value
        args.qfmt = qfmt
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_servo_file_params(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_servo_file_params_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_servo_file_params failed: unknown result")

    def combine_motion_config(self, type, ref_plane, fq, amp, el_offset, az_offset, up_height, time, path_dwell, op_list):
        """
        Parameters:
         - type
         - ref_plane
         - fq
         - amp
         - el_offset
         - az_offset
         - up_height
         - time
         - path_dwell
         - op_list

        """
        self.send_combine_motion_config(type, ref_plane, fq, amp, el_offset, az_offset, up_height, time, path_dwell, op_list)
        return self.recv_combine_motion_config()

    def send_combine_motion_config(self, type, ref_plane, fq, amp, el_offset, az_offset, up_height, time, path_dwell, op_list):
        self._oprot.writeMessageBegin('combine_motion_config', TMessageType.CALL, self._seqid)
        args = combine_motion_config_args()
        args.type = type
        args.ref_plane = ref_plane
        args.fq = fq
        args.amp = amp
        args.el_offset = el_offset
        args.az_offset = az_offset
        args.up_height = up_height
        args.time = time
        args.path_dwell = path_dwell
        args.op_list = op_list
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_combine_motion_config(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = combine_motion_config_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "combine_motion_config failed: unknown result")

    def set_eaxis_param(self, num, param, block):
        """
        Parameters:
         - num
         - param
         - block

        """
        self.send_set_eaxis_param(num, param, block)
        return self.recv_set_eaxis_param()

    def send_set_eaxis_param(self, num, param, block):
        self._oprot.writeMessageBegin('set_eaxis_param', TMessageType.CALL, self._seqid)
        args = set_eaxis_param_args()
        args.num = num
        args.param = param
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_eaxis_param(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_eaxis_param_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_eaxis_param failed: unknown result")

    def add_eaxis_scheme(self, num, block):
        """
        Parameters:
         - num
         - block

        """
        self.send_add_eaxis_scheme(num, block)
        return self.recv_add_eaxis_scheme()

    def send_add_eaxis_scheme(self, num, block):
        self._oprot.writeMessageBegin('add_eaxis_scheme', TMessageType.CALL, self._seqid)
        args = add_eaxis_scheme_args()
        args.num = num
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_eaxis_scheme(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_eaxis_scheme_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_eaxis_scheme failed: unknown result")

    def delete_eaxis_scheme(self, num, block):
        """
        Parameters:
         - num
         - block

        """
        self.send_delete_eaxis_scheme(num, block)
        return self.recv_delete_eaxis_scheme()

    def send_delete_eaxis_scheme(self, num, block):
        self._oprot.writeMessageBegin('delete_eaxis_scheme', TMessageType.CALL, self._seqid)
        args = delete_eaxis_scheme_args()
        args.num = num
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_eaxis_scheme(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_eaxis_scheme_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_eaxis_scheme failed: unknown result")

    def enable_eaxis_scheme(self, scheme_name):
        """
        Parameters:
         - scheme_name

        """
        self.send_enable_eaxis_scheme(scheme_name)
        return self.recv_enable_eaxis_scheme()

    def send_enable_eaxis_scheme(self, scheme_name):
        self._oprot.writeMessageBegin('enable_eaxis_scheme', TMessageType.CALL, self._seqid)
        args = enable_eaxis_scheme_args()
        args.scheme_name = scheme_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_eaxis_scheme(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_eaxis_scheme_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_eaxis_scheme failed: unknown result")

    def disable_eaxis_scheme(self, scheme_name):
        """
        Parameters:
         - scheme_name

        """
        self.send_disable_eaxis_scheme(scheme_name)
        return self.recv_disable_eaxis_scheme()

    def send_disable_eaxis_scheme(self, scheme_name):
        self._oprot.writeMessageBegin('disable_eaxis_scheme', TMessageType.CALL, self._seqid)
        args = disable_eaxis_scheme_args()
        args.scheme_name = scheme_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_eaxis_scheme(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_eaxis_scheme_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_eaxis_scheme failed: unknown result")

    def set_eaxiss_scheme_param(self, num, param, block):
        """
        Parameters:
         - num
         - param
         - block

        """
        self.send_set_eaxiss_scheme_param(num, param, block)
        return self.recv_set_eaxiss_scheme_param()

    def send_set_eaxiss_scheme_param(self, num, param, block):
        self._oprot.writeMessageBegin('set_eaxiss_scheme_param', TMessageType.CALL, self._seqid)
        args = set_eaxiss_scheme_param_args()
        args.num = num
        args.param = param
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_eaxiss_scheme_param(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_eaxiss_scheme_param_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_eaxiss_scheme_param failed: unknown result")

    def move_jog(self, param, block):
        """
        Parameters:
         - param
         - block

        """
        self.send_move_jog(param, block)
        return self.recv_move_jog()

    def send_move_jog(self, param, block):
        self._oprot.writeMessageBegin('move_jog', TMessageType.CALL, self._seqid)
        args = move_jog_args()
        args.param = param
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_move_jog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = move_jog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "move_jog failed: unknown result")

    def stop_manual_move(self, block):
        """
        Parameters:
         - block

        """
        self.send_stop_manual_move(block)
        return self.recv_stop_manual_move()

    def send_stop_manual_move(self, block):
        self._oprot.writeMessageBegin('stop_manual_move', TMessageType.CALL, self._seqid)
        args = stop_manual_move_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_manual_move(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_manual_move_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "stop_manual_move failed: unknown result")

    def get_robot_version(self):
        self.send_get_robot_version()
        return self.recv_get_robot_version()

    def send_get_robot_version(self):
        self._oprot.writeMessageBegin('get_robot_version', TMessageType.CALL, self._seqid)
        args = get_robot_version_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_robot_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_robot_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_robot_version failed: unknown result")

    def set_teach_pendant(self, enable):
        """
        Parameters:
         - enable

        """
        self.send_set_teach_pendant(enable)
        return self.recv_set_teach_pendant()

    def send_set_teach_pendant(self, enable):
        self._oprot.writeMessageBegin('set_teach_pendant', TMessageType.CALL, self._seqid)
        args = set_teach_pendant_args()
        args.enable = enable
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_teach_pendant(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_teach_pendant_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_teach_pendant failed: unknown result")

    def get_teach_speed(self):
        self.send_get_teach_speed()
        return self.recv_get_teach_speed()

    def send_get_teach_speed(self):
        self._oprot.writeMessageBegin('get_teach_speed', TMessageType.CALL, self._seqid)
        args = get_teach_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_teach_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_teach_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_teach_speed failed: unknown result")

    def get_global_speed(self):
        self.send_get_global_speed()
        return self.recv_get_global_speed()

    def send_get_global_speed(self):
        self._oprot.writeMessageBegin('get_global_speed', TMessageType.CALL, self._seqid)
        args = get_global_speed_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_global_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_global_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_global_speed failed: unknown result")

    def set_teach_speed(self, v):
        """
        Parameters:
         - v

        """
        self.send_set_teach_speed(v)
        return self.recv_set_teach_speed()

    def send_set_teach_speed(self, v):
        self._oprot.writeMessageBegin('set_teach_speed', TMessageType.CALL, self._seqid)
        args = set_teach_speed_args()
        args.v = v
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_teach_speed(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_teach_speed_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_teach_speed failed: unknown result")

    def enable_combine_motion(self):
        self.send_enable_combine_motion()
        return self.recv_enable_combine_motion()

    def send_enable_combine_motion(self):
        self._oprot.writeMessageBegin('enable_combine_motion', TMessageType.CALL, self._seqid)
        args = enable_combine_motion_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_combine_motion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_combine_motion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_combine_motion failed: unknown result")

    def disable_combine_motion(self):
        self.send_disable_combine_motion()
        return self.recv_disable_combine_motion()

    def send_disable_combine_motion(self):
        self._oprot.writeMessageBegin('disable_combine_motion', TMessageType.CALL, self._seqid)
        args = disable_combine_motion_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_combine_motion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_combine_motion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_combine_motion failed: unknown result")

    def enable_singularity_control(self):
        self.send_enable_singularity_control()
        return self.recv_enable_singularity_control()

    def send_enable_singularity_control(self):
        self._oprot.writeMessageBegin('enable_singularity_control', TMessageType.CALL, self._seqid)
        args = enable_singularity_control_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_singularity_control(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_singularity_control_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_singularity_control failed: unknown result")

    def disable_singularity_control(self):
        self.send_disable_singularity_control()
        return self.recv_disable_singularity_control()

    def send_disable_singularity_control(self):
        self._oprot.writeMessageBegin('disable_singularity_control', TMessageType.CALL, self._seqid)
        args = disable_singularity_control_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_singularity_control(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_singularity_control_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_singularity_control failed: unknown result")

    def enable_vibration_control(self):
        self.send_enable_vibration_control()
        return self.recv_enable_vibration_control()

    def send_enable_vibration_control(self):
        self._oprot.writeMessageBegin('enable_vibration_control', TMessageType.CALL, self._seqid)
        args = enable_vibration_control_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_enable_vibration_control(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = enable_vibration_control_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "enable_vibration_control failed: unknown result")

    def disable_vibration_control(self):
        self.send_disable_vibration_control()
        return self.recv_disable_vibration_control()

    def send_disable_vibration_control(self):
        self._oprot.writeMessageBegin('disable_vibration_control', TMessageType.CALL, self._seqid)
        args = disable_vibration_control_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_disable_vibration_control(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = disable_vibration_control_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "disable_vibration_control failed: unknown result")

    def move_eaxis(self, scheme_name, epose, v, block, op):
        """
        Parameters:
         - scheme_name
         - epose
         - v
         - block
         - op

        """
        self.send_move_eaxis(scheme_name, epose, v, block, op)
        return self.recv_move_eaxis()

    def send_move_eaxis(self, scheme_name, epose, v, block, op):
        self._oprot.writeMessageBegin('move_eaxis', TMessageType.CALL, self._seqid)
        args = move_eaxis_args()
        args.scheme_name = scheme_name
        args.epose = epose
        args.v = v
        args.block = block
        args.op = op
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_move_eaxis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = move_eaxis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "move_eaxis failed: unknown result")

    def movej2_eaxis(self, joints_list, v, a, rad, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - joints_list
         - v
         - a
         - rad
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        self.send_movej2_eaxis(joints_list, v, a, rad, scheme_name, epose, eaxis_v, block, op, def_acc)
        return self.recv_movej2_eaxis()

    def send_movej2_eaxis(self, joints_list, v, a, rad, scheme_name, epose, eaxis_v, block, op, def_acc):
        self._oprot.writeMessageBegin('movej2_eaxis', TMessageType.CALL, self._seqid)
        args = movej2_eaxis_args()
        args.joints_list = joints_list
        args.v = v
        args.a = a
        args.rad = rad
        args.scheme_name = scheme_name
        args.epose = epose
        args.eaxis_v = eaxis_v
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej2_eaxis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej2_eaxis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej2_eaxis failed: unknown result")

    def movej2_pose_eaxis(self, p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - rad
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        self.send_movej2_pose_eaxis(p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc)
        return self.recv_movej2_pose_eaxis()

    def send_movej2_pose_eaxis(self, p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        self._oprot.writeMessageBegin('movej2_pose_eaxis', TMessageType.CALL, self._seqid)
        args = movej2_pose_eaxis_args()
        args.p = p
        args.v = v
        args.a = a
        args.rad = rad
        args.qnear = qnear
        args.tool = tool
        args.wobj = wobj
        args.scheme_name = scheme_name
        args.epose = epose
        args.eaxis_v = eaxis_v
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movej2_pose_eaxis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movej2_pose_eaxis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movej2_pose_eaxis failed: unknown result")

    def movel_eaxis(self, p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - p
         - v
         - a
         - rad
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        self.send_movel_eaxis(p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc)
        return self.recv_movel_eaxis()

    def send_movel_eaxis(self, p, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        self._oprot.writeMessageBegin('movel_eaxis', TMessageType.CALL, self._seqid)
        args = movel_eaxis_args()
        args.p = p
        args.v = v
        args.a = a
        args.rad = rad
        args.qnear = qnear
        args.tool = tool
        args.wobj = wobj
        args.scheme_name = scheme_name
        args.epose = epose
        args.eaxis_v = eaxis_v
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movel_eaxis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movel_eaxis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movel_eaxis failed: unknown result")

    def movec_eaxis(self, p1, p2, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc, mode):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - rad
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc
         - mode

        """
        self.send_movec_eaxis(p1, p2, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc, mode)
        return self.recv_movec_eaxis()

    def send_movec_eaxis(self, p1, p2, v, a, rad, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc, mode):
        self._oprot.writeMessageBegin('movec_eaxis', TMessageType.CALL, self._seqid)
        args = movec_eaxis_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.rad = rad
        args.qnear = qnear
        args.tool = tool
        args.wobj = wobj
        args.scheme_name = scheme_name
        args.epose = epose
        args.eaxis_v = eaxis_v
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_movec_eaxis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = movec_eaxis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "movec_eaxis failed: unknown result")

    def move_circle_eaxis(self, p1, p2, v, a, rad, mode, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        """
        Parameters:
         - p1
         - p2
         - v
         - a
         - rad
         - mode
         - qnear
         - tool
         - wobj
         - scheme_name
         - epose
         - eaxis_v
         - block
         - op
         - def_acc

        """
        self.send_move_circle_eaxis(p1, p2, v, a, rad, mode, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc)
        return self.recv_move_circle_eaxis()

    def send_move_circle_eaxis(self, p1, p2, v, a, rad, mode, qnear, tool, wobj, scheme_name, epose, eaxis_v, block, op, def_acc):
        self._oprot.writeMessageBegin('move_circle_eaxis', TMessageType.CALL, self._seqid)
        args = move_circle_eaxis_args()
        args.p1 = p1
        args.p2 = p2
        args.v = v
        args.a = a
        args.rad = rad
        args.mode = mode
        args.qnear = qnear
        args.tool = tool
        args.wobj = wobj
        args.scheme_name = scheme_name
        args.epose = epose
        args.eaxis_v = eaxis_v
        args.block = block
        args.op = op
        args.def_acc = def_acc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_move_circle_eaxis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = move_circle_eaxis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "move_circle_eaxis failed: unknown result")

    def reach_check(self, base, wobj, tool, ref_pos, check_points):
        """
        Parameters:
         - base
         - wobj
         - tool
         - ref_pos
         - check_points

        """
        self.send_reach_check(base, wobj, tool, ref_pos, check_points)
        return self.recv_reach_check()

    def send_reach_check(self, base, wobj, tool, ref_pos, check_points):
        self._oprot.writeMessageBegin('reach_check', TMessageType.CALL, self._seqid)
        args = reach_check_args()
        args.base = base
        args.wobj = wobj
        args.tool = tool
        args.ref_pos = ref_pos
        args.check_points = check_points
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reach_check(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reach_check_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "reach_check failed: unknown result")

    def move_jog_eaxis(self, name, direction, vel, block):
        """
        Parameters:
         - name
         - direction
         - vel
         - block

        """
        self.send_move_jog_eaxis(name, direction, vel, block)
        return self.recv_move_jog_eaxis()

    def send_move_jog_eaxis(self, name, direction, vel, block):
        self._oprot.writeMessageBegin('move_jog_eaxis', TMessageType.CALL, self._seqid)
        args = move_jog_eaxis_args()
        args.name = name
        args.direction = direction
        args.vel = vel
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_move_jog_eaxis(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = move_jog_eaxis_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "move_jog_eaxis failed: unknown result")

    def get_eaxis_info(self):
        self.send_get_eaxis_info()
        return self.recv_get_eaxis_info()

    def send_get_eaxis_info(self):
        self._oprot.writeMessageBegin('get_eaxis_info', TMessageType.CALL, self._seqid)
        args = get_eaxis_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_eaxis_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_eaxis_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_eaxis_info failed: unknown result")

    def set_hand_teach_parameter(self, space, joint_scale, cart_scale, coord_type, direction):
        """
        Parameters:
         - space
         - joint_scale
         - cart_scale
         - coord_type
         - direction

        """
        self.send_set_hand_teach_parameter(space, joint_scale, cart_scale, coord_type, direction)
        return self.recv_set_hand_teach_parameter()

    def send_set_hand_teach_parameter(self, space, joint_scale, cart_scale, coord_type, direction):
        self._oprot.writeMessageBegin('set_hand_teach_parameter', TMessageType.CALL, self._seqid)
        args = set_hand_teach_parameter_args()
        args.space = space
        args.joint_scale = joint_scale
        args.cart_scale = cart_scale
        args.coord_type = coord_type
        args.direction = direction
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_hand_teach_parameter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_hand_teach_parameter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_hand_teach_parameter failed: unknown result")

    def set_pendant_type(self, type):
        """
        Parameters:
         - type

        """
        self.send_set_pendant_type(type)
        return self.recv_set_pendant_type()

    def send_set_pendant_type(self, type):
        self._oprot.writeMessageBegin('set_pendant_type', TMessageType.CALL, self._seqid)
        args = set_pendant_type_args()
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_pendant_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_pendant_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_pendant_type failed: unknown result")

    def set_blend_ahead(self, per, num):
        """
        Parameters:
         - per
         - num

        """
        self.send_set_blend_ahead(per, num)
        return self.recv_set_blend_ahead()

    def send_set_blend_ahead(self, per, num):
        self._oprot.writeMessageBegin('set_blend_ahead', TMessageType.CALL, self._seqid)
        args = set_blend_ahead_args()
        args.per = per
        args.num = num
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_blend_ahead(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_blend_ahead_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_blend_ahead failed: unknown result")

    def switch_mode(self, mode):
        """
        Parameters:
         - mode

        """
        self.send_switch_mode(mode)
        return self.recv_switch_mode()

    def send_switch_mode(self, mode):
        self._oprot.writeMessageBegin('switch_mode', TMessageType.CALL, self._seqid)
        args = switch_mode_args()
        args.mode = mode
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_switch_mode(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = switch_mode_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "switch_mode failed: unknown result")

    def read_encoder_count(self):
        self.send_read_encoder_count()
        return self.recv_read_encoder_count()

    def send_read_encoder_count(self):
        self._oprot.writeMessageBegin('read_encoder_count', TMessageType.CALL, self._seqid)
        args = read_encoder_count_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read_encoder_count(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_encoder_count_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read_encoder_count failed: unknown result")

    def set_kinematic_calibration_params(self, params):
        """
        Parameters:
         - params

        """
        self.send_set_kinematic_calibration_params(params)
        return self.recv_set_kinematic_calibration_params()

    def send_set_kinematic_calibration_params(self, params):
        self._oprot.writeMessageBegin('set_kinematic_calibration_params', TMessageType.CALL, self._seqid)
        args = set_kinematic_calibration_params_args()
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_kinematic_calibration_params(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_kinematic_calibration_params_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_kinematic_calibration_params failed: unknown result")

    def get_pos_bias(self):
        self.send_get_pos_bias()
        return self.recv_get_pos_bias()

    def send_get_pos_bias(self):
        self._oprot.writeMessageBegin('get_pos_bias', TMessageType.CALL, self._seqid)
        args = get_pos_bias_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_pos_bias(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_pos_bias_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_pos_bias failed: unknown result")

    def get_system_value_lists(self, name):
        """
        Parameters:
         - name

        """
        self.send_get_system_value_lists(name)
        return self.recv_get_system_value_lists()

    def send_get_system_value_lists(self, name):
        self._oprot.writeMessageBegin('get_system_value_lists', TMessageType.CALL, self._seqid)
        args = get_system_value_lists_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_system_value_lists(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_system_value_lists_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_system_value_lists failed: unknown result")

    def get_origin_DH(self):
        self.send_get_origin_DH()
        return self.recv_get_origin_DH()

    def send_get_origin_DH(self):
        self._oprot.writeMessageBegin('get_origin_DH', TMessageType.CALL, self._seqid)
        args = get_origin_DH_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_origin_DH(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_origin_DH_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_origin_DH failed: unknown result")

    def get_calib_DH(self):
        self.send_get_calib_DH()
        return self.recv_get_calib_DH()

    def send_get_calib_DH(self):
        self._oprot.writeMessageBegin('get_calib_DH', TMessageType.CALL, self._seqid)
        args = get_calib_DH_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_calib_DH(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_calib_DH_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_calib_DH failed: unknown result")

    def get_robot_type(self):
        self.send_get_robot_type()
        return self.recv_get_robot_type()

    def send_get_robot_type(self):
        self._oprot.writeMessageBegin('get_robot_type', TMessageType.CALL, self._seqid)
        args = get_robot_type_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_robot_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_robot_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_robot_type failed: unknown result")

    def get_ext_torque(self):
        self.send_get_ext_torque()
        return self.recv_get_ext_torque()

    def send_get_ext_torque(self):
        self._oprot.writeMessageBegin('get_ext_torque', TMessageType.CALL, self._seqid)
        args = get_ext_torque_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_ext_torque(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_ext_torque_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_ext_torque failed: unknown result")

    def set_dynamic_calibration_params(self, params):
        """
        Parameters:
         - params

        """
        self.send_set_dynamic_calibration_params(params)
        return self.recv_set_dynamic_calibration_params()

    def send_set_dynamic_calibration_params(self, params):
        self._oprot.writeMessageBegin('set_dynamic_calibration_params', TMessageType.CALL, self._seqid)
        args = set_dynamic_calibration_params_args()
        args.params = params
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_dynamic_calibration_params(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_dynamic_calibration_params_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_dynamic_calibration_params failed: unknown result")

    def get_dynamic_calibration_params(self):
        self.send_get_dynamic_calibration_params()
        return self.recv_get_dynamic_calibration_params()

    def send_get_dynamic_calibration_params(self):
        self._oprot.writeMessageBegin('get_dynamic_calibration_params', TMessageType.CALL, self._seqid)
        args = get_dynamic_calibration_params_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_dynamic_calibration_params(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_dynamic_calibration_params_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_dynamic_calibration_params failed: unknown result")

    def upload_robot_param_to_toolboard(self, passwd):
        """
        Parameters:
         - passwd

        """
        self.send_upload_robot_param_to_toolboard(passwd)
        return self.recv_upload_robot_param_to_toolboard()

    def send_upload_robot_param_to_toolboard(self, passwd):
        self._oprot.writeMessageBegin('upload_robot_param_to_toolboard', TMessageType.CALL, self._seqid)
        args = upload_robot_param_to_toolboard_args()
        args.passwd = passwd
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_upload_robot_param_to_toolboard(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = upload_robot_param_to_toolboard_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "upload_robot_param_to_toolboard failed: unknown result")

    def set_kinematic_calibration_info(self, passwd, info):
        """
        Parameters:
         - passwd
         - info

        """
        self.send_set_kinematic_calibration_info(passwd, info)
        return self.recv_set_kinematic_calibration_info()

    def send_set_kinematic_calibration_info(self, passwd, info):
        self._oprot.writeMessageBegin('set_kinematic_calibration_info', TMessageType.CALL, self._seqid)
        args = set_kinematic_calibration_info_args()
        args.passwd = passwd
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_kinematic_calibration_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_kinematic_calibration_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_kinematic_calibration_info failed: unknown result")

    def set_dynamic_calibration_info(self, passwd, info):
        """
        Parameters:
         - passwd
         - info

        """
        self.send_set_dynamic_calibration_info(passwd, info)
        return self.recv_set_dynamic_calibration_info()

    def send_set_dynamic_calibration_info(self, passwd, info):
        self._oprot.writeMessageBegin('set_dynamic_calibration_info', TMessageType.CALL, self._seqid)
        args = set_dynamic_calibration_info_args()
        args.passwd = passwd
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_dynamic_calibration_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_dynamic_calibration_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_dynamic_calibration_info failed: unknown result")

    def set_vibration_calibration_info(self, passwd, info):
        """
        Parameters:
         - passwd
         - info

        """
        self.send_set_vibration_calibration_info(passwd, info)
        return self.recv_set_vibration_calibration_info()

    def send_set_vibration_calibration_info(self, passwd, info):
        self._oprot.writeMessageBegin('set_vibration_calibration_info', TMessageType.CALL, self._seqid)
        args = set_vibration_calibration_info_args()
        args.passwd = passwd
        args.info = info
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_vibration_calibration_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_vibration_calibration_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_vibration_calibration_info failed: unknown result")

    def get_axis_motor_rated_current(self):
        self.send_get_axis_motor_rated_current()
        return self.recv_get_axis_motor_rated_current()

    def send_get_axis_motor_rated_current(self):
        self._oprot.writeMessageBegin('get_axis_motor_rated_current', TMessageType.CALL, self._seqid)
        args = get_axis_motor_rated_current_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_axis_motor_rated_current(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_axis_motor_rated_current_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_axis_motor_rated_current failed: unknown result")

    def get_axis_motor_kt(self):
        self.send_get_axis_motor_kt()
        return self.recv_get_axis_motor_kt()

    def send_get_axis_motor_kt(self):
        self._oprot.writeMessageBegin('get_axis_motor_kt', TMessageType.CALL, self._seqid)
        args = get_axis_motor_kt_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_axis_motor_kt(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_axis_motor_kt_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_axis_motor_kt failed: unknown result")

    def abort(self, block):
        """
        Parameters:
         - block

        """
        self.send_abort(block)
        return self.recv_abort()

    def send_abort(self, block):
        self._oprot.writeMessageBegin('abort', TMessageType.CALL, self._seqid)
        args = abort_args()
        args.block = block
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "abort failed: unknown result")

    def get_vibration_calibration_params(self):
        self.send_get_vibration_calibration_params()
        return self.recv_get_vibration_calibration_params()

    def send_get_vibration_calibration_params(self):
        self._oprot.writeMessageBegin('get_vibration_calibration_params', TMessageType.CALL, self._seqid)
        args = get_vibration_calibration_params_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_vibration_calibration_params(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_vibration_calibration_params_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_vibration_calibration_params failed: unknown result")

    def save_kinematic_calibration_params(self, passwd):
        """
        Parameters:
         - passwd

        """
        self.send_save_kinematic_calibration_params(passwd)
        return self.recv_save_kinematic_calibration_params()

    def send_save_kinematic_calibration_params(self, passwd):
        self._oprot.writeMessageBegin('save_kinematic_calibration_params', TMessageType.CALL, self._seqid)
        args = save_kinematic_calibration_params_args()
        args.passwd = passwd
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_save_kinematic_calibration_params(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = save_kinematic_calibration_params_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "save_kinematic_calibration_params failed: unknown result")

    def save_dynamic_calibration_params(self, passwd):
        """
        Parameters:
         - passwd

        """
        self.send_save_dynamic_calibration_params(passwd)
        return self.recv_save_dynamic_calibration_params()

    def send_save_dynamic_calibration_params(self, passwd):
        self._oprot.writeMessageBegin('save_dynamic_calibration_params', TMessageType.CALL, self._seqid)
        args = save_dynamic_calibration_params_args()
        args.passwd = passwd
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_save_dynamic_calibration_params(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = save_dynamic_calibration_params_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "save_dynamic_calibration_params failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["power_on"] = Processor.process_power_on
        self._processMap["power_off"] = Processor.process_power_off
        self._processMap["enable"] = Processor.process_enable
        self._processMap["disable"] = Processor.process_disable
        self._processMap["shutdown"] = Processor.process_shutdown
        self._processMap["stop"] = Processor.process_stop
        self._processMap["pause"] = Processor.process_pause
        self._processMap["resume"] = Processor.process_resume
        self._processMap["run_program"] = Processor.process_run_program
        self._processMap["set_tool_data"] = Processor.process_set_tool_data
        self._processMap["get_tool_load"] = Processor.process_get_tool_load
        self._processMap["get_tcp_offset"] = Processor.process_get_tcp_offset
        self._processMap["set_wobj"] = Processor.process_set_wobj
        self._processMap["set_wobj_offset"] = Processor.process_set_wobj_offset
        self._processMap["get_wobj"] = Processor.process_get_wobj
        self._processMap["cal_fkine"] = Processor.process_cal_fkine
        self._processMap["cal_ikine"] = Processor.process_cal_ikine
        self._processMap["set_digital_output_mode"] = Processor.process_set_digital_output_mode
        self._processMap["set_standard_digital_out"] = Processor.process_set_standard_digital_out
        self._processMap["set_tool_digital_out"] = Processor.process_set_tool_digital_out
        self._processMap["get_standard_digital_in"] = Processor.process_get_standard_digital_in
        self._processMap["get_standard_digital_out"] = Processor.process_get_standard_digital_out
        self._processMap["get_tool_digital_in"] = Processor.process_get_tool_digital_in
        self._processMap["get_tool_digital_out"] = Processor.process_get_tool_digital_out
        self._processMap["get_config_digital_in"] = Processor.process_get_config_digital_in
        self._processMap["get_standard_analog_voltage_in"] = Processor.process_get_standard_analog_voltage_in
        self._processMap["get_tool_analog_voltage_in"] = Processor.process_get_tool_analog_voltage_in
        self._processMap["get_standard_analog_current_in"] = Processor.process_get_standard_analog_current_in
        self._processMap["set_standard_analog_voltage_out"] = Processor.process_set_standard_analog_voltage_out
        self._processMap["set_standard_analog_current_out"] = Processor.process_set_standard_analog_current_out
        self._processMap["read_data_485"] = Processor.process_read_data_485
        self._processMap["read_raw_data_485"] = Processor.process_read_raw_data_485
        self._processMap["read_raw_data_485_ht"] = Processor.process_read_raw_data_485_ht
        self._processMap["read_raw_data_485_h"] = Processor.process_read_raw_data_485_h
        self._processMap["write_data_485"] = Processor.process_write_data_485
        self._processMap["write_raw_data_485"] = Processor.process_write_raw_data_485
        self._processMap["write_raw_data_485_h"] = Processor.process_write_raw_data_485_h
        self._processMap["write_raw_data_485_ht"] = Processor.process_write_raw_data_485_ht
        self._processMap["tool_read_data_485"] = Processor.process_tool_read_data_485
        self._processMap["tool_read_raw_data_485"] = Processor.process_tool_read_raw_data_485
        self._processMap["tool_read_raw_data_485_h"] = Processor.process_tool_read_raw_data_485_h
        self._processMap["tool_read_raw_data_485_ht"] = Processor.process_tool_read_raw_data_485_ht
        self._processMap["tool_write_data_485"] = Processor.process_tool_write_data_485
        self._processMap["tool_write_raw_data_485"] = Processor.process_tool_write_raw_data_485
        self._processMap["tool_write_raw_data_485_h"] = Processor.process_tool_write_raw_data_485_h
        self._processMap["tool_write_raw_data_485_ht"] = Processor.process_tool_write_raw_data_485_ht
        self._processMap["read_data_can"] = Processor.process_read_data_can
        self._processMap["read_raw_data_can"] = Processor.process_read_raw_data_can
        self._processMap["write_data_can"] = Processor.process_write_data_can
        self._processMap["write_raw_data_can"] = Processor.process_write_raw_data_can
        self._processMap["get_function_digital_in"] = Processor.process_get_function_digital_in
        self._processMap["get_function_digital_out"] = Processor.process_get_function_digital_out
        self._processMap["read_bool_reg"] = Processor.process_read_bool_reg
        self._processMap["read_word_reg"] = Processor.process_read_word_reg
        self._processMap["read_float_reg"] = Processor.process_read_float_reg
        self._processMap["write_bool_reg"] = Processor.process_write_bool_reg
        self._processMap["write_word_reg"] = Processor.process_write_word_reg
        self._processMap["write_float_reg"] = Processor.process_write_float_reg
        self._processMap["get_function_reg_in"] = Processor.process_get_function_reg_in
        self._processMap["get_function_reg_out"] = Processor.process_get_function_reg_out
        self._processMap["movej"] = Processor.process_movej
        self._processMap["movej_pose"] = Processor.process_movej_pose
        self._processMap["movej2"] = Processor.process_movej2
        self._processMap["movej_pose2"] = Processor.process_movej_pose2
        self._processMap["movel"] = Processor.process_movel
        self._processMap["movec"] = Processor.process_movec
        self._processMap["move_circle"] = Processor.process_move_circle
        self._processMap["tcp_move"] = Processor.process_tcp_move
        self._processMap["tcp_move_2p"] = Processor.process_tcp_move_2p
        self._processMap["wobj_move"] = Processor.process_wobj_move
        self._processMap["wobj_move_2p"] = Processor.process_wobj_move_2p
        self._processMap["spline"] = Processor.process_spline
        self._processMap["spline_op"] = Processor.process_spline_op
        self._processMap["speedj"] = Processor.process_speedj
        self._processMap["speedl"] = Processor.process_speedl
        self._processMap["speed_stop"] = Processor.process_speed_stop
        self._processMap["servoj"] = Processor.process_servoj
        self._processMap["servoj_pose"] = Processor.process_servoj_pose
        self._processMap["servo_tcp"] = Processor.process_servo_tcp
        self._processMap["servol"] = Processor.process_servol
        self._processMap["teach_mode"] = Processor.process_teach_mode
        self._processMap["end_teach_mode"] = Processor.process_end_teach_mode
        self._processMap["modbus_add_signal"] = Processor.process_modbus_add_signal
        self._processMap["modbus_delete_signal"] = Processor.process_modbus_delete_signal
        self._processMap["modbus_read"] = Processor.process_modbus_read
        self._processMap["modbus_write"] = Processor.process_modbus_write
        self._processMap["modbus_set_frequency"] = Processor.process_modbus_set_frequency
        self._processMap["get_last_error"] = Processor.process_get_last_error
        self._processMap["get_noneblock_taskstate"] = Processor.process_get_noneblock_taskstate
        self._processMap["log_info"] = Processor.process_log_info
        self._processMap["log_error"] = Processor.process_log_error
        self._processMap["simulation"] = Processor.process_simulation
        self._processMap["speed"] = Processor.process_speed
        self._processMap["get_robot_state"] = Processor.process_get_robot_state
        self._processMap["get_flange_pose"] = Processor.process_get_flange_pose
        self._processMap["get_flange_speed"] = Processor.process_get_flange_speed
        self._processMap["get_flange_acceleration"] = Processor.process_get_flange_acceleration
        self._processMap["get_tcp_pose"] = Processor.process_get_tcp_pose
        self._processMap["get_tcp_speed"] = Processor.process_get_tcp_speed
        self._processMap["get_tcp_acceleration"] = Processor.process_get_tcp_acceleration
        self._processMap["get_tcp_force"] = Processor.process_get_tcp_force
        self._processMap["get_actual_joints_position"] = Processor.process_get_actual_joints_position
        self._processMap["get_target_joints_position"] = Processor.process_get_target_joints_position
        self._processMap["get_actual_joints_speed"] = Processor.process_get_actual_joints_speed
        self._processMap["get_target_joints_speed"] = Processor.process_get_target_joints_speed
        self._processMap["get_actual_joints_acceleration"] = Processor.process_get_actual_joints_acceleration
        self._processMap["get_target_joints_acceleration"] = Processor.process_get_target_joints_acceleration
        self._processMap["get_actual_joints_torque"] = Processor.process_get_actual_joints_torque
        self._processMap["get_target_joints_torque"] = Processor.process_get_target_joints_torque
        self._processMap["stop_record_track"] = Processor.process_stop_record_track
        self._processMap["start_record_track"] = Processor.process_start_record_track
        self._processMap["collision_detect"] = Processor.process_collision_detect
        self._processMap["replay"] = Processor.process_replay
        self._processMap["set_load_data"] = Processor.process_set_load_data
        self._processMap["fc_start"] = Processor.process_fc_start
        self._processMap["fc_stop"] = Processor.process_fc_stop
        self._processMap["fc_config"] = Processor.process_fc_config
        self._processMap["fc_move"] = Processor.process_fc_move
        self._processMap["fc_guard_act"] = Processor.process_fc_guard_act
        self._processMap["fc_guard_deact"] = Processor.process_fc_guard_deact
        self._processMap["fc_force_set_value"] = Processor.process_fc_force_set_value
        self._processMap["fc_wait_pos"] = Processor.process_fc_wait_pos
        self._processMap["fc_wait_vel"] = Processor.process_fc_wait_vel
        self._processMap["fc_wait_ft"] = Processor.process_fc_wait_ft
        self._processMap["fc_wait_logic"] = Processor.process_fc_wait_logic
        self._processMap["fc_get_ft"] = Processor.process_fc_get_ft
        self._processMap["fc_mode_is_active"] = Processor.process_fc_mode_is_active
        self._processMap["start_realtime_mode"] = Processor.process_start_realtime_mode
        self._processMap["end_realtime_mode"] = Processor.process_end_realtime_mode
        self._processMap["realtime_data_enqueue"] = Processor.process_realtime_data_enqueue
        self._processMap["clear_realtime_data_queue"] = Processor.process_clear_realtime_data_queue
        self._processMap["get_realtime_data_queue_size"] = Processor.process_get_realtime_data_queue_size
        self._processMap["enable_speed_optimization"] = Processor.process_enable_speed_optimization
        self._processMap["disable_speed_optimization"] = Processor.process_disable_speed_optimization
        self._processMap["change_recipe"] = Processor.process_change_recipe
        self._processMap["set_system_value_bool"] = Processor.process_set_system_value_bool
        self._processMap["set_system_value_double"] = Processor.process_set_system_value_double
        self._processMap["set_system_value_str"] = Processor.process_set_system_value_str
        self._processMap["set_system_value_list"] = Processor.process_set_system_value_list
        self._processMap["get_system_value_bool"] = Processor.process_get_system_value_bool
        self._processMap["get_system_value_double"] = Processor.process_get_system_value_double
        self._processMap["get_system_value_str"] = Processor.process_get_system_value_str
        self._processMap["get_system_value_list"] = Processor.process_get_system_value_list
        self._processMap["trackEnqueue"] = Processor.process_trackEnqueue
        self._processMap["trackEnqueueOp"] = Processor.process_trackEnqueueOp
        self._processMap["trackClearQueue"] = Processor.process_trackClearQueue
        self._processMap["getQueueSize"] = Processor.process_getQueueSize
        self._processMap["trackJointMotion"] = Processor.process_trackJointMotion
        self._processMap["trackCartMotion"] = Processor.process_trackCartMotion
        self._processMap["rpc_heartbeat"] = Processor.process_rpc_heartbeat
        self._processMap["move_spiral"] = Processor.process_move_spiral
        self._processMap["enable_acc_optimization"] = Processor.process_enable_acc_optimization
        self._processMap["disable_acc_optimization"] = Processor.process_disable_acc_optimization
        self._processMap["set_baudrate_485"] = Processor.process_set_baudrate_485
        self._processMap["set_baudrate_can"] = Processor.process_set_baudrate_can
        self._processMap["set_analog_output_mode"] = Processor.process_set_analog_output_mode
        self._processMap["robotmoving"] = Processor.process_robotmoving
        self._processMap["modbus_write_multiple_coils"] = Processor.process_modbus_write_multiple_coils
        self._processMap["modbus_write_multiple_regs"] = Processor.process_modbus_write_multiple_regs
        self._processMap["get_current_project"] = Processor.process_get_current_project
        self._processMap["get_files_list"] = Processor.process_get_files_list
        self._processMap["getRobotStatus"] = Processor.process_getRobotStatus
        self._processMap["getRobotIOStatus"] = Processor.process_getRobotIOStatus
        self._processMap["get_tcp_pose_coord"] = Processor.process_get_tcp_pose_coord
        self._processMap["get_tcp_force_tool"] = Processor.process_get_tcp_force_tool
        self._processMap["restart"] = Processor.process_restart
        self._processMap["set_servo_config"] = Processor.process_set_servo_config
        self._processMap["apply_servo_config"] = Processor.process_apply_servo_config
        self._processMap["get_motor_pole_pair_number"] = Processor.process_get_motor_pole_pair_number
        self._processMap["get_motor_stator_slots"] = Processor.process_get_motor_stator_slots
        self._processMap["get_axis_ratio"] = Processor.process_get_axis_ratio
        self._processMap["collision_detection_reset"] = Processor.process_collision_detection_reset
        self._processMap["set_servo_file_params"] = Processor.process_set_servo_file_params
        self._processMap["combine_motion_config"] = Processor.process_combine_motion_config
        self._processMap["set_eaxis_param"] = Processor.process_set_eaxis_param
        self._processMap["add_eaxis_scheme"] = Processor.process_add_eaxis_scheme
        self._processMap["delete_eaxis_scheme"] = Processor.process_delete_eaxis_scheme
        self._processMap["enable_eaxis_scheme"] = Processor.process_enable_eaxis_scheme
        self._processMap["disable_eaxis_scheme"] = Processor.process_disable_eaxis_scheme
        self._processMap["set_eaxiss_scheme_param"] = Processor.process_set_eaxiss_scheme_param
        self._processMap["move_jog"] = Processor.process_move_jog
        self._processMap["stop_manual_move"] = Processor.process_stop_manual_move
        self._processMap["get_robot_version"] = Processor.process_get_robot_version
        self._processMap["set_teach_pendant"] = Processor.process_set_teach_pendant
        self._processMap["get_teach_speed"] = Processor.process_get_teach_speed
        self._processMap["get_global_speed"] = Processor.process_get_global_speed
        self._processMap["set_teach_speed"] = Processor.process_set_teach_speed
        self._processMap["enable_combine_motion"] = Processor.process_enable_combine_motion
        self._processMap["disable_combine_motion"] = Processor.process_disable_combine_motion
        self._processMap["enable_singularity_control"] = Processor.process_enable_singularity_control
        self._processMap["disable_singularity_control"] = Processor.process_disable_singularity_control
        self._processMap["enable_vibration_control"] = Processor.process_enable_vibration_control
        self._processMap["disable_vibration_control"] = Processor.process_disable_vibration_control
        self._processMap["move_eaxis"] = Processor.process_move_eaxis
        self._processMap["movej2_eaxis"] = Processor.process_movej2_eaxis
        self._processMap["movej2_pose_eaxis"] = Processor.process_movej2_pose_eaxis
        self._processMap["movel_eaxis"] = Processor.process_movel_eaxis
        self._processMap["movec_eaxis"] = Processor.process_movec_eaxis
        self._processMap["move_circle_eaxis"] = Processor.process_move_circle_eaxis
        self._processMap["reach_check"] = Processor.process_reach_check
        self._processMap["move_jog_eaxis"] = Processor.process_move_jog_eaxis
        self._processMap["get_eaxis_info"] = Processor.process_get_eaxis_info
        self._processMap["set_hand_teach_parameter"] = Processor.process_set_hand_teach_parameter
        self._processMap["set_pendant_type"] = Processor.process_set_pendant_type
        self._processMap["set_blend_ahead"] = Processor.process_set_blend_ahead
        self._processMap["switch_mode"] = Processor.process_switch_mode
        self._processMap["read_encoder_count"] = Processor.process_read_encoder_count
        self._processMap["set_kinematic_calibration_params"] = Processor.process_set_kinematic_calibration_params
        self._processMap["get_pos_bias"] = Processor.process_get_pos_bias
        self._processMap["get_system_value_lists"] = Processor.process_get_system_value_lists
        self._processMap["get_origin_DH"] = Processor.process_get_origin_DH
        self._processMap["get_calib_DH"] = Processor.process_get_calib_DH
        self._processMap["get_robot_type"] = Processor.process_get_robot_type
        self._processMap["get_ext_torque"] = Processor.process_get_ext_torque
        self._processMap["set_dynamic_calibration_params"] = Processor.process_set_dynamic_calibration_params
        self._processMap["get_dynamic_calibration_params"] = Processor.process_get_dynamic_calibration_params
        self._processMap["upload_robot_param_to_toolboard"] = Processor.process_upload_robot_param_to_toolboard
        self._processMap["set_kinematic_calibration_info"] = Processor.process_set_kinematic_calibration_info
        self._processMap["set_dynamic_calibration_info"] = Processor.process_set_dynamic_calibration_info
        self._processMap["set_vibration_calibration_info"] = Processor.process_set_vibration_calibration_info
        self._processMap["get_axis_motor_rated_current"] = Processor.process_get_axis_motor_rated_current
        self._processMap["get_axis_motor_kt"] = Processor.process_get_axis_motor_kt
        self._processMap["abort"] = Processor.process_abort
        self._processMap["get_vibration_calibration_params"] = Processor.process_get_vibration_calibration_params
        self._processMap["save_kinematic_calibration_params"] = Processor.process_save_kinematic_calibration_params
        self._processMap["save_dynamic_calibration_params"] = Processor.process_save_dynamic_calibration_params
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_power_on(self, seqid, iprot, oprot):
        args = power_on_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = power_on_result()
        try:
            result.success = self._handler.power_on(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("power_on", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_power_off(self, seqid, iprot, oprot):
        args = power_off_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = power_off_result()
        try:
            result.success = self._handler.power_off(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("power_off", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable(self, seqid, iprot, oprot):
        args = enable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_result()
        try:
            result.success = self._handler.enable(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable(self, seqid, iprot, oprot):
        args = disable_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_result()
        try:
            result.success = self._handler.disable(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shutdown(self, seqid, iprot, oprot):
        args = shutdown_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = shutdown_result()
        try:
            result.success = self._handler.shutdown(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("shutdown", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop(self, seqid, iprot, oprot):
        args = stop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_result()
        try:
            result.success = self._handler.stop(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_pause(self, seqid, iprot, oprot):
        args = pause_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = pause_result()
        try:
            result.success = self._handler.pause(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("pause", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resume(self, seqid, iprot, oprot):
        args = resume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resume_result()
        try:
            result.success = self._handler.resume(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("resume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_run_program(self, seqid, iprot, oprot):
        args = run_program_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = run_program_result()
        try:
            result.success = self._handler.run_program(args.name, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("run_program", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_tool_data(self, seqid, iprot, oprot):
        args = set_tool_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_tool_data_result()
        try:
            result.success = self._handler.set_tool_data(args.name, args.tool_offset, args.payload, args.inertia_tensor)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_tool_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tool_load(self, seqid, iprot, oprot):
        args = get_tool_load_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tool_load_result()
        try:
            result.success = self._handler.get_tool_load()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tool_load", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_offset(self, seqid, iprot, oprot):
        args = get_tcp_offset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_offset_result()
        try:
            result.success = self._handler.get_tcp_offset()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_offset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_wobj(self, seqid, iprot, oprot):
        args = set_wobj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_wobj_result()
        try:
            result.success = self._handler.set_wobj(args.name, args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_wobj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_wobj_offset(self, seqid, iprot, oprot):
        args = set_wobj_offset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_wobj_offset_result()
        try:
            result.success = self._handler.set_wobj_offset(args.wobj, args.active)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_wobj_offset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_wobj(self, seqid, iprot, oprot):
        args = get_wobj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_wobj_result()
        try:
            result.success = self._handler.get_wobj()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_wobj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cal_fkine(self, seqid, iprot, oprot):
        args = cal_fkine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cal_fkine_result()
        try:
            result.success = self._handler.cal_fkine(args.joints_position, args.tool, args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cal_fkine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cal_ikine(self, seqid, iprot, oprot):
        args = cal_ikine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cal_ikine_result()
        try:
            result.success = self._handler.cal_ikine(args.p, args.q_near, args.tool, args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cal_ikine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_digital_output_mode(self, seqid, iprot, oprot):
        args = set_digital_output_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_digital_output_mode_result()
        try:
            result.success = self._handler.set_digital_output_mode(args.num, args.type, args.freq, args.duty_cycle)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_digital_output_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_standard_digital_out(self, seqid, iprot, oprot):
        args = set_standard_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_standard_digital_out_result()
        try:
            result.success = self._handler.set_standard_digital_out(args.num, args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_standard_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_tool_digital_out(self, seqid, iprot, oprot):
        args = set_tool_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_tool_digital_out_result()
        try:
            result.success = self._handler.set_tool_digital_out(args.num, args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_tool_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_standard_digital_in(self, seqid, iprot, oprot):
        args = get_standard_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_standard_digital_in_result()
        try:
            result.success = self._handler.get_standard_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_standard_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_standard_digital_out(self, seqid, iprot, oprot):
        args = get_standard_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_standard_digital_out_result()
        try:
            result.success = self._handler.get_standard_digital_out(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_standard_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tool_digital_in(self, seqid, iprot, oprot):
        args = get_tool_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tool_digital_in_result()
        try:
            result.success = self._handler.get_tool_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tool_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tool_digital_out(self, seqid, iprot, oprot):
        args = get_tool_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tool_digital_out_result()
        try:
            result.success = self._handler.get_tool_digital_out(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tool_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_config_digital_in(self, seqid, iprot, oprot):
        args = get_config_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_config_digital_in_result()
        try:
            result.success = self._handler.get_config_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_config_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_standard_analog_voltage_in(self, seqid, iprot, oprot):
        args = get_standard_analog_voltage_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_standard_analog_voltage_in_result()
        try:
            result.success = self._handler.get_standard_analog_voltage_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_standard_analog_voltage_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tool_analog_voltage_in(self, seqid, iprot, oprot):
        args = get_tool_analog_voltage_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tool_analog_voltage_in_result()
        try:
            result.success = self._handler.get_tool_analog_voltage_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tool_analog_voltage_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_standard_analog_current_in(self, seqid, iprot, oprot):
        args = get_standard_analog_current_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_standard_analog_current_in_result()
        try:
            result.success = self._handler.get_standard_analog_current_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_standard_analog_current_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_standard_analog_voltage_out(self, seqid, iprot, oprot):
        args = set_standard_analog_voltage_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_standard_analog_voltage_out_result()
        try:
            result.success = self._handler.set_standard_analog_voltage_out(args.num, args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_standard_analog_voltage_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_standard_analog_current_out(self, seqid, iprot, oprot):
        args = set_standard_analog_current_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_standard_analog_current_out_result()
        try:
            result.success = self._handler.set_standard_analog_current_out(args.num, args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_standard_analog_current_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_data_485(self, seqid, iprot, oprot):
        args = read_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_data_485_result()
        try:
            result.success = self._handler.read_data_485()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_485(self, seqid, iprot, oprot):
        args = read_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_485_result()
        try:
            result.success = self._handler.read_raw_data_485(args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_485_ht(self, seqid, iprot, oprot):
        args = read_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_485_ht_result()
        try:
            result.success = self._handler.read_raw_data_485_ht(args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_485_h(self, seqid, iprot, oprot):
        args = read_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_485_h_result()
        try:
            result.success = self._handler.read_raw_data_485_h(args.head, args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_data_485(self, seqid, iprot, oprot):
        args = write_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_data_485_result()
        try:
            result.success = self._handler.write_data_485(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_485(self, seqid, iprot, oprot):
        args = write_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_485_result()
        try:
            result.success = self._handler.write_raw_data_485(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_485_h(self, seqid, iprot, oprot):
        args = write_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_485_h_result()
        try:
            result.success = self._handler.write_raw_data_485_h(args.data, args.head)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_485_ht(self, seqid, iprot, oprot):
        args = write_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_485_ht_result()
        try:
            result.success = self._handler.write_raw_data_485_ht(args.data, args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_read_data_485(self, seqid, iprot, oprot):
        args = tool_read_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_read_data_485_result()
        try:
            result.success = self._handler.tool_read_data_485()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_read_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_read_raw_data_485(self, seqid, iprot, oprot):
        args = tool_read_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_read_raw_data_485_result()
        try:
            result.success = self._handler.tool_read_raw_data_485(args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_read_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_read_raw_data_485_h(self, seqid, iprot, oprot):
        args = tool_read_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_read_raw_data_485_h_result()
        try:
            result.success = self._handler.tool_read_raw_data_485_h(args.head, args.len)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_read_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_read_raw_data_485_ht(self, seqid, iprot, oprot):
        args = tool_read_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_read_raw_data_485_ht_result()
        try:
            result.success = self._handler.tool_read_raw_data_485_ht(args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_read_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_write_data_485(self, seqid, iprot, oprot):
        args = tool_write_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_write_data_485_result()
        try:
            result.success = self._handler.tool_write_data_485(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_write_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_write_raw_data_485(self, seqid, iprot, oprot):
        args = tool_write_raw_data_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_write_raw_data_485_result()
        try:
            result.success = self._handler.tool_write_raw_data_485(args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_write_raw_data_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_write_raw_data_485_h(self, seqid, iprot, oprot):
        args = tool_write_raw_data_485_h_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_write_raw_data_485_h_result()
        try:
            result.success = self._handler.tool_write_raw_data_485_h(args.data, args.head)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_write_raw_data_485_h", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tool_write_raw_data_485_ht(self, seqid, iprot, oprot):
        args = tool_write_raw_data_485_ht_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tool_write_raw_data_485_ht_result()
        try:
            result.success = self._handler.tool_write_raw_data_485_ht(args.data, args.head, args.tail)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tool_write_raw_data_485_ht", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_data_can(self, seqid, iprot, oprot):
        args = read_data_can_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_data_can_result()
        try:
            result.success = self._handler.read_data_can()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_data_can", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_raw_data_can(self, seqid, iprot, oprot):
        args = read_raw_data_can_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_raw_data_can_result()
        try:
            result.success = self._handler.read_raw_data_can()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_raw_data_can", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_data_can(self, seqid, iprot, oprot):
        args = write_data_can_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_data_can_result()
        try:
            result.success = self._handler.write_data_can(args.id, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_data_can", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_raw_data_can(self, seqid, iprot, oprot):
        args = write_raw_data_can_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_raw_data_can_result()
        try:
            result.success = self._handler.write_raw_data_can(args.id, args.data)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_raw_data_can", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function_digital_in(self, seqid, iprot, oprot):
        args = get_function_digital_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_digital_in_result()
        try:
            result.success = self._handler.get_function_digital_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function_digital_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function_digital_out(self, seqid, iprot, oprot):
        args = get_function_digital_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_digital_out_result()
        try:
            result.success = self._handler.get_function_digital_out(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function_digital_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_bool_reg(self, seqid, iprot, oprot):
        args = read_bool_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_bool_reg_result()
        try:
            result.success = self._handler.read_bool_reg(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_bool_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_word_reg(self, seqid, iprot, oprot):
        args = read_word_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_word_reg_result()
        try:
            result.success = self._handler.read_word_reg(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_word_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_float_reg(self, seqid, iprot, oprot):
        args = read_float_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_float_reg_result()
        try:
            result.success = self._handler.read_float_reg(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_float_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_bool_reg(self, seqid, iprot, oprot):
        args = write_bool_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_bool_reg_result()
        try:
            result.success = self._handler.write_bool_reg(args.num, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_bool_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_word_reg(self, seqid, iprot, oprot):
        args = write_word_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_word_reg_result()
        try:
            result.success = self._handler.write_word_reg(args.num, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_word_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write_float_reg(self, seqid, iprot, oprot):
        args = write_float_reg_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_float_reg_result()
        try:
            result.success = self._handler.write_float_reg(args.num, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write_float_reg", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function_reg_in(self, seqid, iprot, oprot):
        args = get_function_reg_in_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_reg_in_result()
        try:
            result.success = self._handler.get_function_reg_in(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function_reg_in", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function_reg_out(self, seqid, iprot, oprot):
        args = get_function_reg_out_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_reg_out_result()
        try:
            result.success = self._handler.get_function_reg_out(args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function_reg_out", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej(self, seqid, iprot, oprot):
        args = movej_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej_result()
        try:
            result.success = self._handler.movej(args.joints_list, args.v, args.a, args.r, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej_pose(self, seqid, iprot, oprot):
        args = movej_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej_pose_result()
        try:
            result.success = self._handler.movej_pose(args.p, args.v, args.a, args.r, args.q_near, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej2(self, seqid, iprot, oprot):
        args = movej2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej2_result()
        try:
            result.success = self._handler.movej2(args.joints_list, args.v, args.a, args.r, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej_pose2(self, seqid, iprot, oprot):
        args = movej_pose2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej_pose2_result()
        try:
            result.success = self._handler.movej_pose2(args.p, args.v, args.a, args.r, args.q_near, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej_pose2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movel(self, seqid, iprot, oprot):
        args = movel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movel_result()
        try:
            result.success = self._handler.movel(args.p, args.v, args.a, args.r, args.q_near, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movec(self, seqid, iprot, oprot):
        args = movec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movec_result()
        try:
            result.success = self._handler.movec(args.p1, args.p2, args.v, args.a, args.r, args.mode, args.q_near, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_move_circle(self, seqid, iprot, oprot):
        args = move_circle_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = move_circle_result()
        try:
            result.success = self._handler.move_circle(args.p1, args.p2, args.v, args.a, args.r, args.mode, args.q_near, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("move_circle", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tcp_move(self, seqid, iprot, oprot):
        args = tcp_move_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tcp_move_result()
        try:
            result.success = self._handler.tcp_move(args.pose_offset, args.v, args.a, args.r, args.tool, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tcp_move", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tcp_move_2p(self, seqid, iprot, oprot):
        args = tcp_move_2p_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tcp_move_2p_result()
        try:
            result.success = self._handler.tcp_move_2p(args.p1, args.p2, args.v, args.a, args.r, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tcp_move_2p", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wobj_move(self, seqid, iprot, oprot):
        args = wobj_move_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wobj_move_result()
        try:
            result.success = self._handler.wobj_move(args.pose_offset, args.v, args.a, args.r, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wobj_move", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_wobj_move_2p(self, seqid, iprot, oprot):
        args = wobj_move_2p_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = wobj_move_2p_result()
        try:
            result.success = self._handler.wobj_move_2p(args.p1, args.p2, args.v, args.a, args.r, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("wobj_move_2p", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spline(self, seqid, iprot, oprot):
        args = spline_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spline_result()
        try:
            result.success = self._handler.spline(args.pose_list, args.v, args.a, args.tool, args.wobj, args.block, args.op, args.r, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spline", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_spline_op(self, seqid, iprot, oprot):
        args = spline_op_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = spline_op_result()
        try:
            result.success = self._handler.spline_op(args.pose_list, args.v, args.a, args.tool, args.wobj, args.block, args.op, args.r, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("spline_op", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speedj(self, seqid, iprot, oprot):
        args = speedj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speedj_result()
        try:
            result.success = self._handler.speedj(args.joints_list, args.a, args.time, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speedj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speedl(self, seqid, iprot, oprot):
        args = speedl_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speedl_result()
        try:
            result.success = self._handler.speedl(args.pose_list, args.a, args.time, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speedl", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speed_stop(self, seqid, iprot, oprot):
        args = speed_stop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speed_stop_result()
        try:
            result.success = self._handler.speed_stop(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speed_stop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_servoj(self, seqid, iprot, oprot):
        args = servoj_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = servoj_result()
        try:
            result.success = self._handler.servoj(args.joints_list, args.v, args.a, args.block, args.kp, args.kd, args.smooth_vel, args.smooth_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("servoj", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_servoj_pose(self, seqid, iprot, oprot):
        args = servoj_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = servoj_pose_result()
        try:
            result.success = self._handler.servoj_pose(args.pose_list, args.v, args.a, args.q_near, args.tool, args.wobj, args.block, args.kp, args.kd, args.smooth_vel, args.smooth_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("servoj_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_servo_tcp(self, seqid, iprot, oprot):
        args = servo_tcp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = servo_tcp_result()
        try:
            result.success = self._handler.servo_tcp(args.pose_offset, args.v, args.a, args.tool, args.block, args.kp, args.kd, args.smooth_vel, args.smooth_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("servo_tcp", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_servol(self, seqid, iprot, oprot):
        args = servol_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = servol_result()
        try:
            result.success = self._handler.servol(args.pose_list, args.v, args.a, args.q_near, args.tool, args.wobj, args.block, args.kp, args.kd, args.smooth_vel, args.smooth_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("servol", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_teach_mode(self, seqid, iprot, oprot):
        args = teach_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = teach_mode_result()
        try:
            result.success = self._handler.teach_mode(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("teach_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_end_teach_mode(self, seqid, iprot, oprot):
        args = end_teach_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = end_teach_mode_result()
        try:
            result.success = self._handler.end_teach_mode(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("end_teach_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_add_signal(self, seqid, iprot, oprot):
        args = modbus_add_signal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_add_signal_result()
        try:
            result.success = self._handler.modbus_add_signal(args.ip, args.slave_number, args.signal_address, args.signal_type, args.signal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_add_signal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_delete_signal(self, seqid, iprot, oprot):
        args = modbus_delete_signal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_delete_signal_result()
        try:
            result.success = self._handler.modbus_delete_signal(args.signal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_delete_signal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_read(self, seqid, iprot, oprot):
        args = modbus_read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_read_result()
        try:
            result.success = self._handler.modbus_read(args.signal_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_write(self, seqid, iprot, oprot):
        args = modbus_write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_write_result()
        try:
            result.success = self._handler.modbus_write(args.signal_name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_set_frequency(self, seqid, iprot, oprot):
        args = modbus_set_frequency_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_set_frequency_result()
        try:
            self._handler.modbus_set_frequency(args.signal_name, args.frequence)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_set_frequency", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_last_error(self, seqid, iprot, oprot):
        args = get_last_error_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_last_error_result()
        try:
            result.success = self._handler.get_last_error()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_last_error", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_noneblock_taskstate(self, seqid, iprot, oprot):
        args = get_noneblock_taskstate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_noneblock_taskstate_result()
        try:
            result.success = self._handler.get_noneblock_taskstate(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_noneblock_taskstate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_log_info(self, seqid, iprot, oprot):
        args = log_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = log_info_result()
        try:
            self._handler.log_info(args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("log_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_log_error(self, seqid, iprot, oprot):
        args = log_error_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = log_error_result()
        try:
            self._handler.log_error(args.message)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("log_error", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_simulation(self, seqid, iprot, oprot):
        args = simulation_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = simulation_result()
        try:
            result.success = self._handler.simulation(args.sim, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("simulation", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_speed(self, seqid, iprot, oprot):
        args = speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = speed_result()
        try:
            result.success = self._handler.speed(args.val)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_robot_state(self, seqid, iprot, oprot):
        args = get_robot_state_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_robot_state_result()
        try:
            result.success = self._handler.get_robot_state()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_robot_state", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flange_pose(self, seqid, iprot, oprot):
        args = get_flange_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flange_pose_result()
        try:
            result.success = self._handler.get_flange_pose()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_flange_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flange_speed(self, seqid, iprot, oprot):
        args = get_flange_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flange_speed_result()
        try:
            result.success = self._handler.get_flange_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_flange_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flange_acceleration(self, seqid, iprot, oprot):
        args = get_flange_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flange_acceleration_result()
        try:
            result.success = self._handler.get_flange_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_flange_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_pose(self, seqid, iprot, oprot):
        args = get_tcp_pose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_pose_result()
        try:
            result.success = self._handler.get_tcp_pose()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_pose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_speed(self, seqid, iprot, oprot):
        args = get_tcp_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_speed_result()
        try:
            result.success = self._handler.get_tcp_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_acceleration(self, seqid, iprot, oprot):
        args = get_tcp_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_acceleration_result()
        try:
            result.success = self._handler.get_tcp_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_force(self, seqid, iprot, oprot):
        args = get_tcp_force_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_force_result()
        try:
            result.success = self._handler.get_tcp_force()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_force", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_position(self, seqid, iprot, oprot):
        args = get_actual_joints_position_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_position_result()
        try:
            result.success = self._handler.get_actual_joints_position()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_position", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_position(self, seqid, iprot, oprot):
        args = get_target_joints_position_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_position_result()
        try:
            result.success = self._handler.get_target_joints_position()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_position", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_speed(self, seqid, iprot, oprot):
        args = get_actual_joints_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_speed_result()
        try:
            result.success = self._handler.get_actual_joints_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_speed(self, seqid, iprot, oprot):
        args = get_target_joints_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_speed_result()
        try:
            result.success = self._handler.get_target_joints_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_acceleration(self, seqid, iprot, oprot):
        args = get_actual_joints_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_acceleration_result()
        try:
            result.success = self._handler.get_actual_joints_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_acceleration(self, seqid, iprot, oprot):
        args = get_target_joints_acceleration_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_acceleration_result()
        try:
            result.success = self._handler.get_target_joints_acceleration()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_acceleration", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_actual_joints_torque(self, seqid, iprot, oprot):
        args = get_actual_joints_torque_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_actual_joints_torque_result()
        try:
            result.success = self._handler.get_actual_joints_torque()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_actual_joints_torque", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_target_joints_torque(self, seqid, iprot, oprot):
        args = get_target_joints_torque_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_target_joints_torque_result()
        try:
            result.success = self._handler.get_target_joints_torque()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_target_joints_torque", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_record_track(self, seqid, iprot, oprot):
        args = stop_record_track_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_record_track_result()
        try:
            result.success = self._handler.stop_record_track()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_record_track", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_record_track(self, seqid, iprot, oprot):
        args = start_record_track_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_record_track_result()
        try:
            result.success = self._handler.start_record_track(args.name, args.mode, args.tool, args.wobj, args.interval)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_record_track", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_collision_detect(self, seqid, iprot, oprot):
        args = collision_detect_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = collision_detect_result()
        try:
            result.success = self._handler.collision_detect(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("collision_detect", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_replay(self, seqid, iprot, oprot):
        args = replay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = replay_result()
        try:
            result.success = self._handler.replay(args.name, args.value, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("replay", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_load_data(self, seqid, iprot, oprot):
        args = set_load_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_load_data_result()
        try:
            result.success = self._handler.set_load_data(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_load_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_start(self, seqid, iprot, oprot):
        args = fc_start_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_start_result()
        try:
            result.success = self._handler.fc_start()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_start", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_stop(self, seqid, iprot, oprot):
        args = fc_stop_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_stop_result()
        try:
            result.success = self._handler.fc_stop()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_stop", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_config(self, seqid, iprot, oprot):
        args = fc_config_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_config_result()
        try:
            result.success = self._handler.fc_config(args.direction, args.ref_ft, args.damp, args.max_vel, args.number_list, args.tool, args.wobj, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_config", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_move(self, seqid, iprot, oprot):
        args = fc_move_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_move_result()
        try:
            result.success = self._handler.fc_move(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_move", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_guard_act(self, seqid, iprot, oprot):
        args = fc_guard_act_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_guard_act_result()
        try:
            result.success = self._handler.fc_guard_act(args.direction, args.ref_ft, args.tool, args.wobj, args.type, args.force_property)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_guard_act", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_guard_deact(self, seqid, iprot, oprot):
        args = fc_guard_deact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_guard_deact_result()
        try:
            result.success = self._handler.fc_guard_deact()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_guard_deact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_force_set_value(self, seqid, iprot, oprot):
        args = fc_force_set_value_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_force_set_value_result()
        try:
            result.success = self._handler.fc_force_set_value(args.direction, args.ref_ft)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_force_set_value", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_pos(self, seqid, iprot, oprot):
        args = fc_wait_pos_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_pos_result()
        try:
            result.success = self._handler.fc_wait_pos(args.middle, args.range, args.absolute, args.duration, args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_pos", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_vel(self, seqid, iprot, oprot):
        args = fc_wait_vel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_vel_result()
        try:
            result.success = self._handler.fc_wait_vel(args.middle, args.range, args.absolute, args.duration, args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_vel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_ft(self, seqid, iprot, oprot):
        args = fc_wait_ft_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_ft_result()
        try:
            result.success = self._handler.fc_wait_ft(args.middle, args.range, args.absolute, args.duration, args.timeout)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_ft", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_wait_logic(self, seqid, iprot, oprot):
        args = fc_wait_logic_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_wait_logic_result()
        try:
            result.success = self._handler.fc_wait_logic(args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_wait_logic", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_get_ft(self, seqid, iprot, oprot):
        args = fc_get_ft_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_get_ft_result()
        try:
            result.success = self._handler.fc_get_ft()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_get_ft", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fc_mode_is_active(self, seqid, iprot, oprot):
        args = fc_mode_is_active_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fc_mode_is_active_result()
        try:
            result.success = self._handler.fc_mode_is_active()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fc_mode_is_active", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_realtime_mode(self, seqid, iprot, oprot):
        args = start_realtime_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_realtime_mode_result()
        try:
            result.success = self._handler.start_realtime_mode(args.mode, args.fileter_bandwidth, args.com_lost_time)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("start_realtime_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_end_realtime_mode(self, seqid, iprot, oprot):
        args = end_realtime_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = end_realtime_mode_result()
        try:
            result.success = self._handler.end_realtime_mode()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("end_realtime_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_realtime_data_enqueue(self, seqid, iprot, oprot):
        args = realtime_data_enqueue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = realtime_data_enqueue_result()
        try:
            result.success = self._handler.realtime_data_enqueue(args.realtime_data, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("realtime_data_enqueue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_clear_realtime_data_queue(self, seqid, iprot, oprot):
        args = clear_realtime_data_queue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = clear_realtime_data_queue_result()
        try:
            result.success = self._handler.clear_realtime_data_queue()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("clear_realtime_data_queue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_realtime_data_queue_size(self, seqid, iprot, oprot):
        args = get_realtime_data_queue_size_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_realtime_data_queue_size_result()
        try:
            result.success = self._handler.get_realtime_data_queue_size()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_realtime_data_queue_size", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_speed_optimization(self, seqid, iprot, oprot):
        args = enable_speed_optimization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_speed_optimization_result()
        try:
            result.success = self._handler.enable_speed_optimization()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_speed_optimization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_speed_optimization(self, seqid, iprot, oprot):
        args = disable_speed_optimization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_speed_optimization_result()
        try:
            result.success = self._handler.disable_speed_optimization()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_speed_optimization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_change_recipe(self, seqid, iprot, oprot):
        args = change_recipe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = change_recipe_result()
        try:
            self._handler.change_recipe()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("change_recipe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_system_value_bool(self, seqid, iprot, oprot):
        args = set_system_value_bool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_system_value_bool_result()
        try:
            result.success = self._handler.set_system_value_bool(args.name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_system_value_bool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_system_value_double(self, seqid, iprot, oprot):
        args = set_system_value_double_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_system_value_double_result()
        try:
            result.success = self._handler.set_system_value_double(args.name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_system_value_double", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_system_value_str(self, seqid, iprot, oprot):
        args = set_system_value_str_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_system_value_str_result()
        try:
            result.success = self._handler.set_system_value_str(args.name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_system_value_str", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_system_value_list(self, seqid, iprot, oprot):
        args = set_system_value_list_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_system_value_list_result()
        try:
            result.success = self._handler.set_system_value_list(args.name, args.value)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_system_value_list", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_system_value_bool(self, seqid, iprot, oprot):
        args = get_system_value_bool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_system_value_bool_result()
        try:
            result.success = self._handler.get_system_value_bool(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_system_value_bool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_system_value_double(self, seqid, iprot, oprot):
        args = get_system_value_double_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_system_value_double_result()
        try:
            result.success = self._handler.get_system_value_double(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_system_value_double", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_system_value_str(self, seqid, iprot, oprot):
        args = get_system_value_str_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_system_value_str_result()
        try:
            result.success = self._handler.get_system_value_str(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_system_value_str", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_system_value_list(self, seqid, iprot, oprot):
        args = get_system_value_list_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_system_value_list_result()
        try:
            result.success = self._handler.get_system_value_list(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_system_value_list", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_trackEnqueue(self, seqid, iprot, oprot):
        args = trackEnqueue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trackEnqueue_result()
        try:
            result.success = self._handler.trackEnqueue(args.track, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("trackEnqueue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_trackEnqueueOp(self, seqid, iprot, oprot):
        args = trackEnqueueOp_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trackEnqueueOp_result()
        try:
            result.success = self._handler.trackEnqueueOp(args.track, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("trackEnqueueOp", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_trackClearQueue(self, seqid, iprot, oprot):
        args = trackClearQueue_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trackClearQueue_result()
        try:
            result.success = self._handler.trackClearQueue()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("trackClearQueue", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getQueueSize(self, seqid, iprot, oprot):
        args = getQueueSize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getQueueSize_result()
        try:
            result.success = self._handler.getQueueSize()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getQueueSize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_trackJointMotion(self, seqid, iprot, oprot):
        args = trackJointMotion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trackJointMotion_result()
        try:
            result.success = self._handler.trackJointMotion(args.speed, args.acc, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("trackJointMotion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_trackCartMotion(self, seqid, iprot, oprot):
        args = trackCartMotion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = trackCartMotion_result()
        try:
            result.success = self._handler.trackCartMotion(args.speed, args.acc, args.block, args.tool, args.wobj, args.radius)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("trackCartMotion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rpc_heartbeat(self, seqid, iprot, oprot):
        args = rpc_heartbeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rpc_heartbeat_result()
        try:
            self._handler.rpc_heartbeat(args.time)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rpc_heartbeat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_move_spiral(self, seqid, iprot, oprot):
        args = move_spiral_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = move_spiral_result()
        try:
            result.success = self._handler.move_spiral(args.p1, args.p2, args.rev, args.len, args.r, args.mode, args.v, args.a, args.q_near, args.tool, args.wobj, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("move_spiral", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_acc_optimization(self, seqid, iprot, oprot):
        args = enable_acc_optimization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_acc_optimization_result()
        try:
            result.success = self._handler.enable_acc_optimization()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_acc_optimization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_acc_optimization(self, seqid, iprot, oprot):
        args = disable_acc_optimization_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_acc_optimization_result()
        try:
            result.success = self._handler.disable_acc_optimization()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_acc_optimization", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_baudrate_485(self, seqid, iprot, oprot):
        args = set_baudrate_485_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_baudrate_485_result()
        try:
            result.success = self._handler.set_baudrate_485(args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_baudrate_485", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_baudrate_can(self, seqid, iprot, oprot):
        args = set_baudrate_can_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_baudrate_can_result()
        try:
            result.success = self._handler.set_baudrate_can(args.value, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_baudrate_can", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_analog_output_mode(self, seqid, iprot, oprot):
        args = set_analog_output_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_analog_output_mode_result()
        try:
            result.success = self._handler.set_analog_output_mode(args.num, args.mode, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_analog_output_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_robotmoving(self, seqid, iprot, oprot):
        args = robotmoving_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = robotmoving_result()
        try:
            result.success = self._handler.robotmoving()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("robotmoving", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_write_multiple_coils(self, seqid, iprot, oprot):
        args = modbus_write_multiple_coils_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_write_multiple_coils_result()
        try:
            result.success = self._handler.modbus_write_multiple_coils(args.slave_num, args.name, args.len, args.byte_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_write_multiple_coils", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_modbus_write_multiple_regs(self, seqid, iprot, oprot):
        args = modbus_write_multiple_regs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = modbus_write_multiple_regs_result()
        try:
            result.success = self._handler.modbus_write_multiple_regs(args.slave_num, args.name, args.len, args.word_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("modbus_write_multiple_regs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_current_project(self, seqid, iprot, oprot):
        args = get_current_project_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_current_project_result()
        try:
            result.success = self._handler.get_current_project()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_current_project", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_files_list(self, seqid, iprot, oprot):
        args = get_files_list_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_files_list_result()
        try:
            result.success = self._handler.get_files_list(args.path)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_files_list", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRobotStatus(self, seqid, iprot, oprot):
        args = getRobotStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRobotStatus_result()
        try:
            result.success = self._handler.getRobotStatus()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRobotStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getRobotIOStatus(self, seqid, iprot, oprot):
        args = getRobotIOStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getRobotIOStatus_result()
        try:
            result.success = self._handler.getRobotIOStatus()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getRobotIOStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_pose_coord(self, seqid, iprot, oprot):
        args = get_tcp_pose_coord_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_pose_coord_result()
        try:
            result.success = self._handler.get_tcp_pose_coord(args.tool, args.wobj)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_pose_coord", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tcp_force_tool(self, seqid, iprot, oprot):
        args = get_tcp_force_tool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tcp_force_tool_result()
        try:
            result.success = self._handler.get_tcp_force_tool(args.tool)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tcp_force_tool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_restart(self, seqid, iprot, oprot):
        args = restart_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = restart_result()
        try:
            result.success = self._handler.restart(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("restart", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_servo_config(self, seqid, iprot, oprot):
        args = set_servo_config_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_servo_config_result()
        try:
            result.success = self._handler.set_servo_config(args.axis_num, args.id, args.value, args.qfmt, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_servo_config", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_apply_servo_config(self, seqid, iprot, oprot):
        args = apply_servo_config_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = apply_servo_config_result()
        try:
            result.success = self._handler.apply_servo_config(args.axis_num, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("apply_servo_config", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_motor_pole_pair_number(self, seqid, iprot, oprot):
        args = get_motor_pole_pair_number_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_motor_pole_pair_number_result()
        try:
            result.success = self._handler.get_motor_pole_pair_number()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_motor_pole_pair_number", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_motor_stator_slots(self, seqid, iprot, oprot):
        args = get_motor_stator_slots_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_motor_stator_slots_result()
        try:
            result.success = self._handler.get_motor_stator_slots()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_motor_stator_slots", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_axis_ratio(self, seqid, iprot, oprot):
        args = get_axis_ratio_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_axis_ratio_result()
        try:
            result.success = self._handler.get_axis_ratio()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_axis_ratio", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_collision_detection_reset(self, seqid, iprot, oprot):
        args = collision_detection_reset_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = collision_detection_reset_result()
        try:
            result.success = self._handler.collision_detection_reset()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("collision_detection_reset", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_servo_file_params(self, seqid, iprot, oprot):
        args = set_servo_file_params_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_servo_file_params_result()
        try:
            result.success = self._handler.set_servo_file_params(args.axis_num, args.id, args.name, args.value, args.qfmt)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_servo_file_params", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_combine_motion_config(self, seqid, iprot, oprot):
        args = combine_motion_config_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = combine_motion_config_result()
        try:
            result.success = self._handler.combine_motion_config(args.type, args.ref_plane, args.fq, args.amp, args.el_offset, args.az_offset, args.up_height, args.time, args.path_dwell, args.op_list)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("combine_motion_config", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_eaxis_param(self, seqid, iprot, oprot):
        args = set_eaxis_param_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_eaxis_param_result()
        try:
            result.success = self._handler.set_eaxis_param(args.num, args.param, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_eaxis_param", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_eaxis_scheme(self, seqid, iprot, oprot):
        args = add_eaxis_scheme_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_eaxis_scheme_result()
        try:
            result.success = self._handler.add_eaxis_scheme(args.num, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_eaxis_scheme", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_eaxis_scheme(self, seqid, iprot, oprot):
        args = delete_eaxis_scheme_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_eaxis_scheme_result()
        try:
            result.success = self._handler.delete_eaxis_scheme(args.num, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_eaxis_scheme", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_eaxis_scheme(self, seqid, iprot, oprot):
        args = enable_eaxis_scheme_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_eaxis_scheme_result()
        try:
            result.success = self._handler.enable_eaxis_scheme(args.scheme_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_eaxis_scheme", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_eaxis_scheme(self, seqid, iprot, oprot):
        args = disable_eaxis_scheme_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_eaxis_scheme_result()
        try:
            result.success = self._handler.disable_eaxis_scheme(args.scheme_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_eaxis_scheme", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_eaxiss_scheme_param(self, seqid, iprot, oprot):
        args = set_eaxiss_scheme_param_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_eaxiss_scheme_param_result()
        try:
            result.success = self._handler.set_eaxiss_scheme_param(args.num, args.param, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_eaxiss_scheme_param", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_move_jog(self, seqid, iprot, oprot):
        args = move_jog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = move_jog_result()
        try:
            result.success = self._handler.move_jog(args.param, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("move_jog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_manual_move(self, seqid, iprot, oprot):
        args = stop_manual_move_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_manual_move_result()
        try:
            result.success = self._handler.stop_manual_move(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("stop_manual_move", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_robot_version(self, seqid, iprot, oprot):
        args = get_robot_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_robot_version_result()
        try:
            result.success = self._handler.get_robot_version()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_robot_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_teach_pendant(self, seqid, iprot, oprot):
        args = set_teach_pendant_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_teach_pendant_result()
        try:
            result.success = self._handler.set_teach_pendant(args.enable)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_teach_pendant", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_teach_speed(self, seqid, iprot, oprot):
        args = get_teach_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_teach_speed_result()
        try:
            result.success = self._handler.get_teach_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_teach_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_global_speed(self, seqid, iprot, oprot):
        args = get_global_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_global_speed_result()
        try:
            result.success = self._handler.get_global_speed()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_global_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_teach_speed(self, seqid, iprot, oprot):
        args = set_teach_speed_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_teach_speed_result()
        try:
            result.success = self._handler.set_teach_speed(args.v)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_teach_speed", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_combine_motion(self, seqid, iprot, oprot):
        args = enable_combine_motion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_combine_motion_result()
        try:
            result.success = self._handler.enable_combine_motion()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_combine_motion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_combine_motion(self, seqid, iprot, oprot):
        args = disable_combine_motion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_combine_motion_result()
        try:
            result.success = self._handler.disable_combine_motion()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_combine_motion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_singularity_control(self, seqid, iprot, oprot):
        args = enable_singularity_control_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_singularity_control_result()
        try:
            result.success = self._handler.enable_singularity_control()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_singularity_control", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_singularity_control(self, seqid, iprot, oprot):
        args = disable_singularity_control_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_singularity_control_result()
        try:
            result.success = self._handler.disable_singularity_control()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_singularity_control", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_enable_vibration_control(self, seqid, iprot, oprot):
        args = enable_vibration_control_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = enable_vibration_control_result()
        try:
            result.success = self._handler.enable_vibration_control()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("enable_vibration_control", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_disable_vibration_control(self, seqid, iprot, oprot):
        args = disable_vibration_control_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = disable_vibration_control_result()
        try:
            result.success = self._handler.disable_vibration_control()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("disable_vibration_control", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_move_eaxis(self, seqid, iprot, oprot):
        args = move_eaxis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = move_eaxis_result()
        try:
            result.success = self._handler.move_eaxis(args.scheme_name, args.epose, args.v, args.block, args.op)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("move_eaxis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej2_eaxis(self, seqid, iprot, oprot):
        args = movej2_eaxis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej2_eaxis_result()
        try:
            result.success = self._handler.movej2_eaxis(args.joints_list, args.v, args.a, args.rad, args.scheme_name, args.epose, args.eaxis_v, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej2_eaxis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movej2_pose_eaxis(self, seqid, iprot, oprot):
        args = movej2_pose_eaxis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movej2_pose_eaxis_result()
        try:
            result.success = self._handler.movej2_pose_eaxis(args.p, args.v, args.a, args.rad, args.qnear, args.tool, args.wobj, args.scheme_name, args.epose, args.eaxis_v, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movej2_pose_eaxis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movel_eaxis(self, seqid, iprot, oprot):
        args = movel_eaxis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movel_eaxis_result()
        try:
            result.success = self._handler.movel_eaxis(args.p, args.v, args.a, args.rad, args.qnear, args.tool, args.wobj, args.scheme_name, args.epose, args.eaxis_v, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movel_eaxis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_movec_eaxis(self, seqid, iprot, oprot):
        args = movec_eaxis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = movec_eaxis_result()
        try:
            result.success = self._handler.movec_eaxis(args.p1, args.p2, args.v, args.a, args.rad, args.qnear, args.tool, args.wobj, args.scheme_name, args.epose, args.eaxis_v, args.block, args.op, args.def_acc, args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("movec_eaxis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_move_circle_eaxis(self, seqid, iprot, oprot):
        args = move_circle_eaxis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = move_circle_eaxis_result()
        try:
            result.success = self._handler.move_circle_eaxis(args.p1, args.p2, args.v, args.a, args.rad, args.mode, args.qnear, args.tool, args.wobj, args.scheme_name, args.epose, args.eaxis_v, args.block, args.op, args.def_acc)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("move_circle_eaxis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reach_check(self, seqid, iprot, oprot):
        args = reach_check_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reach_check_result()
        try:
            result.success = self._handler.reach_check(args.base, args.wobj, args.tool, args.ref_pos, args.check_points)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("reach_check", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_move_jog_eaxis(self, seqid, iprot, oprot):
        args = move_jog_eaxis_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = move_jog_eaxis_result()
        try:
            result.success = self._handler.move_jog_eaxis(args.name, args.direction, args.vel, args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("move_jog_eaxis", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_eaxis_info(self, seqid, iprot, oprot):
        args = get_eaxis_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_eaxis_info_result()
        try:
            result.success = self._handler.get_eaxis_info()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_eaxis_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_hand_teach_parameter(self, seqid, iprot, oprot):
        args = set_hand_teach_parameter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_hand_teach_parameter_result()
        try:
            result.success = self._handler.set_hand_teach_parameter(args.space, args.joint_scale, args.cart_scale, args.coord_type, args.direction)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_hand_teach_parameter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_pendant_type(self, seqid, iprot, oprot):
        args = set_pendant_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_pendant_type_result()
        try:
            result.success = self._handler.set_pendant_type(args.type)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_pendant_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_blend_ahead(self, seqid, iprot, oprot):
        args = set_blend_ahead_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_blend_ahead_result()
        try:
            result.success = self._handler.set_blend_ahead(args.per, args.num)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_blend_ahead", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_switch_mode(self, seqid, iprot, oprot):
        args = switch_mode_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = switch_mode_result()
        try:
            result.success = self._handler.switch_mode(args.mode)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("switch_mode", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read_encoder_count(self, seqid, iprot, oprot):
        args = read_encoder_count_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_encoder_count_result()
        try:
            result.success = self._handler.read_encoder_count()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read_encoder_count", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_kinematic_calibration_params(self, seqid, iprot, oprot):
        args = set_kinematic_calibration_params_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_kinematic_calibration_params_result()
        try:
            result.success = self._handler.set_kinematic_calibration_params(args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_kinematic_calibration_params", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_pos_bias(self, seqid, iprot, oprot):
        args = get_pos_bias_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_pos_bias_result()
        try:
            result.success = self._handler.get_pos_bias()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_pos_bias", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_system_value_lists(self, seqid, iprot, oprot):
        args = get_system_value_lists_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_system_value_lists_result()
        try:
            result.success = self._handler.get_system_value_lists(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_system_value_lists", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_origin_DH(self, seqid, iprot, oprot):
        args = get_origin_DH_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_origin_DH_result()
        try:
            result.success = self._handler.get_origin_DH()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_origin_DH", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_calib_DH(self, seqid, iprot, oprot):
        args = get_calib_DH_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_calib_DH_result()
        try:
            result.success = self._handler.get_calib_DH()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_calib_DH", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_robot_type(self, seqid, iprot, oprot):
        args = get_robot_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_robot_type_result()
        try:
            result.success = self._handler.get_robot_type()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_robot_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_ext_torque(self, seqid, iprot, oprot):
        args = get_ext_torque_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_ext_torque_result()
        try:
            result.success = self._handler.get_ext_torque()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_ext_torque", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_dynamic_calibration_params(self, seqid, iprot, oprot):
        args = set_dynamic_calibration_params_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_dynamic_calibration_params_result()
        try:
            result.success = self._handler.set_dynamic_calibration_params(args.params)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_dynamic_calibration_params", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_dynamic_calibration_params(self, seqid, iprot, oprot):
        args = get_dynamic_calibration_params_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_dynamic_calibration_params_result()
        try:
            result.success = self._handler.get_dynamic_calibration_params()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_dynamic_calibration_params", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_upload_robot_param_to_toolboard(self, seqid, iprot, oprot):
        args = upload_robot_param_to_toolboard_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = upload_robot_param_to_toolboard_result()
        try:
            result.success = self._handler.upload_robot_param_to_toolboard(args.passwd)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("upload_robot_param_to_toolboard", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_kinematic_calibration_info(self, seqid, iprot, oprot):
        args = set_kinematic_calibration_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_kinematic_calibration_info_result()
        try:
            result.success = self._handler.set_kinematic_calibration_info(args.passwd, args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_kinematic_calibration_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_dynamic_calibration_info(self, seqid, iprot, oprot):
        args = set_dynamic_calibration_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_dynamic_calibration_info_result()
        try:
            result.success = self._handler.set_dynamic_calibration_info(args.passwd, args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_dynamic_calibration_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_vibration_calibration_info(self, seqid, iprot, oprot):
        args = set_vibration_calibration_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_vibration_calibration_info_result()
        try:
            result.success = self._handler.set_vibration_calibration_info(args.passwd, args.info)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_vibration_calibration_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_axis_motor_rated_current(self, seqid, iprot, oprot):
        args = get_axis_motor_rated_current_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_axis_motor_rated_current_result()
        try:
            result.success = self._handler.get_axis_motor_rated_current()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_axis_motor_rated_current", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_axis_motor_kt(self, seqid, iprot, oprot):
        args = get_axis_motor_kt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_axis_motor_kt_result()
        try:
            result.success = self._handler.get_axis_motor_kt()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_axis_motor_kt", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abort(self, seqid, iprot, oprot):
        args = abort_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_result()
        try:
            result.success = self._handler.abort(args.block)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abort", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_vibration_calibration_params(self, seqid, iprot, oprot):
        args = get_vibration_calibration_params_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_vibration_calibration_params_result()
        try:
            result.success = self._handler.get_vibration_calibration_params()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_vibration_calibration_params", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_save_kinematic_calibration_params(self, seqid, iprot, oprot):
        args = save_kinematic_calibration_params_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = save_kinematic_calibration_params_result()
        try:
            result.success = self._handler.save_kinematic_calibration_params(args.passwd)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("save_kinematic_calibration_params", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_save_dynamic_calibration_params(self, seqid, iprot, oprot):
        args = save_dynamic_calibration_params_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = save_dynamic_calibration_params_result()
        try:
            result.success = self._handler.save_dynamic_calibration_params(args.passwd)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("save_dynamic_calibration_params", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class power_on_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_on_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_on_args)
power_on_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class power_on_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_on_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_on_result)
power_on_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class power_off_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_off_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_off_args)
power_off_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class power_off_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('power_off_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(power_off_result)
power_off_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_args)
enable_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class enable_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_result)
enable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_args)
disable_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class disable_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_result)
disable_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class shutdown_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_args)
shutdown_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class shutdown_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_result)
shutdown_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class stop_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_args)
stop_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class stop_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_result)
stop_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class pause_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pause_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pause_args)
pause_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class pause_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('pause_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(pause_result)
pause_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class resume_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resume_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resume_args)
resume_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class resume_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('resume_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(resume_result)
resume_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class run_program_args(object):
    """
    Attributes:
     - name
     - block

    """


    def __init__(self, name=None, block=None,):
        self.name = name
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_program_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_program_args)
run_program_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class run_program_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('run_program_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(run_program_result)
run_program_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_tool_data_args(object):
    """
    Attributes:
     - name
     - tool_offset
     - payload
     - inertia_tensor

    """


    def __init__(self, name=None, tool_offset=None, payload=None, inertia_tensor=None,):
        self.name = name
        self.tool_offset = tool_offset
        self.payload = payload
        self.inertia_tensor = inertia_tensor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tool_offset = []
                    (_etype332, _size329) = iprot.readListBegin()
                    for _i333 in range(_size329):
                        _elem334 = iprot.readDouble()
                        self.tool_offset.append(_elem334)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.payload = []
                    (_etype338, _size335) = iprot.readListBegin()
                    for _i339 in range(_size335):
                        _elem340 = iprot.readDouble()
                        self.payload.append(_elem340)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.inertia_tensor = []
                    (_etype344, _size341) = iprot.readListBegin()
                    for _i345 in range(_size341):
                        _elem346 = iprot.readDouble()
                        self.inertia_tensor.append(_elem346)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_data_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.tool_offset is not None:
            oprot.writeFieldBegin('tool_offset', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.tool_offset))
            for iter347 in self.tool_offset:
                oprot.writeDouble(iter347)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.payload))
            for iter348 in self.payload:
                oprot.writeDouble(iter348)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.inertia_tensor is not None:
            oprot.writeFieldBegin('inertia_tensor', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.inertia_tensor))
            for iter349 in self.inertia_tensor:
                oprot.writeDouble(iter349)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_data_args)
set_tool_data_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'tool_offset', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'payload', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'inertia_tensor', (TType.DOUBLE, None, False), None, ),  # 4
)


class set_tool_data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_data_result)
set_tool_data_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_tool_load_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_load_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_load_args)
get_tool_load_args.thrift_spec = (
)


class get_tool_load_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype353, _size350) = iprot.readListBegin()
                    for _i354 in range(_size350):
                        _elem355 = iprot.readDouble()
                        self.success.append(_elem355)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_load_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter356 in self.success:
                oprot.writeDouble(iter356)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_load_result)
get_tool_load_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_offset_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_offset_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_offset_args)
get_tcp_offset_args.thrift_spec = (
)


class get_tcp_offset_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype360, _size357) = iprot.readListBegin()
                    for _i361 in range(_size357):
                        _elem362 = iprot.readDouble()
                        self.success.append(_elem362)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_offset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter363 in self.success:
                oprot.writeDouble(iter363)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_offset_result)
get_tcp_offset_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class set_wobj_args(object):
    """
    Attributes:
     - name
     - wobj

    """


    def __init__(self, name=None, wobj=None,):
        self.name = name
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype367, _size364) = iprot.readListBegin()
                    for _i368 in range(_size364):
                        _elem369 = iprot.readDouble()
                        self.wobj.append(_elem369)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter370 in self.wobj:
                oprot.writeDouble(iter370)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_args)
set_wobj_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 2
)


class set_wobj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_result)
set_wobj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_wobj_offset_args(object):
    """
    Attributes:
     - wobj
     - active

    """


    def __init__(self, wobj=None, active=None,):
        self.wobj = wobj
        self.active = active

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype374, _size371) = iprot.readListBegin()
                    for _i375 in range(_size371):
                        _elem376 = iprot.readDouble()
                        self.wobj.append(_elem376)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_offset_args')
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter377 in self.wobj:
                oprot.writeDouble(iter377)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.active is not None:
            oprot.writeFieldBegin('active', TType.BOOL, 2)
            oprot.writeBool(self.active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_offset_args)
set_wobj_offset_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.BOOL, 'active', None, None, ),  # 2
)


class set_wobj_offset_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_wobj_offset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_wobj_offset_result)
set_wobj_offset_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_wobj_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_wobj_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_wobj_args)
get_wobj_args.thrift_spec = (
)


class get_wobj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype381, _size378) = iprot.readListBegin()
                    for _i382 in range(_size378):
                        _elem383 = iprot.readDouble()
                        self.success.append(_elem383)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_wobj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter384 in self.success:
                oprot.writeDouble(iter384)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_wobj_result)
get_wobj_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class cal_fkine_args(object):
    """
    Attributes:
     - joints_position
     - tool
     - wobj

    """


    def __init__(self, joints_position=None, tool=None, wobj=None,):
        self.joints_position = joints_position
        self.tool = tool
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_position = []
                    (_etype388, _size385) = iprot.readListBegin()
                    for _i389 in range(_size385):
                        _elem390 = iprot.readDouble()
                        self.joints_position.append(_elem390)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tool = []
                    (_etype394, _size391) = iprot.readListBegin()
                    for _i395 in range(_size391):
                        _elem396 = iprot.readDouble()
                        self.tool.append(_elem396)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype400, _size397) = iprot.readListBegin()
                    for _i401 in range(_size397):
                        _elem402 = iprot.readDouble()
                        self.wobj.append(_elem402)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_fkine_args')
        if self.joints_position is not None:
            oprot.writeFieldBegin('joints_position', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_position))
            for iter403 in self.joints_position:
                oprot.writeDouble(iter403)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.tool))
            for iter404 in self.tool:
                oprot.writeDouble(iter404)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter405 in self.wobj:
                oprot.writeDouble(iter405)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_fkine_args)
cal_fkine_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_position', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'tool', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 3
)


class cal_fkine_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype409, _size406) = iprot.readListBegin()
                    for _i410 in range(_size406):
                        _elem411 = iprot.readDouble()
                        self.success.append(_elem411)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_fkine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter412 in self.success:
                oprot.writeDouble(iter412)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_fkine_result)
cal_fkine_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class cal_ikine_args(object):
    """
    Attributes:
     - p
     - q_near
     - tool
     - wobj

    """


    def __init__(self, p=None, q_near=None, tool=None, wobj=None,):
        self.p = p
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype416, _size413) = iprot.readListBegin()
                    for _i417 in range(_size413):
                        _elem418 = iprot.readDouble()
                        self.p.append(_elem418)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype422, _size419) = iprot.readListBegin()
                    for _i423 in range(_size419):
                        _elem424 = iprot.readDouble()
                        self.q_near.append(_elem424)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tool = []
                    (_etype428, _size425) = iprot.readListBegin()
                    for _i429 in range(_size425):
                        _elem430 = iprot.readDouble()
                        self.tool.append(_elem430)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype434, _size431) = iprot.readListBegin()
                    for _i435 in range(_size431):
                        _elem436 = iprot.readDouble()
                        self.wobj.append(_elem436)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_ikine_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter437 in self.p:
                oprot.writeDouble(iter437)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter438 in self.q_near:
                oprot.writeDouble(iter438)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.tool))
            for iter439 in self.tool:
                oprot.writeDouble(iter439)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter440 in self.wobj:
                oprot.writeDouble(iter440)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_ikine_args)
cal_ikine_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'tool', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 4
)


class cal_ikine_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype444, _size441) = iprot.readListBegin()
                    for _i445 in range(_size441):
                        _elem446 = iprot.readDouble()
                        self.success.append(_elem446)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cal_ikine_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter447 in self.success:
                oprot.writeDouble(iter447)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(cal_ikine_result)
cal_ikine_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class set_digital_output_mode_args(object):
    """
    Attributes:
     - num
     - type
     - freq
     - duty_cycle

    """


    def __init__(self, num=None, type=None, freq=None, duty_cycle=None,):
        self.num = num
        self.type = type
        self.freq = freq
        self.duty_cycle = duty_cycle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.freq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.duty_cycle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_digital_output_mode_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 2)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.freq is not None:
            oprot.writeFieldBegin('freq', TType.I32, 3)
            oprot.writeI32(self.freq)
            oprot.writeFieldEnd()
        if self.duty_cycle is not None:
            oprot.writeFieldBegin('duty_cycle', TType.I32, 4)
            oprot.writeI32(self.duty_cycle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_digital_output_mode_args)
set_digital_output_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.I16, 'type', None, None, ),  # 2
    (3, TType.I32, 'freq', None, None, ),  # 3
    (4, TType.I32, 'duty_cycle', None, None, ),  # 4
)


class set_digital_output_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_digital_output_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_digital_output_mode_result)
set_digital_output_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_standard_digital_out_args(object):
    """
    Attributes:
     - num
     - value
     - block

    """


    def __init__(self, num=None, value=None, block=None,):
        self.num = num
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 2)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_digital_out_args)
set_standard_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'value', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_standard_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_digital_out_result)
set_standard_digital_out_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_tool_digital_out_args(object):
    """
    Attributes:
     - num
     - value
     - block

    """


    def __init__(self, num=None, value=None, block=None,):
        self.num = num
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 2)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_digital_out_args)
set_tool_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'value', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_tool_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_tool_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_tool_digital_out_result)
set_tool_digital_out_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_standard_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_digital_in_args)
get_standard_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_standard_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_digital_in_result)
get_standard_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_standard_digital_out_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_digital_out_args)
get_standard_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_standard_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_digital_out_result)
get_standard_digital_out_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_tool_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_digital_in_args)
get_tool_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_tool_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_digital_in_result)
get_tool_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_tool_digital_out_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_digital_out_args)
get_tool_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_tool_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_digital_out_result)
get_tool_digital_out_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_config_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_config_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_config_digital_in_args)
get_config_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_config_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_config_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_config_digital_in_result)
get_config_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_standard_analog_voltage_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_voltage_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_voltage_in_args)
get_standard_analog_voltage_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_standard_analog_voltage_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_voltage_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_voltage_in_result)
get_standard_analog_voltage_in_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class get_tool_analog_voltage_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_analog_voltage_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_analog_voltage_in_args)
get_tool_analog_voltage_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_tool_analog_voltage_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tool_analog_voltage_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tool_analog_voltage_in_result)
get_tool_analog_voltage_in_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class get_standard_analog_current_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_current_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_current_in_args)
get_standard_analog_current_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_standard_analog_current_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_standard_analog_current_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_standard_analog_current_in_result)
get_standard_analog_current_in_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class set_standard_analog_voltage_out_args(object):
    """
    Attributes:
     - num
     - value
     - block

    """


    def __init__(self, num=None, value=None, block=None,):
        self.num = num
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_analog_voltage_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 2)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_analog_voltage_out_args)
set_standard_analog_voltage_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.DOUBLE, 'value', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_standard_analog_voltage_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_analog_voltage_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_analog_voltage_out_result)
set_standard_analog_voltage_out_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_standard_analog_current_out_args(object):
    """
    Attributes:
     - num
     - value
     - block

    """


    def __init__(self, num=None, value=None, block=None,):
        self.num = num
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_analog_current_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 2)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_analog_current_out_args)
set_standard_analog_current_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.DOUBLE, 'value', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_standard_analog_current_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_standard_analog_current_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_standard_analog_current_out_result)
set_standard_analog_current_out_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class read_data_485_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_data_485_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_data_485_args)
read_data_485_args.thrift_spec = (
)


class read_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype451, _size448) = iprot.readListBegin()
                    for _i452 in range(_size448):
                        _elem453 = iprot.readByte()
                        self.success.append(_elem453)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter454 in self.success:
                oprot.writeByte(iter454)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_data_485_result)
read_data_485_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class read_raw_data_485_args(object):
    """
    Attributes:
     - len

    """


    def __init__(self, len=None,):
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_args')
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 1)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_args)
read_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'len', None, None, ),  # 1
)


class read_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype458, _size455) = iprot.readListBegin()
                    for _i459 in range(_size455):
                        _elem460 = iprot.readByte()
                        self.success.append(_elem460)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter461 in self.success:
                oprot.writeByte(iter461)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_result)
read_raw_data_485_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class read_raw_data_485_ht_args(object):
    """
    Attributes:
     - head
     - tail

    """


    def __init__(self, head=None, tail=None,):
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype465, _size462) = iprot.readListBegin()
                    for _i466 in range(_size462):
                        _elem467 = iprot.readByte()
                        self.head.append(_elem467)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype471, _size468) = iprot.readListBegin()
                    for _i472 in range(_size468):
                        _elem473 = iprot.readByte()
                        self.tail.append(_elem473)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_ht_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter474 in self.head:
                oprot.writeByte(iter474)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter475 in self.tail:
                oprot.writeByte(iter475)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_ht_args)
read_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 2
)


class read_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype479, _size476) = iprot.readListBegin()
                    for _i480 in range(_size476):
                        _elem481 = iprot.readByte()
                        self.success.append(_elem481)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter482 in self.success:
                oprot.writeByte(iter482)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_ht_result)
read_raw_data_485_ht_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class read_raw_data_485_h_args(object):
    """
    Attributes:
     - head
     - len

    """


    def __init__(self, head=None, len=None,):
        self.head = head
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype486, _size483) = iprot.readListBegin()
                    for _i487 in range(_size483):
                        _elem488 = iprot.readByte()
                        self.head.append(_elem488)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_h_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter489 in self.head:
                oprot.writeByte(iter489)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 2)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_h_args)
read_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.I32, 'len', None, None, ),  # 2
)


class read_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype493, _size490) = iprot.readListBegin()
                    for _i494 in range(_size490):
                        _elem495 = iprot.readByte()
                        self.success.append(_elem495)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter496 in self.success:
                oprot.writeByte(iter496)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_485_h_result)
read_raw_data_485_h_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class write_data_485_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype500, _size497) = iprot.readListBegin()
                    for _i501 in range(_size497):
                        _elem502 = iprot.readByte()
                        self.data.append(_elem502)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_data_485_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter503 in self.data:
                oprot.writeByte(iter503)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_data_485_args)
write_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
)


class write_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_data_485_result)
write_data_485_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class write_raw_data_485_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype507, _size504) = iprot.readListBegin()
                    for _i508 in range(_size504):
                        _elem509 = iprot.readByte()
                        self.data.append(_elem509)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter510 in self.data:
                oprot.writeByte(iter510)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_args)
write_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
)


class write_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_result)
write_raw_data_485_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class write_raw_data_485_h_args(object):
    """
    Attributes:
     - data
     - head

    """


    def __init__(self, data=None, head=None,):
        self.data = data
        self.head = head

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype514, _size511) = iprot.readListBegin()
                    for _i515 in range(_size511):
                        _elem516 = iprot.readByte()
                        self.data.append(_elem516)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype520, _size517) = iprot.readListBegin()
                    for _i521 in range(_size517):
                        _elem522 = iprot.readByte()
                        self.head.append(_elem522)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_h_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter523 in self.data:
                oprot.writeByte(iter523)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter524 in self.head:
                oprot.writeByte(iter524)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_h_args)
write_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
)


class write_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_h_result)
write_raw_data_485_h_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class write_raw_data_485_ht_args(object):
    """
    Attributes:
     - data
     - head
     - tail

    """


    def __init__(self, data=None, head=None, tail=None,):
        self.data = data
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype528, _size525) = iprot.readListBegin()
                    for _i529 in range(_size525):
                        _elem530 = iprot.readByte()
                        self.data.append(_elem530)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype534, _size531) = iprot.readListBegin()
                    for _i535 in range(_size531):
                        _elem536 = iprot.readByte()
                        self.head.append(_elem536)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype540, _size537) = iprot.readListBegin()
                    for _i541 in range(_size537):
                        _elem542 = iprot.readByte()
                        self.tail.append(_elem542)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_ht_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter543 in self.data:
                oprot.writeByte(iter543)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter544 in self.head:
                oprot.writeByte(iter544)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 3)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter545 in self.tail:
                oprot.writeByte(iter545)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_ht_args)
write_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
    (3, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 3
)


class write_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_485_ht_result)
write_raw_data_485_ht_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tool_read_data_485_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_data_485_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_data_485_args)
tool_read_data_485_args.thrift_spec = (
)


class tool_read_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype549, _size546) = iprot.readListBegin()
                    for _i550 in range(_size546):
                        _elem551 = iprot.readByte()
                        self.success.append(_elem551)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter552 in self.success:
                oprot.writeByte(iter552)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_data_485_result)
tool_read_data_485_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class tool_read_raw_data_485_args(object):
    """
    Attributes:
     - len

    """


    def __init__(self, len=None,):
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_args')
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 1)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_args)
tool_read_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'len', None, None, ),  # 1
)


class tool_read_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype556, _size553) = iprot.readListBegin()
                    for _i557 in range(_size553):
                        _elem558 = iprot.readByte()
                        self.success.append(_elem558)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter559 in self.success:
                oprot.writeByte(iter559)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_result)
tool_read_raw_data_485_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class tool_read_raw_data_485_h_args(object):
    """
    Attributes:
     - head
     - len

    """


    def __init__(self, head=None, len=None,):
        self.head = head
        self.len = len

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype563, _size560) = iprot.readListBegin()
                    for _i564 in range(_size560):
                        _elem565 = iprot.readByte()
                        self.head.append(_elem565)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_h_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter566 in self.head:
                oprot.writeByte(iter566)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 2)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_h_args)
tool_read_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.I32, 'len', None, None, ),  # 2
)


class tool_read_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype570, _size567) = iprot.readListBegin()
                    for _i571 in range(_size567):
                        _elem572 = iprot.readByte()
                        self.success.append(_elem572)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter573 in self.success:
                oprot.writeByte(iter573)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_h_result)
tool_read_raw_data_485_h_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class tool_read_raw_data_485_ht_args(object):
    """
    Attributes:
     - head
     - tail

    """


    def __init__(self, head=None, tail=None,):
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype577, _size574) = iprot.readListBegin()
                    for _i578 in range(_size574):
                        _elem579 = iprot.readByte()
                        self.head.append(_elem579)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype583, _size580) = iprot.readListBegin()
                    for _i584 in range(_size580):
                        _elem585 = iprot.readByte()
                        self.tail.append(_elem585)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_ht_args')
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter586 in self.head:
                oprot.writeByte(iter586)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter587 in self.tail:
                oprot.writeByte(iter587)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_ht_args)
tool_read_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 2
)


class tool_read_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype591, _size588) = iprot.readListBegin()
                    for _i592 in range(_size588):
                        _elem593 = iprot.readByte()
                        self.success.append(_elem593)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_read_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter594 in self.success:
                oprot.writeByte(iter594)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_read_raw_data_485_ht_result)
tool_read_raw_data_485_ht_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class tool_write_data_485_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype598, _size595) = iprot.readListBegin()
                    for _i599 in range(_size595):
                        _elem600 = iprot.readByte()
                        self.data.append(_elem600)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_data_485_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter601 in self.data:
                oprot.writeByte(iter601)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_data_485_args)
tool_write_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
)


class tool_write_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_data_485_result)
tool_write_data_485_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tool_write_raw_data_485_args(object):
    """
    Attributes:
     - data

    """


    def __init__(self, data=None,):
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype605, _size602) = iprot.readListBegin()
                    for _i606 in range(_size602):
                        _elem607 = iprot.readByte()
                        self.data.append(_elem607)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter608 in self.data:
                oprot.writeByte(iter608)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_args)
tool_write_raw_data_485_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
)


class tool_write_raw_data_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_result)
tool_write_raw_data_485_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tool_write_raw_data_485_h_args(object):
    """
    Attributes:
     - data
     - head

    """


    def __init__(self, data=None, head=None,):
        self.data = data
        self.head = head

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype612, _size609) = iprot.readListBegin()
                    for _i613 in range(_size609):
                        _elem614 = iprot.readByte()
                        self.data.append(_elem614)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype618, _size615) = iprot.readListBegin()
                    for _i619 in range(_size615):
                        _elem620 = iprot.readByte()
                        self.head.append(_elem620)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_h_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter621 in self.data:
                oprot.writeByte(iter621)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter622 in self.head:
                oprot.writeByte(iter622)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_h_args)
tool_write_raw_data_485_h_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
)


class tool_write_raw_data_485_h_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_h_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_h_result)
tool_write_raw_data_485_h_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class tool_write_raw_data_485_ht_args(object):
    """
    Attributes:
     - data
     - head
     - tail

    """


    def __init__(self, data=None, head=None, tail=None,):
        self.data = data
        self.head = head
        self.tail = tail

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype626, _size623) = iprot.readListBegin()
                    for _i627 in range(_size623):
                        _elem628 = iprot.readByte()
                        self.data.append(_elem628)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.head = []
                    (_etype632, _size629) = iprot.readListBegin()
                    for _i633 in range(_size629):
                        _elem634 = iprot.readByte()
                        self.head.append(_elem634)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tail = []
                    (_etype638, _size635) = iprot.readListBegin()
                    for _i639 in range(_size635):
                        _elem640 = iprot.readByte()
                        self.tail.append(_elem640)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_ht_args')
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 1)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter641 in self.data:
                oprot.writeByte(iter641)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.head is not None:
            oprot.writeFieldBegin('head', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.head))
            for iter642 in self.head:
                oprot.writeByte(iter642)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tail is not None:
            oprot.writeFieldBegin('tail', TType.LIST, 3)
            oprot.writeListBegin(TType.BYTE, len(self.tail))
            for iter643 in self.tail:
                oprot.writeByte(iter643)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_ht_args)
tool_write_raw_data_485_ht_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 1
    (2, TType.LIST, 'head', (TType.BYTE, None, False), None, ),  # 2
    (3, TType.LIST, 'tail', (TType.BYTE, None, False), None, ),  # 3
)


class tool_write_raw_data_485_ht_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tool_write_raw_data_485_ht_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tool_write_raw_data_485_ht_result)
tool_write_raw_data_485_ht_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class read_data_can_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_data_can_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_data_can_args)
read_data_can_args.thrift_spec = (
)


class read_data_can_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype647, _size644) = iprot.readListBegin()
                    for _i648 in range(_size644):
                        _elem649 = iprot.readByte()
                        self.success.append(_elem649)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_data_can_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter650 in self.success:
                oprot.writeByte(iter650)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_data_can_result)
read_data_can_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class read_raw_data_can_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_can_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_can_args)
read_raw_data_can_args.thrift_spec = (
)


class read_raw_data_can_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype654, _size651) = iprot.readListBegin()
                    for _i655 in range(_size651):
                        _elem656 = iprot.readByte()
                        self.success.append(_elem656)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_raw_data_can_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter657 in self.success:
                oprot.writeByte(iter657)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_raw_data_can_result)
read_raw_data_can_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class write_data_can_args(object):
    """
    Attributes:
     - id
     - data

    """


    def __init__(self, id=None, data=None,):
        self.id = id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype661, _size658) = iprot.readListBegin()
                    for _i662 in range(_size658):
                        _elem663 = iprot.readByte()
                        self.data.append(_elem663)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_data_can_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter664 in self.data:
                oprot.writeByte(iter664)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_data_can_args)
write_data_can_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 2
)


class write_data_can_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_data_can_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_data_can_result)
write_data_can_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class write_raw_data_can_args(object):
    """
    Attributes:
     - id
     - data

    """


    def __init__(self, id=None, data=None,):
        self.id = id
        self.data = data

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.data = []
                    (_etype668, _size665) = iprot.readListBegin()
                    for _i669 in range(_size665):
                        _elem670 = iprot.readByte()
                        self.data.append(_elem670)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_can_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.LIST, 2)
            oprot.writeListBegin(TType.BYTE, len(self.data))
            for iter671 in self.data:
                oprot.writeByte(iter671)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_can_args)
write_raw_data_can_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.LIST, 'data', (TType.BYTE, None, False), None, ),  # 2
)


class write_raw_data_can_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_raw_data_can_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_raw_data_can_result)
write_raw_data_can_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_function_digital_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_in_args)
get_function_digital_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_function_digital_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_in_result)
get_function_digital_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_function_digital_out_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_out_args)
get_function_digital_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_function_digital_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_digital_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_digital_out_result)
get_function_digital_out_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class read_bool_reg_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_bool_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_bool_reg_args)
read_bool_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class read_bool_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_bool_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_bool_reg_result)
read_bool_reg_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class read_word_reg_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_word_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_word_reg_args)
read_word_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class read_word_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_word_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_word_reg_result)
read_word_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class read_float_reg_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_float_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_float_reg_args)
read_float_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class read_float_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_float_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_float_reg_result)
read_float_reg_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class write_bool_reg_args(object):
    """
    Attributes:
     - num
     - value

    """


    def __init__(self, num=None, value=None,):
        self.num = num
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_bool_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 2)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_bool_reg_args)
write_bool_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'value', None, None, ),  # 2
)


class write_bool_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_bool_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_bool_reg_result)
write_bool_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class write_word_reg_args(object):
    """
    Attributes:
     - num
     - value

    """


    def __init__(self, num=None, value=None,):
        self.num = num
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_word_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_word_reg_args)
write_word_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)


class write_word_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_word_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_word_reg_result)
write_word_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class write_float_reg_args(object):
    """
    Attributes:
     - num
     - value

    """


    def __init__(self, num=None, value=None,):
        self.num = num
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_float_reg_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 2)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_float_reg_args)
write_float_reg_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.DOUBLE, 'value', None, None, ),  # 2
)


class write_float_reg_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_float_reg_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_float_reg_result)
write_float_reg_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_function_reg_in_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_reg_in_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_reg_in_args)
get_function_reg_in_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_function_reg_in_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_reg_in_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_reg_in_result)
get_function_reg_in_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_function_reg_out_args(object):
    """
    Attributes:
     - num

    """


    def __init__(self, num=None,):
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_reg_out_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_reg_out_args)
get_function_reg_out_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
)


class get_function_reg_out_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_function_reg_out_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_function_reg_out_result)
get_function_reg_out_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class movej_args(object):
    """
    Attributes:
     - joints_list
     - v
     - a
     - r
     - block
     - op
     - def_acc

    """


    def __init__(self, joints_list=None, v=None, a=None, r=None, block=None, op=None, def_acc=None,):
        self.joints_list = joints_list
        self.v = v
        self.a = a
        self.r = r
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype675, _size672) = iprot.readListBegin()
                    for _i676 in range(_size672):
                        _elem677 = iprot.readDouble()
                        self.joints_list.append(_elem677)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter678 in self.joints_list:
                oprot.writeDouble(iter678)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 5)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 6)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 7)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_args)
movej_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.BOOL, 'block', None, None, ),  # 5
    (6, TType.STRUCT, 'op', [Op, None], None, ),  # 6
    (7, TType.BOOL, 'def_acc', None, None, ),  # 7
)


class movej_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_result)
movej_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej_pose_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - r
     - q_near
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p=None, v=None, a=None, r=None, q_near=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p = p
        self.v = v
        self.a = a
        self.r = r
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype682, _size679) = iprot.readListBegin()
                    for _i683 in range(_size679):
                        _elem684 = iprot.readDouble()
                        self.p.append(_elem684)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype688, _size685) = iprot.readListBegin()
                    for _i689 in range(_size685):
                        _elem690 = iprot.readDouble()
                        self.q_near.append(_elem690)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter691 in self.p:
                oprot.writeDouble(iter691)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter692 in self.q_near:
                oprot.writeDouble(iter692)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 10)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose_args)
movej_pose_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
    (10, TType.BOOL, 'def_acc', None, None, ),  # 10
)


class movej_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose_result)
movej_pose_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej2_args(object):
    """
    Attributes:
     - joints_list
     - v
     - a
     - r
     - block
     - op
     - def_acc

    """


    def __init__(self, joints_list=None, v=None, a=None, r=None, block=None, op=None, def_acc=None,):
        self.joints_list = joints_list
        self.v = v
        self.a = a
        self.r = r
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype696, _size693) = iprot.readListBegin()
                    for _i697 in range(_size693):
                        _elem698 = iprot.readDouble()
                        self.joints_list.append(_elem698)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter699 in self.joints_list:
                oprot.writeDouble(iter699)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 5)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 6)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 7)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_args)
movej2_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.BOOL, 'block', None, None, ),  # 5
    (6, TType.STRUCT, 'op', [Op, None], None, ),  # 6
    (7, TType.BOOL, 'def_acc', None, None, ),  # 7
)


class movej2_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_result)
movej2_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej_pose2_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - r
     - q_near
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p=None, v=None, a=None, r=None, q_near=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p = p
        self.v = v
        self.a = a
        self.r = r
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype703, _size700) = iprot.readListBegin()
                    for _i704 in range(_size700):
                        _elem705 = iprot.readDouble()
                        self.p.append(_elem705)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype709, _size706) = iprot.readListBegin()
                    for _i710 in range(_size706):
                        _elem711 = iprot.readDouble()
                        self.q_near.append(_elem711)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose2_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter712 in self.p:
                oprot.writeDouble(iter712)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter713 in self.q_near:
                oprot.writeDouble(iter713)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 10)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose2_args)
movej_pose2_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
    (10, TType.BOOL, 'def_acc', None, None, ),  # 10
)


class movej_pose2_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej_pose2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej_pose2_result)
movej_pose2_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movel_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - r
     - q_near
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p=None, v=None, a=None, r=None, q_near=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p = p
        self.v = v
        self.a = a
        self.r = r
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype717, _size714) = iprot.readListBegin()
                    for _i718 in range(_size714):
                        _elem719 = iprot.readDouble()
                        self.p.append(_elem719)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype723, _size720) = iprot.readListBegin()
                    for _i724 in range(_size720):
                        _elem725 = iprot.readDouble()
                        self.q_near.append(_elem725)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movel_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter726 in self.p:
                oprot.writeDouble(iter726)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter727 in self.q_near:
                oprot.writeDouble(iter727)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 10)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movel_args)
movel_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
    (10, TType.BOOL, 'def_acc', None, None, ),  # 10
)


class movel_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movel_result)
movel_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movec_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - r
     - mode
     - q_near
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, r=None, mode=None, q_near=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.r = r
        self.mode = mode
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype731, _size728) = iprot.readListBegin()
                    for _i732 in range(_size728):
                        _elem733 = iprot.readDouble()
                        self.p1.append(_elem733)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype737, _size734) = iprot.readListBegin()
                    for _i738 in range(_size734):
                        _elem739 = iprot.readDouble()
                        self.p2.append(_elem739)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype743, _size740) = iprot.readListBegin()
                    for _i744 in range(_size740):
                        _elem745 = iprot.readDouble()
                        self.q_near.append(_elem745)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movec_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter746 in self.p1:
                oprot.writeDouble(iter746)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter747 in self.p2:
                oprot.writeDouble(iter747)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 6)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 7)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter748 in self.q_near:
                oprot.writeDouble(iter748)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 8)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 9)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 10)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 11)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 12)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movec_args)
movec_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.I32, 'mode', None, None, ),  # 6
    (7, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 7
    (8, TType.STRING, 'tool', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'wobj', 'UTF8', None, ),  # 9
    (10, TType.BOOL, 'block', None, None, ),  # 10
    (11, TType.STRUCT, 'op', [Op, None], None, ),  # 11
    (12, TType.BOOL, 'def_acc', None, None, ),  # 12
)


class movec_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movec_result)
movec_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class move_circle_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - r
     - mode
     - q_near
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, r=None, mode=None, q_near=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.r = r
        self.mode = mode
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype752, _size749) = iprot.readListBegin()
                    for _i753 in range(_size749):
                        _elem754 = iprot.readDouble()
                        self.p1.append(_elem754)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype758, _size755) = iprot.readListBegin()
                    for _i759 in range(_size755):
                        _elem760 = iprot.readDouble()
                        self.p2.append(_elem760)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype764, _size761) = iprot.readListBegin()
                    for _i765 in range(_size761):
                        _elem766 = iprot.readDouble()
                        self.q_near.append(_elem766)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_circle_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter767 in self.p1:
                oprot.writeDouble(iter767)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter768 in self.p2:
                oprot.writeDouble(iter768)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 6)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 7)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter769 in self.q_near:
                oprot.writeDouble(iter769)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 8)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 9)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 10)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 11)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 12)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_circle_args)
move_circle_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.I32, 'mode', None, None, ),  # 6
    (7, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 7
    (8, TType.STRING, 'tool', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'wobj', 'UTF8', None, ),  # 9
    (10, TType.BOOL, 'block', None, None, ),  # 10
    (11, TType.STRUCT, 'op', [Op, None], None, ),  # 11
    (12, TType.BOOL, 'def_acc', None, None, ),  # 12
)


class move_circle_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_circle_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_circle_result)
move_circle_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class tcp_move_args(object):
    """
    Attributes:
     - pose_offset
     - v
     - a
     - r
     - tool
     - block
     - op
     - def_acc

    """


    def __init__(self, pose_offset=None, v=None, a=None, r=None, tool=None, block=None, op=None, def_acc=None,):
        self.pose_offset = pose_offset
        self.v = v
        self.a = a
        self.r = r
        self.tool = tool
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_offset = []
                    (_etype773, _size770) = iprot.readListBegin()
                    for _i774 in range(_size770):
                        _elem775 = iprot.readDouble()
                        self.pose_offset.append(_elem775)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_args')
        if self.pose_offset is not None:
            oprot.writeFieldBegin('pose_offset', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_offset))
            for iter776 in self.pose_offset:
                oprot.writeDouble(iter776)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 5)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 6)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 7)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 8)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_args)
tcp_move_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_offset', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.STRING, 'tool', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'block', None, None, ),  # 6
    (7, TType.STRUCT, 'op', [Op, None], None, ),  # 7
    (8, TType.BOOL, 'def_acc', None, None, ),  # 8
)


class tcp_move_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_result)
tcp_move_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class tcp_move_2p_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - r
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, r=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.r = r
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype780, _size777) = iprot.readListBegin()
                    for _i781 in range(_size777):
                        _elem782 = iprot.readDouble()
                        self.p1.append(_elem782)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype786, _size783) = iprot.readListBegin()
                    for _i787 in range(_size783):
                        _elem788 = iprot.readDouble()
                        self.p2.append(_elem788)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_2p_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter789 in self.p1:
                oprot.writeDouble(iter789)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter790 in self.p2:
                oprot.writeDouble(iter790)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 10)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_2p_args)
tcp_move_2p_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
    (10, TType.BOOL, 'def_acc', None, None, ),  # 10
)


class tcp_move_2p_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tcp_move_2p_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tcp_move_2p_result)
tcp_move_2p_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class wobj_move_args(object):
    """
    Attributes:
     - pose_offset
     - v
     - a
     - r
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, pose_offset=None, v=None, a=None, r=None, wobj=None, block=None, op=None, def_acc=None,):
        self.pose_offset = pose_offset
        self.v = v
        self.a = a
        self.r = r
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_offset = []
                    (_etype794, _size791) = iprot.readListBegin()
                    for _i795 in range(_size791):
                        _elem796 = iprot.readDouble()
                        self.pose_offset.append(_elem796)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wobj_move_args')
        if self.pose_offset is not None:
            oprot.writeFieldBegin('pose_offset', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_offset))
            for iter797 in self.pose_offset:
                oprot.writeDouble(iter797)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 4)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 5)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 6)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 7)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 8)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wobj_move_args)
wobj_move_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_offset', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'r', None, None, ),  # 4
    (5, TType.STRING, 'wobj', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'block', None, None, ),  # 6
    (7, TType.STRUCT, 'op', [Op, None], None, ),  # 7
    (8, TType.BOOL, 'def_acc', None, None, ),  # 8
)


class wobj_move_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wobj_move_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wobj_move_result)
wobj_move_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class wobj_move_2p_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - r
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, r=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.r = r
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype801, _size798) = iprot.readListBegin()
                    for _i802 in range(_size798):
                        _elem803 = iprot.readDouble()
                        self.p1.append(_elem803)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype807, _size804) = iprot.readListBegin()
                    for _i808 in range(_size804):
                        _elem809 = iprot.readDouble()
                        self.p2.append(_elem809)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wobj_move_2p_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter810 in self.p1:
                oprot.writeDouble(iter810)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter811 in self.p2:
                oprot.writeDouble(iter811)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 10)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wobj_move_2p_args)
wobj_move_2p_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
    (10, TType.BOOL, 'def_acc', None, None, ),  # 10
)


class wobj_move_2p_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('wobj_move_2p_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(wobj_move_2p_result)
wobj_move_2p_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spline_args(object):
    """
    Attributes:
     - pose_list
     - v
     - a
     - tool
     - wobj
     - block
     - op
     - r
     - def_acc

    """


    def __init__(self, pose_list=None, v=None, a=None, tool=None, wobj=None, block=None, op=None, r=None, def_acc=None,):
        self.pose_list = pose_list
        self.v = v
        self.a = a
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.r = r
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype815, _size812) = iprot.readListBegin()
                    for _i816 in range(_size812):
                        _elem817 = []
                        (_etype821, _size818) = iprot.readListBegin()
                        for _i822 in range(_size818):
                            _elem823 = iprot.readDouble()
                            _elem817.append(_elem823)
                        iprot.readListEnd()
                        self.pose_list.append(_elem817)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spline_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.pose_list))
            for iter824 in self.pose_list:
                oprot.writeListBegin(TType.DOUBLE, len(iter824))
                for iter825 in iter824:
                    oprot.writeDouble(iter825)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 4)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 5)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 6)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 7)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 8)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 9)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spline_args)
spline_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.STRING, 'tool', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'wobj', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'block', None, None, ),  # 6
    (7, TType.STRUCT, 'op', [Op, None], None, ),  # 7
    (8, TType.DOUBLE, 'r', None, None, ),  # 8
    (9, TType.BOOL, 'def_acc', None, None, ),  # 9
)


class spline_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spline_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spline_result)
spline_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class spline_op_args(object):
    """
    Attributes:
     - pose_list
     - v
     - a
     - tool
     - wobj
     - block
     - op
     - r
     - def_acc

    """


    def __init__(self, pose_list=None, v=None, a=None, tool=None, wobj=None, block=None, op=None, r=None, def_acc=None,):
        self.pose_list = pose_list
        self.v = v
        self.a = a
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.r = r
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype829, _size826) = iprot.readListBegin()
                    for _i830 in range(_size826):
                        _elem831 = PointOp()
                        _elem831.read(iprot)
                        self.pose_list.append(_elem831)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spline_op_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.pose_list))
            for iter832 in self.pose_list:
                iter832.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 4)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 5)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 6)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 7)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 8)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 9)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spline_op_args)
spline_op_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.STRUCT, [PointOp, None], False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.STRING, 'tool', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'wobj', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'block', None, None, ),  # 6
    (7, TType.STRUCT, 'op', [Op, None], None, ),  # 7
    (8, TType.DOUBLE, 'r', None, None, ),  # 8
    (9, TType.BOOL, 'def_acc', None, None, ),  # 9
)


class spline_op_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('spline_op_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(spline_op_result)
spline_op_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speedj_args(object):
    """
    Attributes:
     - joints_list
     - a
     - time
     - block

    """


    def __init__(self, joints_list=None, a=None, time=None, block=None,):
        self.joints_list = joints_list
        self.a = a
        self.time = time
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype836, _size833) = iprot.readListBegin()
                    for _i837 in range(_size833):
                        _elem838 = iprot.readDouble()
                        self.joints_list.append(_elem838)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedj_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter839 in self.joints_list:
                oprot.writeDouble(iter839)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 2)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I32, 3)
            oprot.writeI32(self.time)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 4)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedj_args)
speedj_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'a', None, None, ),  # 2
    (3, TType.I32, 'time', None, None, ),  # 3
    (4, TType.BOOL, 'block', None, None, ),  # 4
)


class speedj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedj_result)
speedj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speedl_args(object):
    """
    Attributes:
     - pose_list
     - a
     - time
     - block

    """


    def __init__(self, pose_list=None, a=None, time=None, block=None,):
        self.pose_list = pose_list
        self.a = a
        self.time = time
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype843, _size840) = iprot.readListBegin()
                    for _i844 in range(_size840):
                        _elem845 = iprot.readDouble()
                        self.pose_list.append(_elem845)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.time = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedl_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_list))
            for iter846 in self.pose_list:
                oprot.writeDouble(iter846)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 2)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I32, 3)
            oprot.writeI32(self.time)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 4)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedl_args)
speedl_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'a', None, None, ),  # 2
    (3, TType.I32, 'time', None, None, ),  # 3
    (4, TType.BOOL, 'block', None, None, ),  # 4
)


class speedl_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speedl_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speedl_result)
speedl_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speed_stop_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_stop_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_stop_args)
speed_stop_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class speed_stop_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_stop_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_stop_result)
speed_stop_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class servoj_args(object):
    """
    Attributes:
     - joints_list
     - v
     - a
     - block
     - kp
     - kd
     - smooth_vel
     - smooth_acc

    """


    def __init__(self, joints_list=None, v=None, a=None, block=None, kp=None, kd=None, smooth_vel=None, smooth_acc=None,):
        self.joints_list = joints_list
        self.v = v
        self.a = a
        self.block = block
        self.kp = kp
        self.kd = kd
        self.smooth_vel = smooth_vel
        self.smooth_acc = smooth_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype850, _size847) = iprot.readListBegin()
                    for _i851 in range(_size847):
                        _elem852 = iprot.readDouble()
                        self.joints_list.append(_elem852)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.kp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.kd = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.smooth_vel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.smooth_acc = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter853 in self.joints_list:
                oprot.writeDouble(iter853)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 4)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.kp is not None:
            oprot.writeFieldBegin('kp', TType.DOUBLE, 5)
            oprot.writeDouble(self.kp)
            oprot.writeFieldEnd()
        if self.kd is not None:
            oprot.writeFieldBegin('kd', TType.DOUBLE, 6)
            oprot.writeDouble(self.kd)
            oprot.writeFieldEnd()
        if self.smooth_vel is not None:
            oprot.writeFieldBegin('smooth_vel', TType.DOUBLE, 7)
            oprot.writeDouble(self.smooth_vel)
            oprot.writeFieldEnd()
        if self.smooth_acc is not None:
            oprot.writeFieldBegin('smooth_acc', TType.DOUBLE, 8)
            oprot.writeDouble(self.smooth_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_args)
servoj_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.BOOL, 'block', None, None, ),  # 4
    (5, TType.DOUBLE, 'kp', None, None, ),  # 5
    (6, TType.DOUBLE, 'kd', None, None, ),  # 6
    (7, TType.DOUBLE, 'smooth_vel', None, None, ),  # 7
    (8, TType.DOUBLE, 'smooth_acc', None, None, ),  # 8
)


class servoj_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_result)
servoj_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class servoj_pose_args(object):
    """
    Attributes:
     - pose_list
     - v
     - a
     - q_near
     - tool
     - wobj
     - block
     - kp
     - kd
     - smooth_vel
     - smooth_acc

    """


    def __init__(self, pose_list=None, v=None, a=None, q_near=None, tool=None, wobj=None, block=None, kp=None, kd=None, smooth_vel=None, smooth_acc=None,):
        self.pose_list = pose_list
        self.v = v
        self.a = a
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.kp = kp
        self.kd = kd
        self.smooth_vel = smooth_vel
        self.smooth_acc = smooth_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype857, _size854) = iprot.readListBegin()
                    for _i858 in range(_size854):
                        _elem859 = iprot.readDouble()
                        self.pose_list.append(_elem859)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype863, _size860) = iprot.readListBegin()
                    for _i864 in range(_size860):
                        _elem865 = iprot.readDouble()
                        self.q_near.append(_elem865)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.kp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.kd = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.smooth_vel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.smooth_acc = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_pose_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_list))
            for iter866 in self.pose_list:
                oprot.writeDouble(iter866)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter867 in self.q_near:
                oprot.writeDouble(iter867)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 5)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 6)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 7)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.kp is not None:
            oprot.writeFieldBegin('kp', TType.DOUBLE, 8)
            oprot.writeDouble(self.kp)
            oprot.writeFieldEnd()
        if self.kd is not None:
            oprot.writeFieldBegin('kd', TType.DOUBLE, 9)
            oprot.writeDouble(self.kd)
            oprot.writeFieldEnd()
        if self.smooth_vel is not None:
            oprot.writeFieldBegin('smooth_vel', TType.DOUBLE, 10)
            oprot.writeDouble(self.smooth_vel)
            oprot.writeFieldEnd()
        if self.smooth_acc is not None:
            oprot.writeFieldBegin('smooth_acc', TType.DOUBLE, 11)
            oprot.writeDouble(self.smooth_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_pose_args)
servoj_pose_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.STRING, 'tool', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'wobj', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'block', None, None, ),  # 7
    (8, TType.DOUBLE, 'kp', None, None, ),  # 8
    (9, TType.DOUBLE, 'kd', None, None, ),  # 9
    (10, TType.DOUBLE, 'smooth_vel', None, None, ),  # 10
    (11, TType.DOUBLE, 'smooth_acc', None, None, ),  # 11
)


class servoj_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servoj_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servoj_pose_result)
servoj_pose_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class servo_tcp_args(object):
    """
    Attributes:
     - pose_offset
     - v
     - a
     - tool
     - block
     - kp
     - kd
     - smooth_vel
     - smooth_acc

    """


    def __init__(self, pose_offset=None, v=None, a=None, tool=None, block=None, kp=None, kd=None, smooth_vel=None, smooth_acc=None,):
        self.pose_offset = pose_offset
        self.v = v
        self.a = a
        self.tool = tool
        self.block = block
        self.kp = kp
        self.kd = kd
        self.smooth_vel = smooth_vel
        self.smooth_acc = smooth_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_offset = []
                    (_etype871, _size868) = iprot.readListBegin()
                    for _i872 in range(_size868):
                        _elem873 = iprot.readDouble()
                        self.pose_offset.append(_elem873)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.kp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.kd = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.smooth_vel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.smooth_acc = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servo_tcp_args')
        if self.pose_offset is not None:
            oprot.writeFieldBegin('pose_offset', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_offset))
            for iter874 in self.pose_offset:
                oprot.writeDouble(iter874)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 4)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 5)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.kp is not None:
            oprot.writeFieldBegin('kp', TType.DOUBLE, 6)
            oprot.writeDouble(self.kp)
            oprot.writeFieldEnd()
        if self.kd is not None:
            oprot.writeFieldBegin('kd', TType.DOUBLE, 7)
            oprot.writeDouble(self.kd)
            oprot.writeFieldEnd()
        if self.smooth_vel is not None:
            oprot.writeFieldBegin('smooth_vel', TType.DOUBLE, 8)
            oprot.writeDouble(self.smooth_vel)
            oprot.writeFieldEnd()
        if self.smooth_acc is not None:
            oprot.writeFieldBegin('smooth_acc', TType.DOUBLE, 9)
            oprot.writeDouble(self.smooth_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servo_tcp_args)
servo_tcp_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_offset', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.STRING, 'tool', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'block', None, None, ),  # 5
    (6, TType.DOUBLE, 'kp', None, None, ),  # 6
    (7, TType.DOUBLE, 'kd', None, None, ),  # 7
    (8, TType.DOUBLE, 'smooth_vel', None, None, ),  # 8
    (9, TType.DOUBLE, 'smooth_acc', None, None, ),  # 9
)


class servo_tcp_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servo_tcp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servo_tcp_result)
servo_tcp_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class servol_args(object):
    """
    Attributes:
     - pose_list
     - v
     - a
     - q_near
     - tool
     - wobj
     - block
     - kp
     - kd
     - smooth_vel
     - smooth_acc

    """


    def __init__(self, pose_list=None, v=None, a=None, q_near=None, tool=None, wobj=None, block=None, kp=None, kd=None, smooth_vel=None, smooth_acc=None,):
        self.pose_list = pose_list
        self.v = v
        self.a = a
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.kp = kp
        self.kd = kd
        self.smooth_vel = smooth_vel
        self.smooth_acc = smooth_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.pose_list = []
                    (_etype878, _size875) = iprot.readListBegin()
                    for _i879 in range(_size875):
                        _elem880 = iprot.readDouble()
                        self.pose_list.append(_elem880)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype884, _size881) = iprot.readListBegin()
                    for _i885 in range(_size881):
                        _elem886 = iprot.readDouble()
                        self.q_near.append(_elem886)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.kp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.kd = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.smooth_vel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.smooth_acc = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servol_args')
        if self.pose_list is not None:
            oprot.writeFieldBegin('pose_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.pose_list))
            for iter887 in self.pose_list:
                oprot.writeDouble(iter887)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter888 in self.q_near:
                oprot.writeDouble(iter888)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 5)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 6)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 7)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.kp is not None:
            oprot.writeFieldBegin('kp', TType.DOUBLE, 8)
            oprot.writeDouble(self.kp)
            oprot.writeFieldEnd()
        if self.kd is not None:
            oprot.writeFieldBegin('kd', TType.DOUBLE, 9)
            oprot.writeDouble(self.kd)
            oprot.writeFieldEnd()
        if self.smooth_vel is not None:
            oprot.writeFieldBegin('smooth_vel', TType.DOUBLE, 10)
            oprot.writeDouble(self.smooth_vel)
            oprot.writeFieldEnd()
        if self.smooth_acc is not None:
            oprot.writeFieldBegin('smooth_acc', TType.DOUBLE, 11)
            oprot.writeDouble(self.smooth_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servol_args)
servol_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'pose_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.STRING, 'tool', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'wobj', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'block', None, None, ),  # 7
    (8, TType.DOUBLE, 'kp', None, None, ),  # 8
    (9, TType.DOUBLE, 'kd', None, None, ),  # 9
    (10, TType.DOUBLE, 'smooth_vel', None, None, ),  # 10
    (11, TType.DOUBLE, 'smooth_acc', None, None, ),  # 11
)


class servol_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('servol_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(servol_result)
servol_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class teach_mode_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('teach_mode_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(teach_mode_args)
teach_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class teach_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('teach_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(teach_mode_result)
teach_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class end_teach_mode_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_teach_mode_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_teach_mode_args)
end_teach_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class end_teach_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_teach_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_teach_mode_result)
end_teach_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_add_signal_args(object):
    """
    Attributes:
     - ip
     - slave_number
     - signal_address
     - signal_type
     - signal_name

    """


    def __init__(self, ip=None, slave_number=None, signal_address=None, signal_type=None, signal_name=None,):
        self.ip = ip
        self.slave_number = slave_number
        self.signal_address = signal_address
        self.signal_type = signal_type
        self.signal_name = signal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.slave_number = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.signal_address = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.signal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_add_signal_args')
        if self.ip is not None:
            oprot.writeFieldBegin('ip', TType.STRING, 1)
            oprot.writeString(self.ip.encode('utf-8') if sys.version_info[0] == 2 else self.ip)
            oprot.writeFieldEnd()
        if self.slave_number is not None:
            oprot.writeFieldBegin('slave_number', TType.I32, 2)
            oprot.writeI32(self.slave_number)
            oprot.writeFieldEnd()
        if self.signal_address is not None:
            oprot.writeFieldBegin('signal_address', TType.I32, 3)
            oprot.writeI32(self.signal_address)
            oprot.writeFieldEnd()
        if self.signal_type is not None:
            oprot.writeFieldBegin('signal_type', TType.I32, 4)
            oprot.writeI32(self.signal_type)
            oprot.writeFieldEnd()
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 5)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_add_signal_args)
modbus_add_signal_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ip', 'UTF8', None, ),  # 1
    (2, TType.I32, 'slave_number', None, None, ),  # 2
    (3, TType.I32, 'signal_address', None, None, ),  # 3
    (4, TType.I32, 'signal_type', None, None, ),  # 4
    (5, TType.STRING, 'signal_name', 'UTF8', None, ),  # 5
)


class modbus_add_signal_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_add_signal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_add_signal_result)
modbus_add_signal_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_delete_signal_args(object):
    """
    Attributes:
     - signal_name

    """


    def __init__(self, signal_name=None,):
        self.signal_name = signal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_delete_signal_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_delete_signal_args)
modbus_delete_signal_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
)


class modbus_delete_signal_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_delete_signal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_delete_signal_result)
modbus_delete_signal_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_read_args(object):
    """
    Attributes:
     - signal_name

    """


    def __init__(self, signal_name=None,):
        self.signal_name = signal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_read_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_read_args)
modbus_read_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
)


class modbus_read_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_read_result)
modbus_read_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_write_args(object):
    """
    Attributes:
     - signal_name
     - value

    """


    def __init__(self, signal_name=None, value=None,):
        self.signal_name = signal_name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_args)
modbus_write_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
)


class modbus_write_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_result)
modbus_write_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_set_frequency_args(object):
    """
    Attributes:
     - signal_name
     - frequence

    """


    def __init__(self, signal_name=None, frequence=None,):
        self.signal_name = signal_name
        self.frequence = frequence

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.signal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.frequence = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_set_frequency_args')
        if self.signal_name is not None:
            oprot.writeFieldBegin('signal_name', TType.STRING, 1)
            oprot.writeString(self.signal_name.encode('utf-8') if sys.version_info[0] == 2 else self.signal_name)
            oprot.writeFieldEnd()
        if self.frequence is not None:
            oprot.writeFieldBegin('frequence', TType.I32, 2)
            oprot.writeI32(self.frequence)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_set_frequency_args)
modbus_set_frequency_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'signal_name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'frequence', None, None, ),  # 2
)


class modbus_set_frequency_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_set_frequency_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_set_frequency_result)
modbus_set_frequency_result.thrift_spec = (
)


class get_last_error_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_last_error_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_last_error_args)
get_last_error_args.thrift_spec = (
)


class get_last_error_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype892, _size889) = iprot.readListBegin()
                    for _i893 in range(_size889):
                        _elem894 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem894)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_last_error_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter895 in self.success:
                oprot.writeString(iter895.encode('utf-8') if sys.version_info[0] == 2 else iter895)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_last_error_result)
get_last_error_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_noneblock_taskstate_args(object):
    """
    Attributes:
     - id

    """


    def __init__(self, id=None,):
        self.id = id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_noneblock_taskstate_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_noneblock_taskstate_args)
get_noneblock_taskstate_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
)


class get_noneblock_taskstate_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_noneblock_taskstate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_noneblock_taskstate_result)
get_noneblock_taskstate_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class log_info_args(object):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_info_args')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_info_args)
log_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)


class log_info_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_info_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_info_result)
log_info_result.thrift_spec = (
)


class log_error_args(object):
    """
    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_error_args')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_error_args)
log_error_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)


class log_error_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('log_error_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(log_error_result)
log_error_result.thrift_spec = (
)


class simulation_args(object):
    """
    Attributes:
     - sim
     - block

    """


    def __init__(self, sim=None, block=None,):
        self.sim = sim
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.sim = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simulation_args')
        if self.sim is not None:
            oprot.writeFieldBegin('sim', TType.BOOL, 1)
            oprot.writeBool(self.sim)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simulation_args)
simulation_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'sim', None, None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class simulation_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('simulation_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(simulation_result)
simulation_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class speed_args(object):
    """
    Attributes:
     - val

    """


    def __init__(self, val=None,):
        self.val = val

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.val = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_args')
        if self.val is not None:
            oprot.writeFieldBegin('val', TType.DOUBLE, 1)
            oprot.writeDouble(self.val)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_args)
speed_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'val', None, None, ),  # 1
)


class speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(speed_result)
speed_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_robot_state_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_state_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_state_args)
get_robot_state_args.thrift_spec = (
)


class get_robot_state_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype899, _size896) = iprot.readListBegin()
                    for _i900 in range(_size896):
                        _elem901 = iprot.readByte()
                        self.success.append(_elem901)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_state_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.BYTE, len(self.success))
            for iter902 in self.success:
                oprot.writeByte(iter902)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_state_result)
get_robot_state_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.BYTE, None, False), None, ),  # 0
)


class get_flange_pose_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_pose_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_pose_args)
get_flange_pose_args.thrift_spec = (
)


class get_flange_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype906, _size903) = iprot.readListBegin()
                    for _i907 in range(_size903):
                        _elem908 = iprot.readDouble()
                        self.success.append(_elem908)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter909 in self.success:
                oprot.writeDouble(iter909)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_pose_result)
get_flange_pose_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_flange_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_speed_args)
get_flange_speed_args.thrift_spec = (
)


class get_flange_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype913, _size910) = iprot.readListBegin()
                    for _i914 in range(_size910):
                        _elem915 = iprot.readDouble()
                        self.success.append(_elem915)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter916 in self.success:
                oprot.writeDouble(iter916)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_speed_result)
get_flange_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_flange_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_acceleration_args)
get_flange_acceleration_args.thrift_spec = (
)


class get_flange_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype920, _size917) = iprot.readListBegin()
                    for _i921 in range(_size917):
                        _elem922 = iprot.readDouble()
                        self.success.append(_elem922)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_flange_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter923 in self.success:
                oprot.writeDouble(iter923)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_flange_acceleration_result)
get_flange_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_pose_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_pose_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_pose_args)
get_tcp_pose_args.thrift_spec = (
)


class get_tcp_pose_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype927, _size924) = iprot.readListBegin()
                    for _i928 in range(_size924):
                        _elem929 = iprot.readDouble()
                        self.success.append(_elem929)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_pose_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter930 in self.success:
                oprot.writeDouble(iter930)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_pose_result)
get_tcp_pose_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_speed_args)
get_tcp_speed_args.thrift_spec = (
)


class get_tcp_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype934, _size931) = iprot.readListBegin()
                    for _i935 in range(_size931):
                        _elem936 = iprot.readDouble()
                        self.success.append(_elem936)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter937 in self.success:
                oprot.writeDouble(iter937)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_speed_result)
get_tcp_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_acceleration_args)
get_tcp_acceleration_args.thrift_spec = (
)


class get_tcp_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype941, _size938) = iprot.readListBegin()
                    for _i942 in range(_size938):
                        _elem943 = iprot.readDouble()
                        self.success.append(_elem943)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter944 in self.success:
                oprot.writeDouble(iter944)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_acceleration_result)
get_tcp_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_force_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_force_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_force_args)
get_tcp_force_args.thrift_spec = (
)


class get_tcp_force_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype948, _size945) = iprot.readListBegin()
                    for _i949 in range(_size945):
                        _elem950 = iprot.readDouble()
                        self.success.append(_elem950)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_force_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter951 in self.success:
                oprot.writeDouble(iter951)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_force_result)
get_tcp_force_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_position_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_position_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_position_args)
get_actual_joints_position_args.thrift_spec = (
)


class get_actual_joints_position_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype955, _size952) = iprot.readListBegin()
                    for _i956 in range(_size952):
                        _elem957 = iprot.readDouble()
                        self.success.append(_elem957)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_position_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter958 in self.success:
                oprot.writeDouble(iter958)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_position_result)
get_actual_joints_position_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_position_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_position_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_position_args)
get_target_joints_position_args.thrift_spec = (
)


class get_target_joints_position_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype962, _size959) = iprot.readListBegin()
                    for _i963 in range(_size959):
                        _elem964 = iprot.readDouble()
                        self.success.append(_elem964)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_position_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter965 in self.success:
                oprot.writeDouble(iter965)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_position_result)
get_target_joints_position_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_speed_args)
get_actual_joints_speed_args.thrift_spec = (
)


class get_actual_joints_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype969, _size966) = iprot.readListBegin()
                    for _i970 in range(_size966):
                        _elem971 = iprot.readDouble()
                        self.success.append(_elem971)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter972 in self.success:
                oprot.writeDouble(iter972)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_speed_result)
get_actual_joints_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_speed_args)
get_target_joints_speed_args.thrift_spec = (
)


class get_target_joints_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype976, _size973) = iprot.readListBegin()
                    for _i977 in range(_size973):
                        _elem978 = iprot.readDouble()
                        self.success.append(_elem978)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter979 in self.success:
                oprot.writeDouble(iter979)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_speed_result)
get_target_joints_speed_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_acceleration_args)
get_actual_joints_acceleration_args.thrift_spec = (
)


class get_actual_joints_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype983, _size980) = iprot.readListBegin()
                    for _i984 in range(_size980):
                        _elem985 = iprot.readDouble()
                        self.success.append(_elem985)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter986 in self.success:
                oprot.writeDouble(iter986)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_acceleration_result)
get_actual_joints_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_acceleration_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_acceleration_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_acceleration_args)
get_target_joints_acceleration_args.thrift_spec = (
)


class get_target_joints_acceleration_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype990, _size987) = iprot.readListBegin()
                    for _i991 in range(_size987):
                        _elem992 = iprot.readDouble()
                        self.success.append(_elem992)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_acceleration_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter993 in self.success:
                oprot.writeDouble(iter993)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_acceleration_result)
get_target_joints_acceleration_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_actual_joints_torque_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_torque_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_torque_args)
get_actual_joints_torque_args.thrift_spec = (
)


class get_actual_joints_torque_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype997, _size994) = iprot.readListBegin()
                    for _i998 in range(_size994):
                        _elem999 = iprot.readDouble()
                        self.success.append(_elem999)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_actual_joints_torque_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1000 in self.success:
                oprot.writeDouble(iter1000)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_actual_joints_torque_result)
get_actual_joints_torque_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_target_joints_torque_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_torque_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_torque_args)
get_target_joints_torque_args.thrift_spec = (
)


class get_target_joints_torque_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1004, _size1001) = iprot.readListBegin()
                    for _i1005 in range(_size1001):
                        _elem1006 = iprot.readDouble()
                        self.success.append(_elem1006)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_target_joints_torque_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1007 in self.success:
                oprot.writeDouble(iter1007)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_target_joints_torque_result)
get_target_joints_torque_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class stop_record_track_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_record_track_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_record_track_args)
stop_record_track_args.thrift_spec = (
)


class stop_record_track_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_record_track_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_record_track_result)
stop_record_track_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class start_record_track_args(object):
    """
    Attributes:
     - name
     - mode
     - tool
     - wobj
     - interval

    """


    def __init__(self, name=None, mode=None, tool=None, wobj=None, interval=None,):
        self.name = name
        self.mode = mode
        self.tool = tool
        self.wobj = wobj
        self.interval = interval

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.interval = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_record_track_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 2)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 3)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 4)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.DOUBLE, 5)
            oprot.writeDouble(self.interval)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_record_track_args)
start_record_track_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'mode', None, None, ),  # 2
    (3, TType.STRING, 'tool', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'wobj', 'UTF8', None, ),  # 4
    (5, TType.DOUBLE, 'interval', None, None, ),  # 5
)


class start_record_track_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_record_track_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_record_track_result)
start_record_track_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class collision_detect_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('collision_detect_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 1)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(collision_detect_args)
collision_detect_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'value', None, None, ),  # 1
)


class collision_detect_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('collision_detect_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(collision_detect_result)
collision_detect_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class replay_args(object):
    """
    Attributes:
     - name
     - value
     - mode

    """


    def __init__(self, name=None, value=None, mode=None,):
        self.name = name
        self.value = value
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replay_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 2)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 3)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replay_args)
replay_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'value', None, None, ),  # 2
    (3, TType.I32, 'mode', None, None, ),  # 3
)


class replay_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('replay_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(replay_result)
replay_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_load_data_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.value = []
                    (_etype1011, _size1008) = iprot.readListBegin()
                    for _i1012 in range(_size1008):
                        _elem1013 = iprot.readDouble()
                        self.value.append(_elem1013)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_load_data_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.value))
            for iter1014 in self.value:
                oprot.writeDouble(iter1014)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_load_data_args)
set_load_data_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'value', (TType.DOUBLE, None, False), None, ),  # 1
)


class set_load_data_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_load_data_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_load_data_result)
set_load_data_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_start_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_start_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_start_args)
fc_start_args.thrift_spec = (
)


class fc_start_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_start_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_start_result)
fc_start_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_stop_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_stop_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_stop_args)
fc_stop_args.thrift_spec = (
)


class fc_stop_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_stop_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_stop_result)
fc_stop_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_config_args(object):
    """
    Attributes:
     - direction
     - ref_ft
     - damp
     - max_vel
     - number_list
     - tool
     - wobj
     - value

    """


    def __init__(self, direction=None, ref_ft=None, damp=None, max_vel=None, number_list=None, tool=None, wobj=None, value=None,):
        self.direction = direction
        self.ref_ft = ref_ft
        self.damp = damp
        self.max_vel = max_vel
        self.number_list = number_list
        self.tool = tool
        self.wobj = wobj
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.direction = []
                    (_etype1018, _size1015) = iprot.readListBegin()
                    for _i1019 in range(_size1015):
                        _elem1020 = iprot.readBool()
                        self.direction.append(_elem1020)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ref_ft = []
                    (_etype1024, _size1021) = iprot.readListBegin()
                    for _i1025 in range(_size1021):
                        _elem1026 = iprot.readDouble()
                        self.ref_ft.append(_elem1026)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.damp = []
                    (_etype1030, _size1027) = iprot.readListBegin()
                    for _i1031 in range(_size1027):
                        _elem1032 = iprot.readDouble()
                        self.damp.append(_elem1032)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.max_vel = []
                    (_etype1036, _size1033) = iprot.readListBegin()
                    for _i1037 in range(_size1033):
                        _elem1038 = iprot.readDouble()
                        self.max_vel.append(_elem1038)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.number_list = []
                    (_etype1042, _size1039) = iprot.readListBegin()
                    for _i1043 in range(_size1039):
                        _elem1044 = iprot.readDouble()
                        self.number_list.append(_elem1044)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_config_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.direction))
            for iter1045 in self.direction:
                oprot.writeBool(iter1045)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ref_ft is not None:
            oprot.writeFieldBegin('ref_ft', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.ref_ft))
            for iter1046 in self.ref_ft:
                oprot.writeDouble(iter1046)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.damp is not None:
            oprot.writeFieldBegin('damp', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.damp))
            for iter1047 in self.damp:
                oprot.writeDouble(iter1047)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_vel is not None:
            oprot.writeFieldBegin('max_vel', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.max_vel))
            for iter1048 in self.max_vel:
                oprot.writeDouble(iter1048)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.number_list is not None:
            oprot.writeFieldBegin('number_list', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.number_list))
            for iter1049 in self.number_list:
                oprot.writeDouble(iter1049)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 8)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_config_args)
fc_config_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'direction', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'ref_ft', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'damp', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'max_vel', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.LIST, 'number_list', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.I32, 'value', None, None, ),  # 8
)


class fc_config_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_config_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_config_result)
fc_config_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_move_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_move_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_move_args)
fc_move_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class fc_move_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_move_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_move_result)
fc_move_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_guard_act_args(object):
    """
    Attributes:
     - direction
     - ref_ft
     - tool
     - wobj
     - type
     - force_property

    """


    def __init__(self, direction=None, ref_ft=None, tool=None, wobj=None, type=None, force_property=None,):
        self.direction = direction
        self.ref_ft = ref_ft
        self.tool = tool
        self.wobj = wobj
        self.type = type
        self.force_property = force_property

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.direction = []
                    (_etype1053, _size1050) = iprot.readListBegin()
                    for _i1054 in range(_size1050):
                        _elem1055 = iprot.readBool()
                        self.direction.append(_elem1055)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ref_ft = []
                    (_etype1059, _size1056) = iprot.readListBegin()
                    for _i1060 in range(_size1056):
                        _elem1061 = iprot.readDouble()
                        self.ref_ft.append(_elem1061)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.force_property = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_act_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.direction))
            for iter1062 in self.direction:
                oprot.writeBool(iter1062)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ref_ft is not None:
            oprot.writeFieldBegin('ref_ft', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.ref_ft))
            for iter1063 in self.ref_ft:
                oprot.writeDouble(iter1063)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 3)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 4)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 5)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.force_property is not None:
            oprot.writeFieldBegin('force_property', TType.I32, 6)
            oprot.writeI32(self.force_property)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_act_args)
fc_guard_act_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'direction', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'ref_ft', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.STRING, 'tool', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'wobj', 'UTF8', None, ),  # 4
    (5, TType.I32, 'type', None, None, ),  # 5
    (6, TType.I32, 'force_property', None, None, ),  # 6
)


class fc_guard_act_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_act_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_act_result)
fc_guard_act_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_guard_deact_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_deact_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_deact_args)
fc_guard_deact_args.thrift_spec = (
)


class fc_guard_deact_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_guard_deact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_guard_deact_result)
fc_guard_deact_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_force_set_value_args(object):
    """
    Attributes:
     - direction
     - ref_ft

    """


    def __init__(self, direction=None, ref_ft=None,):
        self.direction = direction
        self.ref_ft = ref_ft

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.direction = []
                    (_etype1067, _size1064) = iprot.readListBegin()
                    for _i1068 in range(_size1064):
                        _elem1069 = iprot.readBool()
                        self.direction.append(_elem1069)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.ref_ft = []
                    (_etype1073, _size1070) = iprot.readListBegin()
                    for _i1074 in range(_size1070):
                        _elem1075 = iprot.readDouble()
                        self.ref_ft.append(_elem1075)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_force_set_value_args')
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.LIST, 1)
            oprot.writeListBegin(TType.BOOL, len(self.direction))
            for iter1076 in self.direction:
                oprot.writeBool(iter1076)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ref_ft is not None:
            oprot.writeFieldBegin('ref_ft', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.ref_ft))
            for iter1077 in self.ref_ft:
                oprot.writeDouble(iter1077)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_force_set_value_args)
fc_force_set_value_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'direction', (TType.BOOL, None, False), None, ),  # 1
    (2, TType.LIST, 'ref_ft', (TType.DOUBLE, None, False), None, ),  # 2
)


class fc_force_set_value_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_force_set_value_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_force_set_value_result)
fc_force_set_value_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_pos_args(object):
    """
    Attributes:
     - middle
     - range
     - absolute
     - duration
     - timeout

    """


    def __init__(self, middle=None, range=None, absolute=None, duration=None, timeout=None,):
        self.middle = middle
        self.range = range
        self.absolute = absolute
        self.duration = duration
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.middle = []
                    (_etype1081, _size1078) = iprot.readListBegin()
                    for _i1082 in range(_size1078):
                        _elem1083 = iprot.readDouble()
                        self.middle.append(_elem1083)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range = []
                    (_etype1087, _size1084) = iprot.readListBegin()
                    for _i1088 in range(_size1084):
                        _elem1089 = iprot.readDouble()
                        self.range.append(_elem1089)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.absolute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.duration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_pos_args')
        if self.middle is not None:
            oprot.writeFieldBegin('middle', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.middle))
            for iter1090 in self.middle:
                oprot.writeDouble(iter1090)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.range))
            for iter1091 in self.range:
                oprot.writeDouble(iter1091)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.absolute is not None:
            oprot.writeFieldBegin('absolute', TType.BOOL, 3)
            oprot.writeBool(self.absolute)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I32, 4)
            oprot.writeI32(self.duration)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 5)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_pos_args)
fc_wait_pos_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'middle', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'range', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.BOOL, 'absolute', None, None, ),  # 3
    (4, TType.I32, 'duration', None, None, ),  # 4
    (5, TType.I32, 'timeout', None, None, ),  # 5
)


class fc_wait_pos_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_pos_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_pos_result)
fc_wait_pos_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_vel_args(object):
    """
    Attributes:
     - middle
     - range
     - absolute
     - duration
     - timeout

    """


    def __init__(self, middle=None, range=None, absolute=None, duration=None, timeout=None,):
        self.middle = middle
        self.range = range
        self.absolute = absolute
        self.duration = duration
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.middle = []
                    (_etype1095, _size1092) = iprot.readListBegin()
                    for _i1096 in range(_size1092):
                        _elem1097 = iprot.readDouble()
                        self.middle.append(_elem1097)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range = []
                    (_etype1101, _size1098) = iprot.readListBegin()
                    for _i1102 in range(_size1098):
                        _elem1103 = iprot.readDouble()
                        self.range.append(_elem1103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.absolute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.duration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_vel_args')
        if self.middle is not None:
            oprot.writeFieldBegin('middle', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.middle))
            for iter1104 in self.middle:
                oprot.writeDouble(iter1104)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.range))
            for iter1105 in self.range:
                oprot.writeDouble(iter1105)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.absolute is not None:
            oprot.writeFieldBegin('absolute', TType.BOOL, 3)
            oprot.writeBool(self.absolute)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I32, 4)
            oprot.writeI32(self.duration)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 5)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_vel_args)
fc_wait_vel_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'middle', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'range', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.BOOL, 'absolute', None, None, ),  # 3
    (4, TType.I32, 'duration', None, None, ),  # 4
    (5, TType.I32, 'timeout', None, None, ),  # 5
)


class fc_wait_vel_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_vel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_vel_result)
fc_wait_vel_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_ft_args(object):
    """
    Attributes:
     - middle
     - range
     - absolute
     - duration
     - timeout

    """


    def __init__(self, middle=None, range=None, absolute=None, duration=None, timeout=None,):
        self.middle = middle
        self.range = range
        self.absolute = absolute
        self.duration = duration
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.middle = []
                    (_etype1109, _size1106) = iprot.readListBegin()
                    for _i1110 in range(_size1106):
                        _elem1111 = iprot.readDouble()
                        self.middle.append(_elem1111)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range = []
                    (_etype1115, _size1112) = iprot.readListBegin()
                    for _i1116 in range(_size1112):
                        _elem1117 = iprot.readDouble()
                        self.range.append(_elem1117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.absolute = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.duration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.timeout = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_ft_args')
        if self.middle is not None:
            oprot.writeFieldBegin('middle', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.middle))
            for iter1118 in self.middle:
                oprot.writeDouble(iter1118)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range is not None:
            oprot.writeFieldBegin('range', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.range))
            for iter1119 in self.range:
                oprot.writeDouble(iter1119)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.absolute is not None:
            oprot.writeFieldBegin('absolute', TType.BOOL, 3)
            oprot.writeBool(self.absolute)
            oprot.writeFieldEnd()
        if self.duration is not None:
            oprot.writeFieldBegin('duration', TType.I32, 4)
            oprot.writeI32(self.duration)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I32, 5)
            oprot.writeI32(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_ft_args)
fc_wait_ft_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'middle', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'range', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.BOOL, 'absolute', None, None, ),  # 3
    (4, TType.I32, 'duration', None, None, ),  # 4
    (5, TType.I32, 'timeout', None, None, ),  # 5
)


class fc_wait_ft_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_ft_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_ft_result)
fc_wait_ft_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_wait_logic_args(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.value = []
                    (_etype1123, _size1120) = iprot.readListBegin()
                    for _i1124 in range(_size1120):
                        _elem1125 = iprot.readI32()
                        self.value.append(_elem1125)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_logic_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.value))
            for iter1126 in self.value:
                oprot.writeI32(iter1126)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_logic_args)
fc_wait_logic_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'value', (TType.I32, None, False), None, ),  # 1
)


class fc_wait_logic_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_wait_logic_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_wait_logic_result)
fc_wait_logic_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class fc_get_ft_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_get_ft_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_get_ft_args)
fc_get_ft_args.thrift_spec = (
)


class fc_get_ft_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1130, _size1127) = iprot.readListBegin()
                    for _i1131 in range(_size1127):
                        _elem1132 = iprot.readDouble()
                        self.success.append(_elem1132)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_get_ft_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1133 in self.success:
                oprot.writeDouble(iter1133)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_get_ft_result)
fc_get_ft_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class fc_mode_is_active_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_mode_is_active_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_mode_is_active_args)
fc_mode_is_active_args.thrift_spec = (
)


class fc_mode_is_active_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('fc_mode_is_active_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(fc_mode_is_active_result)
fc_mode_is_active_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class start_realtime_mode_args(object):
    """
    Attributes:
     - mode
     - fileter_bandwidth
     - com_lost_time

    """


    def __init__(self, mode=None, fileter_bandwidth=None, com_lost_time=None,):
        self.mode = mode
        self.fileter_bandwidth = fileter_bandwidth
        self.com_lost_time = com_lost_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.fileter_bandwidth = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.com_lost_time = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_realtime_mode_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 1)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.fileter_bandwidth is not None:
            oprot.writeFieldBegin('fileter_bandwidth', TType.DOUBLE, 2)
            oprot.writeDouble(self.fileter_bandwidth)
            oprot.writeFieldEnd()
        if self.com_lost_time is not None:
            oprot.writeFieldBegin('com_lost_time', TType.DOUBLE, 3)
            oprot.writeDouble(self.com_lost_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_realtime_mode_args)
start_realtime_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mode', None, None, ),  # 1
    (2, TType.DOUBLE, 'fileter_bandwidth', None, None, ),  # 2
    (3, TType.DOUBLE, 'com_lost_time', None, None, ),  # 3
)


class start_realtime_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('start_realtime_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(start_realtime_mode_result)
start_realtime_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class end_realtime_mode_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_realtime_mode_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_realtime_mode_args)
end_realtime_mode_args.thrift_spec = (
)


class end_realtime_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('end_realtime_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(end_realtime_mode_result)
end_realtime_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class realtime_data_enqueue_args(object):
    """
    Attributes:
     - realtime_data
     - block

    """


    def __init__(self, realtime_data=None, block=None,):
        self.realtime_data = realtime_data
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.realtime_data = []
                    (_etype1137, _size1134) = iprot.readListBegin()
                    for _i1138 in range(_size1134):
                        _elem1139 = RealTimeControlData()
                        _elem1139.read(iprot)
                        self.realtime_data.append(_elem1139)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('realtime_data_enqueue_args')
        if self.realtime_data is not None:
            oprot.writeFieldBegin('realtime_data', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.realtime_data))
            for iter1140 in self.realtime_data:
                iter1140.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(realtime_data_enqueue_args)
realtime_data_enqueue_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'realtime_data', (TType.STRUCT, [RealTimeControlData, None], False), None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class realtime_data_enqueue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('realtime_data_enqueue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(realtime_data_enqueue_result)
realtime_data_enqueue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class clear_realtime_data_queue_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_realtime_data_queue_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_realtime_data_queue_args)
clear_realtime_data_queue_args.thrift_spec = (
)


class clear_realtime_data_queue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('clear_realtime_data_queue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(clear_realtime_data_queue_result)
clear_realtime_data_queue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_realtime_data_queue_size_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_realtime_data_queue_size_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_realtime_data_queue_size_args)
get_realtime_data_queue_size_args.thrift_spec = (
)


class get_realtime_data_queue_size_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_realtime_data_queue_size_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_realtime_data_queue_size_result)
get_realtime_data_queue_size_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_speed_optimization_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_speed_optimization_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_speed_optimization_args)
enable_speed_optimization_args.thrift_spec = (
)


class enable_speed_optimization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_speed_optimization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_speed_optimization_result)
enable_speed_optimization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_speed_optimization_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_speed_optimization_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_speed_optimization_args)
disable_speed_optimization_args.thrift_spec = (
)


class disable_speed_optimization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_speed_optimization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_speed_optimization_result)
disable_speed_optimization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class change_recipe_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('change_recipe_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(change_recipe_args)
change_recipe_args.thrift_spec = (
)


class change_recipe_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('change_recipe_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(change_recipe_result)
change_recipe_result.thrift_spec = (
)


class set_system_value_bool_args(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_bool_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.BOOL, 2)
            oprot.writeBool(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_bool_args)
set_system_value_bool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'value', None, None, ),  # 2
)


class set_system_value_bool_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_bool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_bool_result)
set_system_value_bool_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_system_value_double_args(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_double_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 2)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_double_args)
set_system_value_double_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'value', None, None, ),  # 2
)


class set_system_value_double_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_double_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_double_result)
set_system_value_double_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_system_value_str_args(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_str_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_str_args)
set_system_value_str_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
)


class set_system_value_str_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_str_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_str_result)
set_system_value_str_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_system_value_list_args(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.value = []
                    (_etype1144, _size1141) = iprot.readListBegin()
                    for _i1145 in range(_size1141):
                        _elem1146 = iprot.readDouble()
                        self.value.append(_elem1146)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_list_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.value))
            for iter1147 in self.value:
                oprot.writeDouble(iter1147)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_list_args)
set_system_value_list_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'value', (TType.DOUBLE, None, False), None, ),  # 2
)


class set_system_value_list_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_system_value_list_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_system_value_list_result)
set_system_value_list_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_system_value_bool_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_bool_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_bool_args)
get_system_value_bool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_system_value_bool_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_bool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_bool_result)
get_system_value_bool_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class get_system_value_double_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_double_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_double_args)
get_system_value_double_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_system_value_double_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_double_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_double_result)
get_system_value_double_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class get_system_value_str_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_str_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_str_args)
get_system_value_str_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_system_value_str_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_str_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_str_result)
get_system_value_str_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_system_value_list_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_list_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_list_args)
get_system_value_list_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_system_value_list_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1151, _size1148) = iprot.readListBegin()
                    for _i1152 in range(_size1148):
                        _elem1153 = iprot.readDouble()
                        self.success.append(_elem1153)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_list_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1154 in self.success:
                oprot.writeDouble(iter1154)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_list_result)
get_system_value_list_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class trackEnqueue_args(object):
    """
    Attributes:
     - track
     - block

    """


    def __init__(self, track=None, block=None,):
        self.track = track
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.track = []
                    (_etype1158, _size1155) = iprot.readListBegin()
                    for _i1159 in range(_size1155):
                        _elem1160 = []
                        (_etype1164, _size1161) = iprot.readListBegin()
                        for _i1165 in range(_size1161):
                            _elem1166 = iprot.readDouble()
                            _elem1160.append(_elem1166)
                        iprot.readListEnd()
                        self.track.append(_elem1160)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackEnqueue_args')
        if self.track is not None:
            oprot.writeFieldBegin('track', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.track))
            for iter1167 in self.track:
                oprot.writeListBegin(TType.DOUBLE, len(iter1167))
                for iter1168 in iter1167:
                    oprot.writeDouble(iter1168)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackEnqueue_args)
trackEnqueue_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'track', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class trackEnqueue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackEnqueue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackEnqueue_result)
trackEnqueue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class trackEnqueueOp_args(object):
    """
    Attributes:
     - track
     - block

    """


    def __init__(self, track=None, block=None,):
        self.track = track
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.track = []
                    (_etype1172, _size1169) = iprot.readListBegin()
                    for _i1173 in range(_size1169):
                        _elem1174 = PointOp()
                        _elem1174.read(iprot)
                        self.track.append(_elem1174)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackEnqueueOp_args')
        if self.track is not None:
            oprot.writeFieldBegin('track', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.track))
            for iter1175 in self.track:
                iter1175.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackEnqueueOp_args)
trackEnqueueOp_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'track', (TType.STRUCT, [PointOp, None], False), None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class trackEnqueueOp_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackEnqueueOp_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackEnqueueOp_result)
trackEnqueueOp_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class trackClearQueue_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackClearQueue_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackClearQueue_args)
trackClearQueue_args.thrift_spec = (
)


class trackClearQueue_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackClearQueue_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackClearQueue_result)
trackClearQueue_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class getQueueSize_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getQueueSize_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getQueueSize_args)
getQueueSize_args.thrift_spec = (
)


class getQueueSize_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getQueueSize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getQueueSize_result)
getQueueSize_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class trackJointMotion_args(object):
    """
    Attributes:
     - speed
     - acc
     - block

    """


    def __init__(self, speed=None, acc=None, block=None,):
        self.speed = speed
        self.acc = acc
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.speed = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.acc = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackJointMotion_args')
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.DOUBLE, 1)
            oprot.writeDouble(self.speed)
            oprot.writeFieldEnd()
        if self.acc is not None:
            oprot.writeFieldBegin('acc', TType.DOUBLE, 2)
            oprot.writeDouble(self.acc)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackJointMotion_args)
trackJointMotion_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'speed', None, None, ),  # 1
    (2, TType.DOUBLE, 'acc', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class trackJointMotion_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackJointMotion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackJointMotion_result)
trackJointMotion_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class trackCartMotion_args(object):
    """
    Attributes:
     - speed
     - acc
     - block
     - tool
     - wobj
     - radius

    """


    def __init__(self, speed=None, acc=None, block=None, tool=None, wobj=None, radius=None,):
        self.speed = speed
        self.acc = acc
        self.block = block
        self.tool = tool
        self.wobj = wobj
        self.radius = radius

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.speed = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.acc = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.radius = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackCartMotion_args')
        if self.speed is not None:
            oprot.writeFieldBegin('speed', TType.DOUBLE, 1)
            oprot.writeDouble(self.speed)
            oprot.writeFieldEnd()
        if self.acc is not None:
            oprot.writeFieldBegin('acc', TType.DOUBLE, 2)
            oprot.writeDouble(self.acc)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 4)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 5)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.radius is not None:
            oprot.writeFieldBegin('radius', TType.DOUBLE, 6)
            oprot.writeDouble(self.radius)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackCartMotion_args)
trackCartMotion_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'speed', None, None, ),  # 1
    (2, TType.DOUBLE, 'acc', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
    (4, TType.STRING, 'tool', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'wobj', 'UTF8', None, ),  # 5
    (6, TType.DOUBLE, 'radius', None, None, ),  # 6
)


class trackCartMotion_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('trackCartMotion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(trackCartMotion_result)
trackCartMotion_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class rpc_heartbeat_args(object):
    """
    Attributes:
     - time

    """


    def __init__(self, time=None,):
        self.time = time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.time = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rpc_heartbeat_args')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I32, 1)
            oprot.writeI32(self.time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rpc_heartbeat_args)
rpc_heartbeat_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'time', None, None, ),  # 1
)


class rpc_heartbeat_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('rpc_heartbeat_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(rpc_heartbeat_result)
rpc_heartbeat_result.thrift_spec = (
)


class move_spiral_args(object):
    """
    Attributes:
     - p1
     - p2
     - rev
     - len
     - r
     - mode
     - v
     - a
     - q_near
     - tool
     - wobj
     - block
     - op
     - def_acc

    """


    def __init__(self, p1=None, p2=None, rev=None, len=None, r=None, mode=None, v=None, a=None, q_near=None, tool=None, wobj=None, block=None, op=None, def_acc=None,):
        self.p1 = p1
        self.p2 = p2
        self.rev = rev
        self.len = len
        self.r = r
        self.mode = mode
        self.v = v
        self.a = a
        self.q_near = q_near
        self.tool = tool
        self.wobj = wobj
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype1179, _size1176) = iprot.readListBegin()
                    for _i1180 in range(_size1176):
                        _elem1181 = iprot.readDouble()
                        self.p1.append(_elem1181)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype1185, _size1182) = iprot.readListBegin()
                    for _i1186 in range(_size1182):
                        _elem1187 = iprot.readDouble()
                        self.p2.append(_elem1187)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.rev = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.len = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.r = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.q_near = []
                    (_etype1191, _size1188) = iprot.readListBegin()
                    for _i1192 in range(_size1188):
                        _elem1193 = iprot.readDouble()
                        self.q_near.append(_elem1193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_spiral_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter1194 in self.p1:
                oprot.writeDouble(iter1194)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter1195 in self.p2:
                oprot.writeDouble(iter1195)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.rev is not None:
            oprot.writeFieldBegin('rev', TType.DOUBLE, 3)
            oprot.writeDouble(self.rev)
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.DOUBLE, 4)
            oprot.writeDouble(self.len)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin('r', TType.DOUBLE, 5)
            oprot.writeDouble(self.r)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 6)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 7)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 8)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.q_near is not None:
            oprot.writeFieldBegin('q_near', TType.LIST, 9)
            oprot.writeListBegin(TType.DOUBLE, len(self.q_near))
            for iter1196 in self.q_near:
                oprot.writeDouble(iter1196)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 10)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 11)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 12)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 13)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 14)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_spiral_args)
move_spiral_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'rev', None, None, ),  # 3
    (4, TType.DOUBLE, 'len', None, None, ),  # 4
    (5, TType.DOUBLE, 'r', None, None, ),  # 5
    (6, TType.I32, 'mode', None, None, ),  # 6
    (7, TType.DOUBLE, 'v', None, None, ),  # 7
    (8, TType.DOUBLE, 'a', None, None, ),  # 8
    (9, TType.LIST, 'q_near', (TType.DOUBLE, None, False), None, ),  # 9
    (10, TType.STRING, 'tool', 'UTF8', None, ),  # 10
    (11, TType.STRING, 'wobj', 'UTF8', None, ),  # 11
    (12, TType.BOOL, 'block', None, None, ),  # 12
    (13, TType.STRUCT, 'op', [Op, None], None, ),  # 13
    (14, TType.BOOL, 'def_acc', None, None, ),  # 14
)


class move_spiral_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_spiral_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_spiral_result)
move_spiral_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_acc_optimization_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_acc_optimization_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_acc_optimization_args)
enable_acc_optimization_args.thrift_spec = (
)


class enable_acc_optimization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_acc_optimization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_acc_optimization_result)
enable_acc_optimization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_acc_optimization_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_acc_optimization_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_acc_optimization_args)
disable_acc_optimization_args.thrift_spec = (
)


class disable_acc_optimization_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_acc_optimization_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_acc_optimization_result)
disable_acc_optimization_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_baudrate_485_args(object):
    """
    Attributes:
     - value
     - block

    """


    def __init__(self, value=None, block=None,):
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_baudrate_485_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 1)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_baudrate_485_args)
set_baudrate_485_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'value', None, None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class set_baudrate_485_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_baudrate_485_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_baudrate_485_result)
set_baudrate_485_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_baudrate_can_args(object):
    """
    Attributes:
     - value
     - block

    """


    def __init__(self, value=None, block=None,):
        self.value = value
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_baudrate_can_args')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 1)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_baudrate_can_args)
set_baudrate_can_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'value', None, None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class set_baudrate_can_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_baudrate_can_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_baudrate_can_result)
set_baudrate_can_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_analog_output_mode_args(object):
    """
    Attributes:
     - num
     - mode
     - block

    """


    def __init__(self, num=None, mode=None, block=None,):
        self.num = num
        self.mode = mode
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.num = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_analog_output_mode_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I16, 1)
            oprot.writeI16(self.num)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 2)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_analog_output_mode_args)
set_analog_output_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'num', None, None, ),  # 1
    (2, TType.I32, 'mode', None, None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_analog_output_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_analog_output_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_analog_output_mode_result)
set_analog_output_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class robotmoving_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('robotmoving_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(robotmoving_args)
robotmoving_args.thrift_spec = (
)


class robotmoving_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('robotmoving_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(robotmoving_result)
robotmoving_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class modbus_write_multiple_coils_args(object):
    """
    Attributes:
     - slave_num
     - name
     - len
     - byte_list

    """


    def __init__(self, slave_num=None, name=None, len=None, byte_list=None,):
        self.slave_num = slave_num
        self.name = name
        self.len = len
        self.byte_list = byte_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.byte_list = []
                    (_etype1200, _size1197) = iprot.readListBegin()
                    for _i1201 in range(_size1197):
                        _elem1202 = iprot.readByte()
                        self.byte_list.append(_elem1202)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_multiple_coils_args')
        if self.slave_num is not None:
            oprot.writeFieldBegin('slave_num', TType.I32, 1)
            oprot.writeI32(self.slave_num)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 3)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        if self.byte_list is not None:
            oprot.writeFieldBegin('byte_list', TType.LIST, 4)
            oprot.writeListBegin(TType.BYTE, len(self.byte_list))
            for iter1203 in self.byte_list:
                oprot.writeByte(iter1203)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_multiple_coils_args)
modbus_write_multiple_coils_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_num', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'len', None, None, ),  # 3
    (4, TType.LIST, 'byte_list', (TType.BYTE, None, False), None, ),  # 4
)


class modbus_write_multiple_coils_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_multiple_coils_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_multiple_coils_result)
modbus_write_multiple_coils_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class modbus_write_multiple_regs_args(object):
    """
    Attributes:
     - slave_num
     - name
     - len
     - word_list

    """


    def __init__(self, slave_num=None, name=None, len=None, word_list=None,):
        self.slave_num = slave_num
        self.name = name
        self.len = len
        self.word_list = word_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.slave_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.word_list = []
                    (_etype1207, _size1204) = iprot.readListBegin()
                    for _i1208 in range(_size1204):
                        _elem1209 = iprot.readI16()
                        self.word_list.append(_elem1209)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_multiple_regs_args')
        if self.slave_num is not None:
            oprot.writeFieldBegin('slave_num', TType.I32, 1)
            oprot.writeI32(self.slave_num)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.len is not None:
            oprot.writeFieldBegin('len', TType.I32, 3)
            oprot.writeI32(self.len)
            oprot.writeFieldEnd()
        if self.word_list is not None:
            oprot.writeFieldBegin('word_list', TType.LIST, 4)
            oprot.writeListBegin(TType.I16, len(self.word_list))
            for iter1210 in self.word_list:
                oprot.writeI16(iter1210)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_multiple_regs_args)
modbus_write_multiple_regs_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'slave_num', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'len', None, None, ),  # 3
    (4, TType.LIST, 'word_list', (TType.I16, None, False), None, ),  # 4
)


class modbus_write_multiple_regs_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('modbus_write_multiple_regs_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(modbus_write_multiple_regs_result)
modbus_write_multiple_regs_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_current_project_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_current_project_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_current_project_args)
get_current_project_args.thrift_spec = (
)


class get_current_project_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_current_project_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_current_project_result)
get_current_project_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class get_files_list_args(object):
    """
    Attributes:
     - path

    """


    def __init__(self, path=None,):
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_files_list_args')
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 1)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_files_list_args)
get_files_list_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'path', 'UTF8', None, ),  # 1
)


class get_files_list_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype1212, _vtype1213, _size1211) = iprot.readMapBegin()
                    for _i1215 in range(_size1211):
                        _key1216 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val1217 = iprot.readI32()
                        self.success[_key1216] = _val1217
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_files_list_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.success))
            for kiter1218, viter1219 in self.success.items():
                oprot.writeString(kiter1218.encode('utf-8') if sys.version_info[0] == 2 else kiter1218)
                oprot.writeI32(viter1219)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_files_list_result)
get_files_list_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 0
)


class getRobotStatus_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRobotStatus_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRobotStatus_args)
getRobotStatus_args.thrift_spec = (
)


class getRobotStatus_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = RobotStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRobotStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRobotStatus_result)
getRobotStatus_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [RobotStatus, None], None, ),  # 0
)


class getRobotIOStatus_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRobotIOStatus_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRobotIOStatus_args)
getRobotIOStatus_args.thrift_spec = (
)


class getRobotIOStatus_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = IOStatus()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getRobotIOStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getRobotIOStatus_result)
getRobotIOStatus_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [IOStatus, None], None, ),  # 0
)


class get_tcp_pose_coord_args(object):
    """
    Attributes:
     - tool
     - wobj

    """


    def __init__(self, tool=None, wobj=None,):
        self.tool = tool
        self.wobj = wobj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_pose_coord_args')
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 1)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 2)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_pose_coord_args)
get_tcp_pose_coord_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tool', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'wobj', 'UTF8', None, ),  # 2
)


class get_tcp_pose_coord_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1223, _size1220) = iprot.readListBegin()
                    for _i1224 in range(_size1220):
                        _elem1225 = iprot.readDouble()
                        self.success.append(_elem1225)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_pose_coord_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1226 in self.success:
                oprot.writeDouble(iter1226)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_pose_coord_result)
get_tcp_pose_coord_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_tcp_force_tool_args(object):
    """
    Attributes:
     - tool

    """


    def __init__(self, tool=None,):
        self.tool = tool

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_force_tool_args')
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 1)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_force_tool_args)
get_tcp_force_tool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tool', 'UTF8', None, ),  # 1
)


class get_tcp_force_tool_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1230, _size1227) = iprot.readListBegin()
                    for _i1231 in range(_size1227):
                        _elem1232 = iprot.readDouble()
                        self.success.append(_elem1232)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_tcp_force_tool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1233 in self.success:
                oprot.writeDouble(iter1233)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_tcp_force_tool_result)
get_tcp_force_tool_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class restart_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restart_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restart_args)
restart_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class restart_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('restart_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(restart_result)
restart_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_servo_config_args(object):
    """
    Attributes:
     - axis_num
     - id
     - value
     - qfmt
     - block

    """


    def __init__(self, axis_num=None, id=None, value=None, qfmt=None, block=None,):
        self.axis_num = axis_num
        self.id = id
        self.value = value
        self.qfmt = qfmt
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.axis_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.value = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.qfmt = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_servo_config_args')
        if self.axis_num is not None:
            oprot.writeFieldBegin('axis_num', TType.I32, 1)
            oprot.writeI32(self.axis_num)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I32, 3)
            oprot.writeI32(self.value)
            oprot.writeFieldEnd()
        if self.qfmt is not None:
            oprot.writeFieldBegin('qfmt', TType.I32, 4)
            oprot.writeI32(self.qfmt)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 5)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_servo_config_args)
set_servo_config_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'axis_num', None, None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.I32, 'value', None, None, ),  # 3
    (4, TType.I32, 'qfmt', None, None, ),  # 4
    (5, TType.BOOL, 'block', None, None, ),  # 5
)


class set_servo_config_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_servo_config_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_servo_config_result)
set_servo_config_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class apply_servo_config_args(object):
    """
    Attributes:
     - axis_num
     - block

    """


    def __init__(self, axis_num=None, block=None,):
        self.axis_num = axis_num
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.axis_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('apply_servo_config_args')
        if self.axis_num is not None:
            oprot.writeFieldBegin('axis_num', TType.I32, 1)
            oprot.writeI32(self.axis_num)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(apply_servo_config_args)
apply_servo_config_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'axis_num', None, None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class apply_servo_config_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('apply_servo_config_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(apply_servo_config_result)
apply_servo_config_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_motor_pole_pair_number_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_motor_pole_pair_number_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_motor_pole_pair_number_args)
get_motor_pole_pair_number_args.thrift_spec = (
)


class get_motor_pole_pair_number_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1237, _size1234) = iprot.readListBegin()
                    for _i1238 in range(_size1234):
                        _elem1239 = iprot.readI16()
                        self.success.append(_elem1239)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_motor_pole_pair_number_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter1240 in self.success:
                oprot.writeI16(iter1240)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_motor_pole_pair_number_result)
get_motor_pole_pair_number_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
)


class get_motor_stator_slots_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_motor_stator_slots_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_motor_stator_slots_args)
get_motor_stator_slots_args.thrift_spec = (
)


class get_motor_stator_slots_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1244, _size1241) = iprot.readListBegin()
                    for _i1245 in range(_size1241):
                        _elem1246 = iprot.readI16()
                        self.success.append(_elem1246)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_motor_stator_slots_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter1247 in self.success:
                oprot.writeI16(iter1247)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_motor_stator_slots_result)
get_motor_stator_slots_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
)


class get_axis_ratio_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_axis_ratio_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_axis_ratio_args)
get_axis_ratio_args.thrift_spec = (
)


class get_axis_ratio_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1251, _size1248) = iprot.readListBegin()
                    for _i1252 in range(_size1248):
                        _elem1253 = iprot.readI16()
                        self.success.append(_elem1253)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_axis_ratio_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I16, len(self.success))
            for iter1254 in self.success:
                oprot.writeI16(iter1254)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_axis_ratio_result)
get_axis_ratio_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I16, None, False), None, ),  # 0
)


class collision_detection_reset_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('collision_detection_reset_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(collision_detection_reset_args)
collision_detection_reset_args.thrift_spec = (
)


class collision_detection_reset_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('collision_detection_reset_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(collision_detection_reset_result)
collision_detection_reset_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_servo_file_params_args(object):
    """
    Attributes:
     - axis_num
     - id
     - name
     - value
     - qfmt

    """


    def __init__(self, axis_num=None, id=None, name=None, value=None, qfmt=None,):
        self.axis_num = axis_num
        self.id = id
        self.name = name
        self.value = value
        self.qfmt = qfmt

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.axis_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.qfmt = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_servo_file_params_args')
        if self.axis_num is not None:
            oprot.writeFieldBegin('axis_num', TType.I32, 1)
            oprot.writeI32(self.axis_num)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 2)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 3)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.DOUBLE, 4)
            oprot.writeDouble(self.value)
            oprot.writeFieldEnd()
        if self.qfmt is not None:
            oprot.writeFieldBegin('qfmt', TType.DOUBLE, 5)
            oprot.writeDouble(self.qfmt)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_servo_file_params_args)
set_servo_file_params_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'axis_num', None, None, ),  # 1
    (2, TType.I32, 'id', None, None, ),  # 2
    (3, TType.STRING, 'name', 'UTF8', None, ),  # 3
    (4, TType.DOUBLE, 'value', None, None, ),  # 4
    (5, TType.DOUBLE, 'qfmt', None, None, ),  # 5
)


class set_servo_file_params_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_servo_file_params_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_servo_file_params_result)
set_servo_file_params_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class combine_motion_config_args(object):
    """
    Attributes:
     - type
     - ref_plane
     - fq
     - amp
     - el_offset
     - az_offset
     - up_height
     - time
     - path_dwell
     - op_list

    """


    def __init__(self, type=None, ref_plane=None, fq=None, amp=None, el_offset=None, az_offset=None, up_height=None, time=None, path_dwell=None, op_list=None,):
        self.type = type
        self.ref_plane = ref_plane
        self.fq = fq
        self.amp = amp
        self.el_offset = el_offset
        self.az_offset = az_offset
        self.up_height = up_height
        self.time = time
        self.path_dwell = path_dwell
        self.op_list = op_list

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.ref_plane = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.fq = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.amp = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.el_offset = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.az_offset = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.up_height = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.time = []
                    (_etype1258, _size1255) = iprot.readListBegin()
                    for _i1259 in range(_size1255):
                        _elem1260 = iprot.readI32()
                        self.time.append(_elem1260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.path_dwell = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.op_list = []
                    (_etype1264, _size1261) = iprot.readListBegin()
                    for _i1265 in range(_size1261):
                        _elem1266 = Op()
                        _elem1266.read(iprot)
                        self.op_list.append(_elem1266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('combine_motion_config_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.ref_plane is not None:
            oprot.writeFieldBegin('ref_plane', TType.I32, 2)
            oprot.writeI32(self.ref_plane)
            oprot.writeFieldEnd()
        if self.fq is not None:
            oprot.writeFieldBegin('fq', TType.DOUBLE, 3)
            oprot.writeDouble(self.fq)
            oprot.writeFieldEnd()
        if self.amp is not None:
            oprot.writeFieldBegin('amp', TType.DOUBLE, 4)
            oprot.writeDouble(self.amp)
            oprot.writeFieldEnd()
        if self.el_offset is not None:
            oprot.writeFieldBegin('el_offset', TType.DOUBLE, 5)
            oprot.writeDouble(self.el_offset)
            oprot.writeFieldEnd()
        if self.az_offset is not None:
            oprot.writeFieldBegin('az_offset', TType.DOUBLE, 6)
            oprot.writeDouble(self.az_offset)
            oprot.writeFieldEnd()
        if self.up_height is not None:
            oprot.writeFieldBegin('up_height', TType.DOUBLE, 7)
            oprot.writeDouble(self.up_height)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.LIST, 8)
            oprot.writeListBegin(TType.I32, len(self.time))
            for iter1267 in self.time:
                oprot.writeI32(iter1267)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.path_dwell is not None:
            oprot.writeFieldBegin('path_dwell', TType.BOOL, 9)
            oprot.writeBool(self.path_dwell)
            oprot.writeFieldEnd()
        if self.op_list is not None:
            oprot.writeFieldBegin('op_list', TType.LIST, 10)
            oprot.writeListBegin(TType.STRUCT, len(self.op_list))
            for iter1268 in self.op_list:
                iter1268.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(combine_motion_config_args)
combine_motion_config_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I32, 'ref_plane', None, None, ),  # 2
    (3, TType.DOUBLE, 'fq', None, None, ),  # 3
    (4, TType.DOUBLE, 'amp', None, None, ),  # 4
    (5, TType.DOUBLE, 'el_offset', None, None, ),  # 5
    (6, TType.DOUBLE, 'az_offset', None, None, ),  # 6
    (7, TType.DOUBLE, 'up_height', None, None, ),  # 7
    (8, TType.LIST, 'time', (TType.I32, None, False), None, ),  # 8
    (9, TType.BOOL, 'path_dwell', None, None, ),  # 9
    (10, TType.LIST, 'op_list', (TType.STRUCT, [Op, None], False), None, ),  # 10
)


class combine_motion_config_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('combine_motion_config_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(combine_motion_config_result)
combine_motion_config_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_eaxis_param_args(object):
    """
    Attributes:
     - num
     - param
     - block

    """


    def __init__(self, num=None, param=None, block=None,):
        self.num = num
        self.param = param
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.param = EAxisParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_eaxis_param_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 1)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 2)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_eaxis_param_args)
set_eaxis_param_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num', None, None, ),  # 1
    (2, TType.STRUCT, 'param', [EAxisParam, None], None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_eaxis_param_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_eaxis_param_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_eaxis_param_result)
set_eaxis_param_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class add_eaxis_scheme_args(object):
    """
    Attributes:
     - num
     - block

    """


    def __init__(self, num=None, block=None,):
        self.num = num
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_eaxis_scheme_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 1)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_eaxis_scheme_args)
add_eaxis_scheme_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class add_eaxis_scheme_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('add_eaxis_scheme_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(add_eaxis_scheme_result)
add_eaxis_scheme_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class delete_eaxis_scheme_args(object):
    """
    Attributes:
     - num
     - block

    """


    def __init__(self, num=None, block=None,):
        self.num = num
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_eaxis_scheme_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 1)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_eaxis_scheme_args)
delete_eaxis_scheme_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num', None, None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class delete_eaxis_scheme_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('delete_eaxis_scheme_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(delete_eaxis_scheme_result)
delete_eaxis_scheme_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_eaxis_scheme_args(object):
    """
    Attributes:
     - scheme_name

    """


    def __init__(self, scheme_name=None,):
        self.scheme_name = scheme_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_eaxis_scheme_args')
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 1)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_eaxis_scheme_args)
enable_eaxis_scheme_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 1
)


class enable_eaxis_scheme_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_eaxis_scheme_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_eaxis_scheme_result)
enable_eaxis_scheme_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_eaxis_scheme_args(object):
    """
    Attributes:
     - scheme_name

    """


    def __init__(self, scheme_name=None,):
        self.scheme_name = scheme_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_eaxis_scheme_args')
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 1)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_eaxis_scheme_args)
disable_eaxis_scheme_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 1
)


class disable_eaxis_scheme_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_eaxis_scheme_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_eaxis_scheme_result)
disable_eaxis_scheme_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_eaxiss_scheme_param_args(object):
    """
    Attributes:
     - num
     - param
     - block

    """


    def __init__(self, num=None, param=None, block=None,):
        self.num = num
        self.param = param
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.param = EAxisSchemeParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_eaxiss_scheme_param_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 1)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 2)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 3)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_eaxiss_scheme_param_args)
set_eaxiss_scheme_param_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num', None, None, ),  # 1
    (2, TType.STRUCT, 'param', [EAxisSchemeParam, None], None, ),  # 2
    (3, TType.BOOL, 'block', None, None, ),  # 3
)


class set_eaxiss_scheme_param_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_eaxiss_scheme_param_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_eaxiss_scheme_param_result)
set_eaxiss_scheme_param_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class move_jog_args(object):
    """
    Attributes:
     - param
     - block

    """


    def __init__(self, param=None, block=None,):
        self.param = param
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.param = MoveJogTaskParam()
                    self.param.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_jog_args')
        if self.param is not None:
            oprot.writeFieldBegin('param', TType.STRUCT, 1)
            self.param.write(oprot)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 2)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_jog_args)
move_jog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'param', [MoveJogTaskParam, None], None, ),  # 1
    (2, TType.BOOL, 'block', None, None, ),  # 2
)


class move_jog_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_jog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_jog_result)
move_jog_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class stop_manual_move_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_manual_move_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_manual_move_args)
stop_manual_move_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class stop_manual_move_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('stop_manual_move_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(stop_manual_move_result)
stop_manual_move_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_robot_version_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_version_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_version_args)
get_robot_version_args.thrift_spec = (
)


class get_robot_version_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_version_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_version_result)
get_robot_version_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class set_teach_pendant_args(object):
    """
    Attributes:
     - enable

    """


    def __init__(self, enable=None,):
        self.enable = enable

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_teach_pendant_args')
        if self.enable is not None:
            oprot.writeFieldBegin('enable', TType.BOOL, 1)
            oprot.writeBool(self.enable)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_teach_pendant_args)
set_teach_pendant_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enable', None, None, ),  # 1
)


class set_teach_pendant_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_teach_pendant_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_teach_pendant_result)
set_teach_pendant_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_teach_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_teach_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_teach_speed_args)
get_teach_speed_args.thrift_spec = (
)


class get_teach_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_teach_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_teach_speed_result)
get_teach_speed_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_global_speed_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_global_speed_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_global_speed_args)
get_global_speed_args.thrift_spec = (
)


class get_global_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_global_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_global_speed_result)
get_global_speed_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_teach_speed_args(object):
    """
    Attributes:
     - v

    """


    def __init__(self, v=None,):
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.v = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_teach_speed_args')
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I32, 1)
            oprot.writeI32(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_teach_speed_args)
set_teach_speed_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'v', None, None, ),  # 1
)


class set_teach_speed_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_teach_speed_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_teach_speed_result)
set_teach_speed_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_combine_motion_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_combine_motion_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_combine_motion_args)
enable_combine_motion_args.thrift_spec = (
)


class enable_combine_motion_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_combine_motion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_combine_motion_result)
enable_combine_motion_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_combine_motion_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_combine_motion_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_combine_motion_args)
disable_combine_motion_args.thrift_spec = (
)


class disable_combine_motion_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_combine_motion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_combine_motion_result)
disable_combine_motion_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_singularity_control_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_singularity_control_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_singularity_control_args)
enable_singularity_control_args.thrift_spec = (
)


class enable_singularity_control_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_singularity_control_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_singularity_control_result)
enable_singularity_control_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_singularity_control_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_singularity_control_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_singularity_control_args)
disable_singularity_control_args.thrift_spec = (
)


class disable_singularity_control_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_singularity_control_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_singularity_control_result)
disable_singularity_control_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class enable_vibration_control_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_vibration_control_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_vibration_control_args)
enable_vibration_control_args.thrift_spec = (
)


class enable_vibration_control_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('enable_vibration_control_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(enable_vibration_control_result)
enable_vibration_control_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class disable_vibration_control_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_vibration_control_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_vibration_control_args)
disable_vibration_control_args.thrift_spec = (
)


class disable_vibration_control_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('disable_vibration_control_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(disable_vibration_control_result)
disable_vibration_control_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class move_eaxis_args(object):
    """
    Attributes:
     - scheme_name
     - epose
     - v
     - block
     - op

    """


    def __init__(self, scheme_name=None, epose=None, v=None, block=None, op=None,):
        self.scheme_name = scheme_name
        self.epose = epose
        self.v = v
        self.block = block
        self.op = op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.epose = []
                    (_etype1272, _size1269) = iprot.readListBegin()
                    for _i1273 in range(_size1269):
                        _elem1274 = iprot.readDouble()
                        self.epose.append(_elem1274)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_eaxis_args')
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 1)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        if self.epose is not None:
            oprot.writeFieldBegin('epose', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.epose))
            for iter1275 in self.epose:
                oprot.writeDouble(iter1275)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 4)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 5)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_eaxis_args)
move_eaxis_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'epose', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.BOOL, 'block', None, None, ),  # 4
    (5, TType.STRUCT, 'op', [Op, None], None, ),  # 5
)


class move_eaxis_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_eaxis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_eaxis_result)
move_eaxis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej2_eaxis_args(object):
    """
    Attributes:
     - joints_list
     - v
     - a
     - rad
     - scheme_name
     - epose
     - eaxis_v
     - block
     - op
     - def_acc

    """


    def __init__(self, joints_list=None, v=None, a=None, rad=None, scheme_name=None, epose=None, eaxis_v=None, block=None, op=None, def_acc=None,):
        self.joints_list = joints_list
        self.v = v
        self.a = a
        self.rad = rad
        self.scheme_name = scheme_name
        self.epose = epose
        self.eaxis_v = eaxis_v
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.joints_list = []
                    (_etype1279, _size1276) = iprot.readListBegin()
                    for _i1280 in range(_size1276):
                        _elem1281 = iprot.readDouble()
                        self.joints_list.append(_elem1281)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.rad = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.epose = []
                    (_etype1285, _size1282) = iprot.readListBegin()
                    for _i1286 in range(_size1282):
                        _elem1287 = iprot.readDouble()
                        self.epose.append(_elem1287)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.eaxis_v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_eaxis_args')
        if self.joints_list is not None:
            oprot.writeFieldBegin('joints_list', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.joints_list))
            for iter1288 in self.joints_list:
                oprot.writeDouble(iter1288)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.rad is not None:
            oprot.writeFieldBegin('rad', TType.DOUBLE, 4)
            oprot.writeDouble(self.rad)
            oprot.writeFieldEnd()
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 5)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        if self.epose is not None:
            oprot.writeFieldBegin('epose', TType.LIST, 6)
            oprot.writeListBegin(TType.DOUBLE, len(self.epose))
            for iter1289 in self.epose:
                oprot.writeDouble(iter1289)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.eaxis_v is not None:
            oprot.writeFieldBegin('eaxis_v', TType.DOUBLE, 7)
            oprot.writeDouble(self.eaxis_v)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 8)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 9)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 10)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_eaxis_args)
movej2_eaxis_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'joints_list', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'rad', None, None, ),  # 4
    (5, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 5
    (6, TType.LIST, 'epose', (TType.DOUBLE, None, False), None, ),  # 6
    (7, TType.DOUBLE, 'eaxis_v', None, None, ),  # 7
    (8, TType.BOOL, 'block', None, None, ),  # 8
    (9, TType.STRUCT, 'op', [Op, None], None, ),  # 9
    (10, TType.BOOL, 'def_acc', None, None, ),  # 10
)


class movej2_eaxis_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_eaxis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_eaxis_result)
movej2_eaxis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movej2_pose_eaxis_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - rad
     - qnear
     - tool
     - wobj
     - scheme_name
     - epose
     - eaxis_v
     - block
     - op
     - def_acc

    """


    def __init__(self, p=None, v=None, a=None, rad=None, qnear=None, tool=None, wobj=None, scheme_name=None, epose=None, eaxis_v=None, block=None, op=None, def_acc=None,):
        self.p = p
        self.v = v
        self.a = a
        self.rad = rad
        self.qnear = qnear
        self.tool = tool
        self.wobj = wobj
        self.scheme_name = scheme_name
        self.epose = epose
        self.eaxis_v = eaxis_v
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype1293, _size1290) = iprot.readListBegin()
                    for _i1294 in range(_size1290):
                        _elem1295 = iprot.readDouble()
                        self.p.append(_elem1295)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.rad = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.qnear = []
                    (_etype1299, _size1296) = iprot.readListBegin()
                    for _i1300 in range(_size1296):
                        _elem1301 = iprot.readDouble()
                        self.qnear.append(_elem1301)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.epose = []
                    (_etype1305, _size1302) = iprot.readListBegin()
                    for _i1306 in range(_size1302):
                        _elem1307 = iprot.readDouble()
                        self.epose.append(_elem1307)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.eaxis_v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_pose_eaxis_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter1308 in self.p:
                oprot.writeDouble(iter1308)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.rad is not None:
            oprot.writeFieldBegin('rad', TType.DOUBLE, 4)
            oprot.writeDouble(self.rad)
            oprot.writeFieldEnd()
        if self.qnear is not None:
            oprot.writeFieldBegin('qnear', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.qnear))
            for iter1309 in self.qnear:
                oprot.writeDouble(iter1309)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 8)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        if self.epose is not None:
            oprot.writeFieldBegin('epose', TType.LIST, 9)
            oprot.writeListBegin(TType.DOUBLE, len(self.epose))
            for iter1310 in self.epose:
                oprot.writeDouble(iter1310)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.eaxis_v is not None:
            oprot.writeFieldBegin('eaxis_v', TType.DOUBLE, 10)
            oprot.writeDouble(self.eaxis_v)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 11)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 12)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 13)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_pose_eaxis_args)
movej2_pose_eaxis_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'rad', None, None, ),  # 4
    (5, TType.LIST, 'qnear', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 8
    (9, TType.LIST, 'epose', (TType.DOUBLE, None, False), None, ),  # 9
    (10, TType.DOUBLE, 'eaxis_v', None, None, ),  # 10
    (11, TType.BOOL, 'block', None, None, ),  # 11
    (12, TType.STRUCT, 'op', [Op, None], None, ),  # 12
    (13, TType.BOOL, 'def_acc', None, None, ),  # 13
)


class movej2_pose_eaxis_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movej2_pose_eaxis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movej2_pose_eaxis_result)
movej2_pose_eaxis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movel_eaxis_args(object):
    """
    Attributes:
     - p
     - v
     - a
     - rad
     - qnear
     - tool
     - wobj
     - scheme_name
     - epose
     - eaxis_v
     - block
     - op
     - def_acc

    """


    def __init__(self, p=None, v=None, a=None, rad=None, qnear=None, tool=None, wobj=None, scheme_name=None, epose=None, eaxis_v=None, block=None, op=None, def_acc=None,):
        self.p = p
        self.v = v
        self.a = a
        self.rad = rad
        self.qnear = qnear
        self.tool = tool
        self.wobj = wobj
        self.scheme_name = scheme_name
        self.epose = epose
        self.eaxis_v = eaxis_v
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p = []
                    (_etype1314, _size1311) = iprot.readListBegin()
                    for _i1315 in range(_size1311):
                        _elem1316 = iprot.readDouble()
                        self.p.append(_elem1316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.rad = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.qnear = []
                    (_etype1320, _size1317) = iprot.readListBegin()
                    for _i1321 in range(_size1317):
                        _elem1322 = iprot.readDouble()
                        self.qnear.append(_elem1322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.epose = []
                    (_etype1326, _size1323) = iprot.readListBegin()
                    for _i1327 in range(_size1323):
                        _elem1328 = iprot.readDouble()
                        self.epose.append(_elem1328)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.eaxis_v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movel_eaxis_args')
        if self.p is not None:
            oprot.writeFieldBegin('p', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p))
            for iter1329 in self.p:
                oprot.writeDouble(iter1329)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 3)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.rad is not None:
            oprot.writeFieldBegin('rad', TType.DOUBLE, 4)
            oprot.writeDouble(self.rad)
            oprot.writeFieldEnd()
        if self.qnear is not None:
            oprot.writeFieldBegin('qnear', TType.LIST, 5)
            oprot.writeListBegin(TType.DOUBLE, len(self.qnear))
            for iter1330 in self.qnear:
                oprot.writeDouble(iter1330)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 6)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 7)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 8)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        if self.epose is not None:
            oprot.writeFieldBegin('epose', TType.LIST, 9)
            oprot.writeListBegin(TType.DOUBLE, len(self.epose))
            for iter1331 in self.epose:
                oprot.writeDouble(iter1331)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.eaxis_v is not None:
            oprot.writeFieldBegin('eaxis_v', TType.DOUBLE, 10)
            oprot.writeDouble(self.eaxis_v)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 11)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 12)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 13)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movel_eaxis_args)
movel_eaxis_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
    (3, TType.DOUBLE, 'a', None, None, ),  # 3
    (4, TType.DOUBLE, 'rad', None, None, ),  # 4
    (5, TType.LIST, 'qnear', (TType.DOUBLE, None, False), None, ),  # 5
    (6, TType.STRING, 'tool', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'wobj', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 8
    (9, TType.LIST, 'epose', (TType.DOUBLE, None, False), None, ),  # 9
    (10, TType.DOUBLE, 'eaxis_v', None, None, ),  # 10
    (11, TType.BOOL, 'block', None, None, ),  # 11
    (12, TType.STRUCT, 'op', [Op, None], None, ),  # 12
    (13, TType.BOOL, 'def_acc', None, None, ),  # 13
)


class movel_eaxis_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movel_eaxis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movel_eaxis_result)
movel_eaxis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class movec_eaxis_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - rad
     - qnear
     - tool
     - wobj
     - scheme_name
     - epose
     - eaxis_v
     - block
     - op
     - def_acc
     - mode

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, rad=None, qnear=None, tool=None, wobj=None, scheme_name=None, epose=None, eaxis_v=None, block=None, op=None, def_acc=None, mode=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.rad = rad
        self.qnear = qnear
        self.tool = tool
        self.wobj = wobj
        self.scheme_name = scheme_name
        self.epose = epose
        self.eaxis_v = eaxis_v
        self.block = block
        self.op = op
        self.def_acc = def_acc
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype1335, _size1332) = iprot.readListBegin()
                    for _i1336 in range(_size1332):
                        _elem1337 = iprot.readDouble()
                        self.p1.append(_elem1337)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype1341, _size1338) = iprot.readListBegin()
                    for _i1342 in range(_size1338):
                        _elem1343 = iprot.readDouble()
                        self.p2.append(_elem1343)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.rad = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.qnear = []
                    (_etype1347, _size1344) = iprot.readListBegin()
                    for _i1348 in range(_size1344):
                        _elem1349 = iprot.readDouble()
                        self.qnear.append(_elem1349)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.epose = []
                    (_etype1353, _size1350) = iprot.readListBegin()
                    for _i1354 in range(_size1350):
                        _elem1355 = iprot.readDouble()
                        self.epose.append(_elem1355)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.eaxis_v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movec_eaxis_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter1356 in self.p1:
                oprot.writeDouble(iter1356)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter1357 in self.p2:
                oprot.writeDouble(iter1357)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.rad is not None:
            oprot.writeFieldBegin('rad', TType.DOUBLE, 5)
            oprot.writeDouble(self.rad)
            oprot.writeFieldEnd()
        if self.qnear is not None:
            oprot.writeFieldBegin('qnear', TType.LIST, 6)
            oprot.writeListBegin(TType.DOUBLE, len(self.qnear))
            for iter1358 in self.qnear:
                oprot.writeDouble(iter1358)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 7)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 8)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 9)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        if self.epose is not None:
            oprot.writeFieldBegin('epose', TType.LIST, 10)
            oprot.writeListBegin(TType.DOUBLE, len(self.epose))
            for iter1359 in self.epose:
                oprot.writeDouble(iter1359)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.eaxis_v is not None:
            oprot.writeFieldBegin('eaxis_v', TType.DOUBLE, 11)
            oprot.writeDouble(self.eaxis_v)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 12)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 13)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 14)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 15)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movec_eaxis_args)
movec_eaxis_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'rad', None, None, ),  # 5
    (6, TType.LIST, 'qnear', (TType.DOUBLE, None, False), None, ),  # 6
    (7, TType.STRING, 'tool', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'wobj', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 9
    (10, TType.LIST, 'epose', (TType.DOUBLE, None, False), None, ),  # 10
    (11, TType.DOUBLE, 'eaxis_v', None, None, ),  # 11
    (12, TType.BOOL, 'block', None, None, ),  # 12
    (13, TType.STRUCT, 'op', [Op, None], None, ),  # 13
    (14, TType.BOOL, 'def_acc', None, None, ),  # 14
    (15, TType.I32, 'mode', None, None, ),  # 15
)


class movec_eaxis_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('movec_eaxis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(movec_eaxis_result)
movec_eaxis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class move_circle_eaxis_args(object):
    """
    Attributes:
     - p1
     - p2
     - v
     - a
     - rad
     - mode
     - qnear
     - tool
     - wobj
     - scheme_name
     - epose
     - eaxis_v
     - block
     - op
     - def_acc

    """


    def __init__(self, p1=None, p2=None, v=None, a=None, rad=None, mode=None, qnear=None, tool=None, wobj=None, scheme_name=None, epose=None, eaxis_v=None, block=None, op=None, def_acc=None,):
        self.p1 = p1
        self.p2 = p2
        self.v = v
        self.a = a
        self.rad = rad
        self.mode = mode
        self.qnear = qnear
        self.tool = tool
        self.wobj = wobj
        self.scheme_name = scheme_name
        self.epose = epose
        self.eaxis_v = eaxis_v
        self.block = block
        self.op = op
        self.def_acc = def_acc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.p1 = []
                    (_etype1363, _size1360) = iprot.readListBegin()
                    for _i1364 in range(_size1360):
                        _elem1365 = iprot.readDouble()
                        self.p1.append(_elem1365)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.p2 = []
                    (_etype1369, _size1366) = iprot.readListBegin()
                    for _i1370 in range(_size1366):
                        _elem1371 = iprot.readDouble()
                        self.p2.append(_elem1371)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.a = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.rad = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.qnear = []
                    (_etype1375, _size1372) = iprot.readListBegin()
                    for _i1376 in range(_size1372):
                        _elem1377 = iprot.readDouble()
                        self.qnear.append(_elem1377)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.tool = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.wobj = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.scheme_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.epose = []
                    (_etype1381, _size1378) = iprot.readListBegin()
                    for _i1382 in range(_size1378):
                        _elem1383 = iprot.readDouble()
                        self.epose.append(_elem1383)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.DOUBLE:
                    self.eaxis_v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.op = Op()
                    self.op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.def_acc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_circle_eaxis_args')
        if self.p1 is not None:
            oprot.writeFieldBegin('p1', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.p1))
            for iter1384 in self.p1:
                oprot.writeDouble(iter1384)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.p2 is not None:
            oprot.writeFieldBegin('p2', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.p2))
            for iter1385 in self.p2:
                oprot.writeDouble(iter1385)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 3)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.DOUBLE, 4)
            oprot.writeDouble(self.a)
            oprot.writeFieldEnd()
        if self.rad is not None:
            oprot.writeFieldBegin('rad', TType.DOUBLE, 5)
            oprot.writeDouble(self.rad)
            oprot.writeFieldEnd()
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 6)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        if self.qnear is not None:
            oprot.writeFieldBegin('qnear', TType.LIST, 7)
            oprot.writeListBegin(TType.DOUBLE, len(self.qnear))
            for iter1386 in self.qnear:
                oprot.writeDouble(iter1386)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.STRING, 8)
            oprot.writeString(self.tool.encode('utf-8') if sys.version_info[0] == 2 else self.tool)
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.STRING, 9)
            oprot.writeString(self.wobj.encode('utf-8') if sys.version_info[0] == 2 else self.wobj)
            oprot.writeFieldEnd()
        if self.scheme_name is not None:
            oprot.writeFieldBegin('scheme_name', TType.STRING, 10)
            oprot.writeString(self.scheme_name.encode('utf-8') if sys.version_info[0] == 2 else self.scheme_name)
            oprot.writeFieldEnd()
        if self.epose is not None:
            oprot.writeFieldBegin('epose', TType.LIST, 11)
            oprot.writeListBegin(TType.DOUBLE, len(self.epose))
            for iter1387 in self.epose:
                oprot.writeDouble(iter1387)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.eaxis_v is not None:
            oprot.writeFieldBegin('eaxis_v', TType.DOUBLE, 12)
            oprot.writeDouble(self.eaxis_v)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 13)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.STRUCT, 14)
            self.op.write(oprot)
            oprot.writeFieldEnd()
        if self.def_acc is not None:
            oprot.writeFieldBegin('def_acc', TType.BOOL, 15)
            oprot.writeBool(self.def_acc)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_circle_eaxis_args)
move_circle_eaxis_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'p1', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'p2', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.DOUBLE, 'v', None, None, ),  # 3
    (4, TType.DOUBLE, 'a', None, None, ),  # 4
    (5, TType.DOUBLE, 'rad', None, None, ),  # 5
    (6, TType.I32, 'mode', None, None, ),  # 6
    (7, TType.LIST, 'qnear', (TType.DOUBLE, None, False), None, ),  # 7
    (8, TType.STRING, 'tool', 'UTF8', None, ),  # 8
    (9, TType.STRING, 'wobj', 'UTF8', None, ),  # 9
    (10, TType.STRING, 'scheme_name', 'UTF8', None, ),  # 10
    (11, TType.LIST, 'epose', (TType.DOUBLE, None, False), None, ),  # 11
    (12, TType.DOUBLE, 'eaxis_v', None, None, ),  # 12
    (13, TType.BOOL, 'block', None, None, ),  # 13
    (14, TType.STRUCT, 'op', [Op, None], None, ),  # 14
    (15, TType.BOOL, 'def_acc', None, None, ),  # 15
)


class move_circle_eaxis_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_circle_eaxis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_circle_eaxis_result)
move_circle_eaxis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class reach_check_args(object):
    """
    Attributes:
     - base
     - wobj
     - tool
     - ref_pos
     - check_points

    """


    def __init__(self, base=None, wobj=None, tool=None, ref_pos=None, check_points=None,):
        self.base = base
        self.wobj = wobj
        self.tool = tool
        self.ref_pos = ref_pos
        self.check_points = check_points

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.base = []
                    (_etype1391, _size1388) = iprot.readListBegin()
                    for _i1392 in range(_size1388):
                        _elem1393 = iprot.readDouble()
                        self.base.append(_elem1393)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.wobj = []
                    (_etype1397, _size1394) = iprot.readListBegin()
                    for _i1398 in range(_size1394):
                        _elem1399 = iprot.readDouble()
                        self.wobj.append(_elem1399)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tool = []
                    (_etype1403, _size1400) = iprot.readListBegin()
                    for _i1404 in range(_size1400):
                        _elem1405 = iprot.readDouble()
                        self.tool.append(_elem1405)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ref_pos = []
                    (_etype1409, _size1406) = iprot.readListBegin()
                    for _i1410 in range(_size1406):
                        _elem1411 = iprot.readDouble()
                        self.ref_pos.append(_elem1411)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.check_points = []
                    (_etype1415, _size1412) = iprot.readListBegin()
                    for _i1416 in range(_size1412):
                        _elem1417 = []
                        (_etype1421, _size1418) = iprot.readListBegin()
                        for _i1422 in range(_size1418):
                            _elem1423 = iprot.readDouble()
                            _elem1417.append(_elem1423)
                        iprot.readListEnd()
                        self.check_points.append(_elem1417)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reach_check_args')
        if self.base is not None:
            oprot.writeFieldBegin('base', TType.LIST, 1)
            oprot.writeListBegin(TType.DOUBLE, len(self.base))
            for iter1424 in self.base:
                oprot.writeDouble(iter1424)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.wobj is not None:
            oprot.writeFieldBegin('wobj', TType.LIST, 2)
            oprot.writeListBegin(TType.DOUBLE, len(self.wobj))
            for iter1425 in self.wobj:
                oprot.writeDouble(iter1425)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tool is not None:
            oprot.writeFieldBegin('tool', TType.LIST, 3)
            oprot.writeListBegin(TType.DOUBLE, len(self.tool))
            for iter1426 in self.tool:
                oprot.writeDouble(iter1426)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ref_pos is not None:
            oprot.writeFieldBegin('ref_pos', TType.LIST, 4)
            oprot.writeListBegin(TType.DOUBLE, len(self.ref_pos))
            for iter1427 in self.ref_pos:
                oprot.writeDouble(iter1427)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.check_points is not None:
            oprot.writeFieldBegin('check_points', TType.LIST, 5)
            oprot.writeListBegin(TType.LIST, len(self.check_points))
            for iter1428 in self.check_points:
                oprot.writeListBegin(TType.DOUBLE, len(iter1428))
                for iter1429 in iter1428:
                    oprot.writeDouble(iter1429)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reach_check_args)
reach_check_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'base', (TType.DOUBLE, None, False), None, ),  # 1
    (2, TType.LIST, 'wobj', (TType.DOUBLE, None, False), None, ),  # 2
    (3, TType.LIST, 'tool', (TType.DOUBLE, None, False), None, ),  # 3
    (4, TType.LIST, 'ref_pos', (TType.DOUBLE, None, False), None, ),  # 4
    (5, TType.LIST, 'check_points', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 5
)


class reach_check_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReachabilityParam()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('reach_check_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(reach_check_result)
reach_check_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReachabilityParam, None], None, ),  # 0
)


class move_jog_eaxis_args(object):
    """
    Attributes:
     - name
     - direction
     - vel
     - block

    """


    def __init__(self, name=None, direction=None, vel=None, block=None,):
        self.name = name
        self.direction = direction
        self.vel = vel
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.vel = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_jog_eaxis_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 2)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.vel is not None:
            oprot.writeFieldBegin('vel', TType.DOUBLE, 3)
            oprot.writeDouble(self.vel)
            oprot.writeFieldEnd()
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 4)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_jog_eaxis_args)
move_jog_eaxis_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'direction', None, None, ),  # 2
    (3, TType.DOUBLE, 'vel', None, None, ),  # 3
    (4, TType.BOOL, 'block', None, None, ),  # 4
)


class move_jog_eaxis_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('move_jog_eaxis_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(move_jog_eaxis_result)
move_jog_eaxis_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_eaxis_info_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_eaxis_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_eaxis_info_args)
get_eaxis_info_args.thrift_spec = (
)


class get_eaxis_info_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1433, _size1430) = iprot.readListBegin()
                    for _i1434 in range(_size1430):
                        _elem1435 = EAxissInfo()
                        _elem1435.read(iprot)
                        self.success.append(_elem1435)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_eaxis_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter1436 in self.success:
                iter1436.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_eaxis_info_result)
get_eaxis_info_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [EAxissInfo, None], False), None, ),  # 0
)


class set_hand_teach_parameter_args(object):
    """
    Attributes:
     - space
     - joint_scale
     - cart_scale
     - coord_type
     - direction

    """


    def __init__(self, space=None, joint_scale=None, cart_scale=None, coord_type=None, direction=None,):
        self.space = space
        self.joint_scale = joint_scale
        self.cart_scale = cart_scale
        self.coord_type = coord_type
        self.direction = direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.space = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.joint_scale = []
                    (_etype1440, _size1437) = iprot.readListBegin()
                    for _i1441 in range(_size1437):
                        _elem1442 = iprot.readI32()
                        self.joint_scale.append(_elem1442)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.cart_scale = []
                    (_etype1446, _size1443) = iprot.readListBegin()
                    for _i1447 in range(_size1443):
                        _elem1448 = iprot.readI32()
                        self.cart_scale.append(_elem1448)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.coord_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.direction = []
                    (_etype1452, _size1449) = iprot.readListBegin()
                    for _i1453 in range(_size1449):
                        _elem1454 = iprot.readBool()
                        self.direction.append(_elem1454)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_hand_teach_parameter_args')
        if self.space is not None:
            oprot.writeFieldBegin('space', TType.I32, 1)
            oprot.writeI32(self.space)
            oprot.writeFieldEnd()
        if self.joint_scale is not None:
            oprot.writeFieldBegin('joint_scale', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.joint_scale))
            for iter1455 in self.joint_scale:
                oprot.writeI32(iter1455)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cart_scale is not None:
            oprot.writeFieldBegin('cart_scale', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.cart_scale))
            for iter1456 in self.cart_scale:
                oprot.writeI32(iter1456)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.coord_type is not None:
            oprot.writeFieldBegin('coord_type', TType.I32, 4)
            oprot.writeI32(self.coord_type)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.LIST, 5)
            oprot.writeListBegin(TType.BOOL, len(self.direction))
            for iter1457 in self.direction:
                oprot.writeBool(iter1457)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_hand_teach_parameter_args)
set_hand_teach_parameter_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'space', None, None, ),  # 1
    (2, TType.LIST, 'joint_scale', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'cart_scale', (TType.I32, None, False), None, ),  # 3
    (4, TType.I32, 'coord_type', None, None, ),  # 4
    (5, TType.LIST, 'direction', (TType.BOOL, None, False), None, ),  # 5
)


class set_hand_teach_parameter_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_hand_teach_parameter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_hand_teach_parameter_result)
set_hand_teach_parameter_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_pendant_type_args(object):
    """
    Attributes:
     - type

    """


    def __init__(self, type=None,):
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_pendant_type_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_pendant_type_args)
set_pendant_type_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
)


class set_pendant_type_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_pendant_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_pendant_type_result)
set_pendant_type_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_blend_ahead_args(object):
    """
    Attributes:
     - per
     - num

    """


    def __init__(self, per=None, num=None,):
        self.per = per
        self.num = num

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.per = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_blend_ahead_args')
        if self.per is not None:
            oprot.writeFieldBegin('per', TType.I32, 1)
            oprot.writeI32(self.per)
            oprot.writeFieldEnd()
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 2)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_blend_ahead_args)
set_blend_ahead_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'per', None, None, ),  # 1
    (2, TType.I32, 'num', None, None, ),  # 2
)


class set_blend_ahead_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_blend_ahead_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_blend_ahead_result)
set_blend_ahead_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class switch_mode_args(object):
    """
    Attributes:
     - mode

    """


    def __init__(self, mode=None,):
        self.mode = mode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.mode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('switch_mode_args')
        if self.mode is not None:
            oprot.writeFieldBegin('mode', TType.I32, 1)
            oprot.writeI32(self.mode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(switch_mode_args)
switch_mode_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'mode', None, None, ),  # 1
)


class switch_mode_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('switch_mode_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(switch_mode_result)
switch_mode_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class read_encoder_count_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_encoder_count_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_encoder_count_args)
read_encoder_count_args.thrift_spec = (
)


class read_encoder_count_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_encoder_count_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_encoder_count_result)
read_encoder_count_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class set_kinematic_calibration_params_args(object):
    """
    Attributes:
     - params

    """


    def __init__(self, params=None,):
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.params = []
                    (_etype1461, _size1458) = iprot.readListBegin()
                    for _i1462 in range(_size1458):
                        _elem1463 = []
                        (_etype1467, _size1464) = iprot.readListBegin()
                        for _i1468 in range(_size1464):
                            _elem1469 = iprot.readDouble()
                            _elem1463.append(_elem1469)
                        iprot.readListEnd()
                        self.params.append(_elem1463)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_kinematic_calibration_params_args')
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.params))
            for iter1470 in self.params:
                oprot.writeListBegin(TType.DOUBLE, len(iter1470))
                for iter1471 in iter1470:
                    oprot.writeDouble(iter1471)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_kinematic_calibration_params_args)
set_kinematic_calibration_params_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'params', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
)


class set_kinematic_calibration_params_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_kinematic_calibration_params_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_kinematic_calibration_params_result)
set_kinematic_calibration_params_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_pos_bias_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pos_bias_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pos_bias_args)
get_pos_bias_args.thrift_spec = (
)


class get_pos_bias_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1475, _size1472) = iprot.readListBegin()
                    for _i1476 in range(_size1472):
                        _elem1477 = iprot.readDouble()
                        self.success.append(_elem1477)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_pos_bias_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1478 in self.success:
                oprot.writeDouble(iter1478)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_pos_bias_result)
get_pos_bias_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_system_value_lists_args(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_lists_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_lists_args)
get_system_value_lists_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
)


class get_system_value_lists_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1482, _size1479) = iprot.readListBegin()
                    for _i1483 in range(_size1479):
                        _elem1484 = []
                        (_etype1488, _size1485) = iprot.readListBegin()
                        for _i1489 in range(_size1485):
                            _elem1490 = iprot.readDouble()
                            _elem1484.append(_elem1490)
                        iprot.readListEnd()
                        self.success.append(_elem1484)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_system_value_lists_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter1491 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter1491))
                for iter1492 in iter1491:
                    oprot.writeDouble(iter1492)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_system_value_lists_result)
get_system_value_lists_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class get_origin_DH_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_origin_DH_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_origin_DH_args)
get_origin_DH_args.thrift_spec = (
)


class get_origin_DH_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1496, _size1493) = iprot.readListBegin()
                    for _i1497 in range(_size1493):
                        _elem1498 = []
                        (_etype1502, _size1499) = iprot.readListBegin()
                        for _i1503 in range(_size1499):
                            _elem1504 = iprot.readDouble()
                            _elem1498.append(_elem1504)
                        iprot.readListEnd()
                        self.success.append(_elem1498)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_origin_DH_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter1505 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter1505))
                for iter1506 in iter1505:
                    oprot.writeDouble(iter1506)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_origin_DH_result)
get_origin_DH_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class get_calib_DH_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_calib_DH_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_calib_DH_args)
get_calib_DH_args.thrift_spec = (
)


class get_calib_DH_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1510, _size1507) = iprot.readListBegin()
                    for _i1511 in range(_size1507):
                        _elem1512 = []
                        (_etype1516, _size1513) = iprot.readListBegin()
                        for _i1517 in range(_size1513):
                            _elem1518 = iprot.readDouble()
                            _elem1512.append(_elem1518)
                        iprot.readListEnd()
                        self.success.append(_elem1512)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_calib_DH_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter1519 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter1519))
                for iter1520 in iter1519:
                    oprot.writeDouble(iter1520)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_calib_DH_result)
get_calib_DH_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class get_robot_type_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_type_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_type_args)
get_robot_type_args.thrift_spec = (
)


class get_robot_type_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1524, _size1521) = iprot.readListBegin()
                    for _i1525 in range(_size1521):
                        _elem1526 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem1526)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_robot_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter1527 in self.success:
                oprot.writeString(iter1527.encode('utf-8') if sys.version_info[0] == 2 else iter1527)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_robot_type_result)
get_robot_type_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class get_ext_torque_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_ext_torque_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_ext_torque_args)
get_ext_torque_args.thrift_spec = (
)


class get_ext_torque_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1531, _size1528) = iprot.readListBegin()
                    for _i1532 in range(_size1528):
                        _elem1533 = iprot.readDouble()
                        self.success.append(_elem1533)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_ext_torque_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1534 in self.success:
                oprot.writeDouble(iter1534)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_ext_torque_result)
get_ext_torque_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class set_dynamic_calibration_params_args(object):
    """
    Attributes:
     - params

    """


    def __init__(self, params=None,):
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.params = []
                    (_etype1538, _size1535) = iprot.readListBegin()
                    for _i1539 in range(_size1535):
                        _elem1540 = []
                        (_etype1544, _size1541) = iprot.readListBegin()
                        for _i1545 in range(_size1541):
                            _elem1546 = iprot.readDouble()
                            _elem1540.append(_elem1546)
                        iprot.readListEnd()
                        self.params.append(_elem1540)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_dynamic_calibration_params_args')
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.params))
            for iter1547 in self.params:
                oprot.writeListBegin(TType.DOUBLE, len(iter1547))
                for iter1548 in iter1547:
                    oprot.writeDouble(iter1548)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_dynamic_calibration_params_args)
set_dynamic_calibration_params_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'params', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 1
)


class set_dynamic_calibration_params_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_dynamic_calibration_params_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_dynamic_calibration_params_result)
set_dynamic_calibration_params_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_dynamic_calibration_params_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dynamic_calibration_params_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dynamic_calibration_params_args)
get_dynamic_calibration_params_args.thrift_spec = (
)


class get_dynamic_calibration_params_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1552, _size1549) = iprot.readListBegin()
                    for _i1553 in range(_size1549):
                        _elem1554 = []
                        (_etype1558, _size1555) = iprot.readListBegin()
                        for _i1559 in range(_size1555):
                            _elem1560 = iprot.readDouble()
                            _elem1554.append(_elem1560)
                        iprot.readListEnd()
                        self.success.append(_elem1554)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_dynamic_calibration_params_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter1561 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter1561))
                for iter1562 in iter1561:
                    oprot.writeDouble(iter1562)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_dynamic_calibration_params_result)
get_dynamic_calibration_params_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class upload_robot_param_to_toolboard_args(object):
    """
    Attributes:
     - passwd

    """


    def __init__(self, passwd=None,):
        self.passwd = passwd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('upload_robot_param_to_toolboard_args')
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 1)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(upload_robot_param_to_toolboard_args)
upload_robot_param_to_toolboard_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'passwd', 'UTF8', None, ),  # 1
)


class upload_robot_param_to_toolboard_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('upload_robot_param_to_toolboard_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(upload_robot_param_to_toolboard_result)
upload_robot_param_to_toolboard_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_kinematic_calibration_info_args(object):
    """
    Attributes:
     - passwd
     - info

    """


    def __init__(self, passwd=None, info=None,):
        self.passwd = passwd
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.info = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_kinematic_calibration_info_args')
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 1)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRING, 2)
            oprot.writeString(self.info.encode('utf-8') if sys.version_info[0] == 2 else self.info)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_kinematic_calibration_info_args)
set_kinematic_calibration_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'passwd', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'info', 'UTF8', None, ),  # 2
)


class set_kinematic_calibration_info_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_kinematic_calibration_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_kinematic_calibration_info_result)
set_kinematic_calibration_info_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_dynamic_calibration_info_args(object):
    """
    Attributes:
     - passwd
     - info

    """


    def __init__(self, passwd=None, info=None,):
        self.passwd = passwd
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.info = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_dynamic_calibration_info_args')
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 1)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRING, 2)
            oprot.writeString(self.info.encode('utf-8') if sys.version_info[0] == 2 else self.info)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_dynamic_calibration_info_args)
set_dynamic_calibration_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'passwd', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'info', 'UTF8', None, ),  # 2
)


class set_dynamic_calibration_info_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_dynamic_calibration_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_dynamic_calibration_info_result)
set_dynamic_calibration_info_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class set_vibration_calibration_info_args(object):
    """
    Attributes:
     - passwd
     - info

    """


    def __init__(self, passwd=None, info=None,):
        self.passwd = passwd
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.info = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_vibration_calibration_info_args')
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 1)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRING, 2)
            oprot.writeString(self.info.encode('utf-8') if sys.version_info[0] == 2 else self.info)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_vibration_calibration_info_args)
set_vibration_calibration_info_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'passwd', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'info', 'UTF8', None, ),  # 2
)


class set_vibration_calibration_info_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('set_vibration_calibration_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(set_vibration_calibration_info_result)
set_vibration_calibration_info_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_axis_motor_rated_current_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_axis_motor_rated_current_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_axis_motor_rated_current_args)
get_axis_motor_rated_current_args.thrift_spec = (
)


class get_axis_motor_rated_current_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1566, _size1563) = iprot.readListBegin()
                    for _i1567 in range(_size1563):
                        _elem1568 = iprot.readDouble()
                        self.success.append(_elem1568)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_axis_motor_rated_current_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1569 in self.success:
                oprot.writeDouble(iter1569)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_axis_motor_rated_current_result)
get_axis_motor_rated_current_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class get_axis_motor_kt_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_axis_motor_kt_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_axis_motor_kt_args)
get_axis_motor_kt_args.thrift_spec = (
)


class get_axis_motor_kt_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1573, _size1570) = iprot.readListBegin()
                    for _i1574 in range(_size1570):
                        _elem1575 = iprot.readDouble()
                        self.success.append(_elem1575)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_axis_motor_kt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.DOUBLE, len(self.success))
            for iter1576 in self.success:
                oprot.writeDouble(iter1576)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_axis_motor_kt_result)
get_axis_motor_kt_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.DOUBLE, None, False), None, ),  # 0
)


class abort_args(object):
    """
    Attributes:
     - block

    """


    def __init__(self, block=None,):
        self.block = block

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.block = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_args')
        if self.block is not None:
            oprot.writeFieldBegin('block', TType.BOOL, 1)
            oprot.writeBool(self.block)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_args)
abort_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'block', None, None, ),  # 1
)


class abort_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('abort_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(abort_result)
abort_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class get_vibration_calibration_params_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_vibration_calibration_params_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_vibration_calibration_params_args)
get_vibration_calibration_params_args.thrift_spec = (
)


class get_vibration_calibration_params_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype1580, _size1577) = iprot.readListBegin()
                    for _i1581 in range(_size1577):
                        _elem1582 = []
                        (_etype1586, _size1583) = iprot.readListBegin()
                        for _i1587 in range(_size1583):
                            _elem1588 = iprot.readDouble()
                            _elem1582.append(_elem1588)
                        iprot.readListEnd()
                        self.success.append(_elem1582)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_vibration_calibration_params_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.LIST, len(self.success))
            for iter1589 in self.success:
                oprot.writeListBegin(TType.DOUBLE, len(iter1589))
                for iter1590 in iter1589:
                    oprot.writeDouble(iter1590)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_vibration_calibration_params_result)
get_vibration_calibration_params_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.LIST, (TType.DOUBLE, None, False), False), None, ),  # 0
)


class save_kinematic_calibration_params_args(object):
    """
    Attributes:
     - passwd

    """


    def __init__(self, passwd=None,):
        self.passwd = passwd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('save_kinematic_calibration_params_args')
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 1)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(save_kinematic_calibration_params_args)
save_kinematic_calibration_params_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'passwd', 'UTF8', None, ),  # 1
)


class save_kinematic_calibration_params_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('save_kinematic_calibration_params_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(save_kinematic_calibration_params_result)
save_kinematic_calibration_params_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class save_dynamic_calibration_params_args(object):
    """
    Attributes:
     - passwd

    """


    def __init__(self, passwd=None,):
        self.passwd = passwd

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.passwd = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('save_dynamic_calibration_params_args')
        if self.passwd is not None:
            oprot.writeFieldBegin('passwd', TType.STRING, 1)
            oprot.writeString(self.passwd.encode('utf-8') if sys.version_info[0] == 2 else self.passwd)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(save_dynamic_calibration_params_args)
save_dynamic_calibration_params_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'passwd', 'UTF8', None, ),  # 1
)


class save_dynamic_calibration_params_result(object):
    """
    Attributes:
     - success

    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('save_dynamic_calibration_params_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(save_dynamic_calibration_params_result)
save_dynamic_calibration_params_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)
fix_spec(all_structs)
del all_structs

